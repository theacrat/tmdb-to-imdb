/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = T | null | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * A name identifier for a given action link in a CTA. This value is only unique within a list of action links.
   * It is not globally unique.
   */
  ActionLinkName: { input: any; output: any; }
  /** A date string in the ISO-8601 format: https://www.iso.org/iso-8601-date-and-time-format.html */
  Date: { input: any; output: any; }
  /**
   * A datetime string in the ISO-8601 format: https://www.iso.org/iso-8601-date-and-time-format.html
   * (e.g. 2020-05-11T18:15:55Z)
   */
  DateTime: { input: any; output: any; }
  /**
   * A BCP-47 String with the primary language in ISO 639-1 followed by
   * a dash and ISO 3166-1 or UN M.49 code (e.g en-US es-419 fr-FR)
   *
   * https://en.wikipedia.org/wiki/ISO_639-1
   * https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
   * https://en.wikipedia.org/wiki/UN_M.49
   */
  Language: { input: any; output: any; }
  /** A decimal used for a latitude or longitude degree value. If more granular location data is given than one hundredth of a degree, the request will be rejected. */
  LocationDecimal: { input: any; output: any; }
  /** A month and day string in the ISO-8601 format, for example '--06-19' */
  MonthDay: { input: any; output: any; }
  /**
   * An identifier for a given result of a CTA. This value is only unique within the CTA. It is not globally unique.
   * When provided as a resultOverride, the value must match a resultId for one of the results of the requested CTA.
   * Otherwise it will be ignored and the evaluated result for the CTA will be returned.
   * If it does match to a result, the back-end conditional logic is skipped and the matching result is returned.
   * If the CTA supports a "do not display" result, the resultId to use for override will be "DoNotDisplayResult".
   * Result override should be used for testing purposes only.
   */
  ResultID: { input: any; output: any; }
  /**
   * The type to represent a URL for some resource. Format is as follows:
   *
   * scheme:[userinfo@]host[:port]path[?query][#fragment]
   *
   * https://en.wikipedia.org/wiki/URL
   */
  URL: { input: any; output: any; }
};

export enum AccountDataDialogInput {
  /** Retrieve the dialog for confirming account data access request */
  Confirm = 'CONFIRM',
  /** Retrieve the dialog for requesting account data access */
  Request = 'REQUEST'
}

export type AccountDataDialogOutput = {
  __typename?: 'AccountDataDialogOutput';
  /** Provides prompt text for either a data access REQUEST or CONFIRM */
  prompt: LocalizedMarkdown;
  /**
   * A prompt to instruct Amazon Account Pool customers to initiate the data request process on Amazon page.
   * Null if not Amazon Account Pool customers.
   */
  redirectionPrompt?: Maybe<AccountDataDialogRedirectionPrompt>;
  /** Provides supporting body text for either a data access REQUEST or CONFIRM */
  supportMessage: LocalizedMarkdown;
};

export type AccountDataDialogRedirectionPrompt = {
  __typename?: 'AccountDataDialogRedirectionPrompt';
  /** Link to the Amazon page. */
  action: RedirectLink;
  /** Text to instruct customers to initiate the data request process on Amazon page. */
  message: LocalizedMarkdown;
};

/** Generic type for an action link which has a url and optionally associated label (localized text) */
export type ActionLink = {
  __typename?: 'ActionLink';
  /**
   * Optional label (localized text) to associate with URL.
   * The label could be used with a button, text link, or other UI component.
   */
  label?: Maybe<CallToActionText>;
  /** The URL for the action link */
  url: Scalars['String']['output'];
};

export type AdCreativeInfo = {
  __typename?: 'AdCreativeInfo';
  /** Flag used to communicate if the ad creative contains a video to be autoplayed by the client. */
  hasAutoplay: Scalars['Boolean']['output'];
  /** Flag that determines if the app slot is eligible to render 3p ad. */
  isEligibleFor3pAd: Scalars['Boolean']['output'];
  /** Flag used to communicate if the ad returned is premium. */
  isPremium: Scalars['Boolean']['output'];
  /** Flag used to indicate if the client should fit the ad creative to the width of the screen. */
  shouldFitToWidth: Scalars['Boolean']['output'];
  /** Metadata including height and width of the returned creative */
  size: CreativeSize;
  /** HTML markup for the slot containing the ad creative */
  slotMarkup: Scalars['String']['output'];
};

/**
 * An entry to the ad layout slot configuration map containing an ad layout type and a list of supported slots
 * and their configurations.
 */
export type AdLayoutConfiguration = {
  __typename?: 'AdLayoutConfiguration';
  /** The ad layout type represented as a string. */
  adLayoutType: Scalars['String']['output'];
  /** A list of AdSlotConfigurations. */
  adSlotConfigs: Array<Maybe<AdSlotConfiguration>>;
};

/**
 * Required and optional parameters used to form the VAES request URL that come from the context of the app client.
 * Optional params default to null when not present.
 */
export type AdParametersApp = {
  /** Flag used to communicate whether the ad is for an autostarted video. Impacts slot name and placement type. */
  autoStartVideo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optional context of the page used for special section targeting - i.e. oscars.bestOf */
  context?: InputMaybe<Scalars['String']['input']>;
  /** The device id of the client */
  deviceId?: InputMaybe<Scalars['String']['input']>;
  /** The device info of the client. Used in the backend IMDb advertising systems to determine ad placement related info. */
  deviceInfo: DeviceInfo;
  /** The Identifier For Advertising of the user */
  idfa?: InputMaybe<Scalars['String']['input']>;
  /** The page type the query was made from */
  pageType?: InputMaybe<Scalars['String']['input']>;
  /** The subpage type the query was made from */
  subPageType?: InputMaybe<Scalars['String']['input']>;
  /** The user agent of the client. This field is passed to Amazon ad systems via the backend ad requests. */
  userAgent?: InputMaybe<Scalars['String']['input']>;
  /** The viewport size of the client's device */
  viewportSize?: InputMaybe<ViewPortSize>;
};

/**
 * Optional parameters used to form the VAES request URL that come from the context of the web client.
 * All params default to null when not present.
 */
export type AdParametersWeb = {
  /** Flag used to communicate whether the ad is for an autostarted video. Impacts slot name and placement type. */
  autoStartVideo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optional context of the page used for special section targeting - i.e. oscars.bestOf */
  context?: InputMaybe<Scalars['String']['input']>;
  /** The page type the query was made from */
  pageType?: InputMaybe<Scalars['String']['input']>;
  /** The subpage type the query was made from */
  subPageType?: InputMaybe<Scalars['String']['input']>;
  /** The user agent of the client */
  userAgent?: InputMaybe<Scalars['String']['input']>;
  /** The viewport size of the client's device */
  viewportSize?: InputMaybe<ViewPortSize>;
};

/** Attributes of an ad product */
export type AdProductType = {
  __typename?: 'AdProductType';
  /**
   * Enumeration of the relative specialness of this AdProductType.
   * Values include "standard" and "premium".
   */
  grade: Scalars['String']['output'];
  /**
   * Name of the ad product. Human readable, but not intended for display.
   * Values include "premium-page".
   */
  name: Scalars['String']['output'];
  /**
   * A 3-character symbol for this ad product.
   * Values include "prm".
   */
  symbol: Scalars['String']['output'];
};

/** The IMDb site variant on which the ads are intended to be shown */
export enum AdSite {
  BoxOfficeMojo = 'BOX_OFFICE_MOJO',
  Consumer = 'CONSUMER',
  Mobile = 'MOBILE'
}

export type AdSlot = {
  __typename?: 'AdSlot';
  /** Ad feedback URL to be linked in the sponsored label of the ad */
  adFeedbackUrl?: Maybe<Scalars['URL']['output']>;
  /** The creative metadata and slotsMarkup returned for the given ad slot */
  creativeInfo: AdCreativeInfo;
  /** The name of the ad slot */
  name: Scalars['String']['output'];
};

/** The configuration for an ad slot. */
export type AdSlotConfiguration = {
  __typename?: 'AdSlotConfiguration';
  /**
   * The APS configuration for the ad slot in this AdSlotConfiguration. The config
   * contain information for each supported APS placement for the slot.
   * When this field is missing, the client will not make any 3p ad requests for this slot.
   */
  apsConfig?: Maybe<ApsConfiguration>;
  /** The IMDb slot name (e.g. inline20). */
  name: Scalars['String']['output'];
  /** The width and height of the slot. */
  size: CreativeSize;
};

export type AdditionalCreditCategoriesInput = {
  /**
   * The categories to be excluded from the request.
   *
   * If no value is provided, no categories are excluded.
   */
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * The categories to be include in the request.
   *
   * If no value is provided, all categories are returned.
   */
  includeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/**
 * This is an unverified Resume credit, which Pro customers can create for display on
 *   their pro name page. These credits are not vetted and are accepted as is.
 */
export type AdditionalCreditItem = {
  __typename?: 'AdditionalCreditItem';
  /** The name of the category of the credit. */
  category: LocalizedString;
  /** The name of the company or director that made the project. */
  details: LocalizedString;
  /** Unique identifier for the additional credit object. */
  id: Scalars['ID']['output'];
  /** The role or position the individual had on the project. */
  job: LocalizedString;
  /** The name or title of the project. */
  title: LocalizedString;
};

export type AdditionalResumeInfo = {
  __typename?: 'AdditionalResumeInfo';
  /** The details for an additional resume info section. */
  details?: Maybe<LocalizedString>;
  /** Unique identifier for the additional resume info object. */
  id: Scalars['ID']['output'];
  /** The title for the additional resume info section. */
  title?: Maybe<LocalizedString>;
};

export type AdditionalResumeInfoConnection = {
  __typename?: 'AdditionalResumeInfoConnection';
  edges: Array<Maybe<AdditionalResumeInfoEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type AdditionalResumeInfoEdge = {
  __typename?: 'AdditionalResumeInfoEdge';
  cursor: Scalars['ID']['output'];
  node: AdditionalResumeInfo;
  position: Scalars['Int']['output'];
};

export type AdditionalWebAuthContext = {
  /** 'Unique browser ID' i.e ubid context identifier, which in practice means an identifier for the domain+browser combination. */
  clientContext: Scalars['String']['input'];
};

export type AdvancedNameSearchConnection = {
  __typename?: 'AdvancedNameSearchConnection';
  edges: Array<Maybe<AdvancedNameSearchEdge>>;
  facet?: Maybe<Array<Maybe<SearchFacet>>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};


export type AdvancedNameSearchConnectionFacetArgs = {
  facetField: NameFacetField;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type AdvancedNameSearchConstraints = {
  /** Match names based on their awards (Oscar-winner, Oscar-nominated, etc..) */
  awardConstraint?: InputMaybe<AwardSearchConstraint>;
  /** Match names based on words in their biography, or the biography's author (currently only searches in miniBiography) */
  biographyConstraint?: InputMaybe<BiographySearchConstraint>;
  /** Match names based on when they were born */
  birthDateConstraint?: InputMaybe<BirthDateSearchConstraint>;
  /** Match names based on their birth place */
  birthPlaceConstraint?: InputMaybe<BirthPlaceSearchConstraint>;
  /** Match names based on when they died */
  deathDateConstraint?: InputMaybe<DeathDateSearchConstraint>;
  /** Match names based on their death place */
  deathPlaceConstraint?: InputMaybe<DeathPlaceSearchConstraint>;
  /** Match names based on the adult flag (explicit), with the default being exluding names flagged as adult */
  explicitContentConstraint?: InputMaybe<ExplicitContentSearchConstraint>;
  /** Match names based on titles they've been credited in */
  filmographyConstraint?: InputMaybe<FilmographySearchConstraint>;
  /** Match names based on their gender identity */
  genderIdentityConstraint?: InputMaybe<GenderIdentitySearchConstraint>;
  /**
   * Match names based on their presence in lists.
   *
   * If any list specified in this constraint is not a list of Names then
   * `GRAPHQL_VALIDATION_FAILED` will be thrown.
   *
   * Specifying lists that contain in aggregate a large number of Names may
   * trigger an error due to query term limits imposed by the implementation. Note
   * that this term count limit is for the overall query, not just this constraint.
   */
  listConstraint?: InputMaybe<ListSearchConstraint>;
  /** Match names based on their name (name text) */
  nameTextConstraint?: InputMaybe<NameTextSearchConstraint>;
  /** Match names based on their profession categories */
  professionCategoryConstraint?: InputMaybe<NameProfessionCategorySearchConstraint>;
  /** Match names based on their professions */
  professionConstraint?: InputMaybe<NameProfessionSearchConstraint>;
  /** Match names based on the words in quotes */
  quoteMatchingConstraint?: InputMaybe<NameQuoteMatchingSearchConstraint>;
  /** Match names based on the words in trivia */
  triviaMatchingConstraint?: InputMaybe<NameTriviaMatchingSearchConstraint>;
  /** Match names based on their available data (has trivia data, has a birth place, etc..) */
  withNameDataConstraint?: InputMaybe<WithNameDataSearchConstraint>;
};

export type AdvancedNameSearchEdge = {
  __typename?: 'AdvancedNameSearchEdge';
  cursor: Scalars['ID']['output'];
  node: AdvancedNameSearchResult;
};

export type AdvancedNameSearchResult = {
  __typename?: 'AdvancedNameSearchResult';
  name: Name;
};

export type AdvancedNameSearchSort = {
  sortBy: AdvancedNameSearchSortBy;
  sortOrder: SortOrder;
};

export enum AdvancedNameSearchSortBy {
  /**
   * Sort names based on their birth date
   * ASC: Earliest dates to Highest dates (Oldest - Youngest)
   */
  BirthDate = 'BIRTH_DATE',
  /**
   * Sort names based on their death date
   * ASC: Earliest dates to last dates (Died First - Died Last)
   */
  DeathDate = 'DEATH_DATE',
  /**
   * Sort names alphabetically
   * ASC: A-Z
   */
  Name = 'NAME',
  /**
   * Sort names based on their starMeterCurrentWeekRank
   * ASC: Lower popularity score means that the name is more popular, so the most popular names will be first
   */
  Popularity = 'POPULARITY'
}

export type AdvancedTitleSearchConnection = {
  __typename?: 'AdvancedTitleSearchConnection';
  edges: Array<Maybe<AdvancedTitleSearchEdge>>;
  facet?: Maybe<Array<Maybe<SearchFacet>>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};


export type AdvancedTitleSearchConnectionFacetArgs = {
  facetField: TitleFacetField;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type AdvancedTitleSearchConstraints = {
  /** Match titles based on the words in alternate versions */
  alternateVersionMatchingConstraint?: InputMaybe<AlternateVersionMatchingSearchConstraint>;
  /**
   * Match titles based on awards they have been nominated for and/or won.
   * Use query `searchMetadata.advancedSearchAwardOptions` to fetch a curated list of options to use for this constraint.
   */
  awardConstraint?: InputMaybe<AwardSearchConstraint>;
  /** Match titles based on the certificate ratings they are assigned */
  certificateConstraint?: InputMaybe<CertificateSearchConstraint>;
  /**
   * This constraint is deprecated in favor of the titleCreditsConstraint.
   *
   * Match titles based on the names of their characters.
   */
  characterConstraint?: InputMaybe<CharacterSearchConstraint>;
  /** Match titles based on the color info */
  colorationConstraint?: InputMaybe<ColorationSearchConstraint>;
  /** Match titles based on the words in crazy credits */
  crazyCreditMatchingConstraint?: InputMaybe<CrazyCreditMatchingSearchConstraint>;
  /** Match titles based on the company */
  creditedCompanyConstraint?: InputMaybe<CreditedCompanySearchConstraint>;
  /**
   * This constraint is deprecated in favor of the titleCreditsConstraint.
   *
   * Match titles based on cast/crew names
   */
  creditedNameConstraint?: InputMaybe<CreditedNameConstraint>;
  /**
   * Match titles based on their current production status stage.
   *
   * Throws UNAUTHENTICATED if not logged in
   * Throws FORBIDDEN if customer w/o any IMDbPro subscription
   */
  currentProductionStatusStageConstraint?: InputMaybe<CurrentProductionStatusStageConstraint>;
  /** Match titles based on episode data */
  episodicConstraint?: InputMaybe<EpisodicSearchConstraint>;
  /** @experimental experimental field, match titles based on title box office earnings */
  experimental_boxOfficeEarningsConstraint?: InputMaybe<Experimental_BoxOfficeEarningsSearchConstraint>;
  /** @experimental experimental field, match titles based on title occupation credits */
  experimental_occupationCreditConstraint?: InputMaybe<Experimental_OccupationCreditSearchConstraint>;
  /** @experimental experimental field, match titles based profession catagories */
  experimental_professionCatagoryConstraint?: InputMaybe<Experimental_ProfessionCatagorySearchConstraint>;
  /** Match titles based on their explicit content classification */
  explicitContentConstraint?: InputMaybe<ExplicitContentSearchConstraint>;
  /** Match titles based on filming location */
  filmingLocationConstraint?: InputMaybe<FilmingLocationSearchConstraint>;
  /** Match titles based on their genre */
  genreConstraint?: InputMaybe<GenreSearchConstraint>;
  /** Match titles based on the words in goofs */
  goofMatchingConstraint?: InputMaybe<GoofMatchingSearchConstraint>;
  /** Match titles based on their availability in theaters */
  inTheatersConstraint?: InputMaybe<InTheatersSearchConstraint>;
  /** Match titles based on their interests */
  interestConstraint?: InputMaybe<InterestSearchConstraint>;
  /** Match titles based on keywords */
  keywordConstraint?: InputMaybe<KeywordSearchConstraint>;
  /** Match titles based on their language */
  languageConstraint?: InputMaybe<LanguageSearchConstraint>;
  /**
   * Match titles based on their presence in lists.
   *
   * If any list specified in this constraint is not a list of Titles then
   * `GRAPHQL_VALIDATION_FAILED` will be thrown.
   *
   * Specifying lists that contain in aggregate a large number of Titles may
   * trigger an error due to query term limits imposed by the implementation. Note
   * that this term count limit is for the overall query, not just this constraint.
   */
  listConstraint?: InputMaybe<ListSearchConstraint>;
  /** Match titles based on rating given by the requesting user */
  myRatingConstraint?: InputMaybe<MyRatingSearchConstraint>;
  /** Match titles based on their country of origin */
  originCountryConstraint?: InputMaybe<OriginCountrySearchConstraint>;
  /** Match titles based on the words in plot summary and outline, or plot author */
  plotMatchingConstraint?: InputMaybe<PlotMatchingSearchConstraint>;
  /** Match titles based on the words in quotes */
  quoteMatchingConstraint?: InputMaybe<TitleQuoteMatchingSearchConstraint>;
  /** Match titles based on ranked list type */
  rankedTitleListConstraint?: InputMaybe<RankedTitleListSearchConstraint>;
  /** Match titles based on when they were released */
  releaseDateConstraint?: InputMaybe<ReleaseDateSearchConstraint>;
  /** Match titles based on their runtime */
  runtimeConstraint?: InputMaybe<RuntimeSearchConstraint>;
  /** Match titles based on ratings given by a single user */
  singleUserRatingConstraint?: InputMaybe<SingleUserRatingSearchConstraint>;
  /** Match titles based on the sound mix */
  soundMixConstraint?: InputMaybe<SoundMixSearchConstraint>;
  /** Match titles based on the words in soundtracks */
  soundtrackMatchingConstraint?: InputMaybe<SoundtrackMatchingSearchConstraint>;
  /** Match titles based on their credits. */
  titleCreditsConstraint?: InputMaybe<TitleCreditsConstraint>;
  /**
   * This constraint is deprecated in favor of the rankedTitleListConstraint.
   *
   * Match titles based on meter ranking
   */
  titleMeterConstraint?: InputMaybe<TitleMeterSearchConstraint>;
  /** Match titles based on their name (title text) */
  titleTextConstraint?: InputMaybe<TitleTextSearchConstraint>;
  /** Match titles based on their type (tv, movie, etc.) */
  titleTypeConstraint?: InputMaybe<TitleTypeSearchConstraint>;
  /** Match titles based on the words in trivia */
  triviaMatchingConstraint?: InputMaybe<TitleTriviaMatchingSearchConstraint>;
  /** Match titles based on their user ratings */
  userRatingsConstraint?: InputMaybe<UserRatingsSearchConstraint>;
  /** Match titles based on their available watch options */
  watchOptionsConstraint?: InputMaybe<WatchOptionsSearchConstraint>;
  /** Match titles based on the data for the title (locations, trivia, crazyCredits, etc. ) */
  withTitleDataConstraint?: InputMaybe<WithTitleDataSearchConstraint>;
};

export type AdvancedTitleSearchEdge = {
  __typename?: 'AdvancedTitleSearchEdge';
  cursor: Scalars['ID']['output'];
  node: AdvancedTitleSearchResult;
};

export type AdvancedTitleSearchResult = {
  __typename?: 'AdvancedTitleSearchResult';
  title: Title;
};

export type AdvancedTitleSearchSort = {
  sortBy: AdvancedTitleSearchSortBy;
  sortOrder: SortOrder;
};

export enum AdvancedTitleSearchSortBy {
  /**
   * Gross revenue pulled in via box-office in Domestic market for entire lifetime of title.
   * Domestic refers to North America (U.S., Canada, and Puerto Rico)
   * ASC: Lower numbers means the title has pulled in less box-office revenue, so poorer performing titles will be first.
   */
  BoxOfficeGrossDomestic = 'BOX_OFFICE_GROSS_DOMESTIC',
  /**
   * Overall Metascore based on critic reviews. Titles without a metascore are
   * placed at the end when using ASC sort order.
   * ASC: Lower Metacritic score means the title is rated more poorly, so titles with worse scores will be first.
   */
  MetacriticScore = 'METACRITIC_SCORE',
  /**
   * Star Rating given by the requesting user.
   * ASC: Lower star rating means the title the user rated the title more poorly, so most disliked titles will be first.
   */
  MyRating = 'MY_RATING',
  /**
   * Date when customer rated a title.
   * ASC: Earlier (older) ratings will be first.
   */
  MyRatingDate = 'MY_RATING_DATE',
  /**
   * TitleMeterType.TITLE_METER (aka Pro MOVIEMeter). Score given to non-episodic title types.
   * ASC: Lower popularity score means that the title is more popular, so the most popular titles will be first.
   */
  Popularity = 'POPULARITY',
  /**
   * Sort results based on specified ranking algorithm.  For the advancedTitleSearch query, exactly one ranked title list
   * constraint must be specified for using this sort option.
   * ASC: Higher ranks will be first.
   */
  Ranking = 'RANKING',
  /**
   * Earliest wide release date of a title. Titles without a release date are
   * placed at the end when using ASC sort order.
   * ASC: Earlier (older) released title will be first.
   */
  ReleaseDate = 'RELEASE_DATE',
  /**
   * The length of the title in terms of runtime.
   * ASC: Lower runtime means the title is shorter, so shortest titles will be first.
   */
  Runtime = 'RUNTIME',
  /**
   * Star Rating given by the specified user in the SpecifiedUserRatingSearchConstraint.
   * Throws BAD_USER_INPUT if the SpecifiedUserRatingSearchConstraint is not specified.
   * ASC: Lower star rating means the title the user rated the title more poorly, so most disliked titles will be first.
   */
  SingleUserRating = 'SINGLE_USER_RATING',
  /**
   * Date when the specified user rated a title.
   * Throws BAD_USER_INPUT if the SpecifiedUserRatingSearchConstraint is not specified.
   * ASC: Earlier (older) ratings will be first.
   */
  SingleUserRatingDate = 'SINGLE_USER_RATING_DATE',
  /**
   * Alphabetical sorting based on regional title text as determined by user language preferences.
   * Language preference is determined by x-imdb-user-country and x-imdb-user-language headers.
   * Only supports the languages/regions we support for localized search. Defaults to original title otherwise.
   * ASC: Lower numbers and letters near the top of the alphabet will be returned first.
   */
  TitleRegional = 'TITLE_REGIONAL',
  /**
   * Weighted IMDb Star Rating as determined by users
   * Note: IMDb maintains a threshold to a minimum number of ratings before it is considered.
   * ASC: Lower star rating means the title is rated more poorly, so titles with worse ratings will be first.
   */
  UserRating = 'USER_RATING',
  /**
   * Count of ratings given by users
   * Note: IMDb maintains a threshold to a minimum number of ratings before it is considered.
   * ASC: Lower count of ratings means the title has been rated a fewer number of
   * times, so titles with least ratings will be first.
   */
  UserRatingCount = 'USER_RATING_COUNT',
  /**
   * The recognized year of the title. Typically, the release year, but guidelines are here:
   * https://help.imdb.com/article/contribution/titles/title-formatting/G56U5ERK7YY47CQB
   * ASC: Earlier (older) titles will be first.
   */
  Year = 'YEAR'
}

export enum Age {
  Age_18_29 = 'AGE_18_29',
  Age_30_44 = 'AGE_30_44',
  Age_45Plus = 'AGE_45_PLUS',
  AgeUnder_18 = 'AGE_UNDER_18'
}

export type AgeDetails = {
  __typename?: 'AgeDetails';
  /** Age displayable property */
  displayableProperty: DisplayableNameAgeDetailsProperty;
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** Age display text */
  text: Scalars['String']['output'];
  /** Number which represents person's age */
  value: Scalars['Int']['output'];
};

export type AgePlayingRange = {
  __typename?: 'AgePlayingRange';
  from: Scalars['Int']['output'];
  to: Scalars['Int']['output'];
};

/** An agency that represents a name */
export type Agency = {
  __typename?: 'Agency';
  /**
   * The employees at this company who specifically represent a person.
   *
   * A name can be represented by 0, 1, or many people at a specific company.
   */
  agents?: Maybe<Array<Maybe<Agent>>>;
  /** The company representing a name */
  company: Company;
};

/** An employee of a company who represents a name in some capacity */
export type Agent = {
  __typename?: 'Agent';
  branch?: Maybe<CompanyBranch>;
  company: Company;
  employeeContact?: Maybe<CompanyContactDetails>;
  id: Scalars['ID']['output'];
  /**
   * Whether or not this person is the primary representative.
   *
   * Each representation type and company combination can have one point of contact
   * but is not guaranteed to have one, even if there is only one associated representative.
   *
   * For example, if a person has multiple Talent Agents at CAA, this being
   * true would indicate the associated name is the person's main Talent Agent
   * at CAA
   */
  isPrimaryAgent: Scalars['Boolean']['output'];
  jobTitle?: Maybe<LocalizedString>;
  name: Name;
  occupation?: Maybe<OccupationValue>;
  /** The type of relationship this representation has with their client */
  relationshipType: RepresentationRelationshipType;
};

export type AggregateRatingsBreakdown = {
  __typename?: 'AggregateRatingsBreakdown';
  /** Default value for demographicFilter */
  histogram?: Maybe<Histogram>;
  /** Whether the aggregate rating breakdown info display should be hidden by default */
  isCollapsed: Scalars['Boolean']['output'];
  /**
   * Country is set by detection during registration or the user, the latter taking precedence.
   * RatingsSummaryByCountry will vend only the top N country summary ordered specifically by number of ratings.
   * We will only return countries with a voting count and rating data, countries with no votes will be filtered
   * out. If there is no limit we will return all country rating data available for a title.
   */
  ratingsSummaryByCountry?: Maybe<Array<Maybe<RatingsSummaryByCountry>>>;
  ratingsSummaryByDemographics?: Maybe<Array<Maybe<DemographicRatings>>>;
};


export type AggregateRatingsBreakdownHistogramArgs = {
  demographicFilter?: InputMaybe<DemographicFilter>;
};


export type AggregateRatingsBreakdownRatingsSummaryByCountryArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Aka details */
export type Aka = {
  __typename?: 'Aka';
  /** Other attributes about this aka */
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** If applicable, the country where this was the title text */
  country?: Maybe<DisplayableCountry>;
  /** Aka as displayable property */
  displayableProperty: DisplayableTitleAkaProperty;
  /** The language of this title text */
  language?: Maybe<DisplayableLanguage>;
  /** The alternative title text */
  text: Scalars['String']['output'];
};

/** Pagination for AKA types which always has a known total number of edges. */
export type AkaConnection = {
  __typename?: 'AkaConnection';
  /** Pages of AKAs */
  edges: Array<Maybe<AkaEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Akas */
export type AkaEdge = {
  __typename?: 'AkaEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A AKA node */
  node: Aka;
  /** Position of the node in this context, eg: AKA 4 out of 31 */
  position: Scalars['Int']['output'];
};

export enum AkaFilter {
  /** Filter the AKAs to a list of 1 AKA per region and language */
  DisplayTitlesOnly = 'DISPLAY_TITLES_ONLY',
  /** Exclude the aka if it's the same as the primary title text */
  ExcludeIfSameAsPrimary = 'EXCLUDE_IF_SAME_AS_PRIMARY'
}

export type AkaSort = {
  by: AkaSortBy;
  order: SortOrder;
};

export enum AkaSortBy {
  Country = 'COUNTRY',
  Relevance = 'RELEVANCE'
}

/** An Alexa question. */
export type AlexaQuestion = {
  __typename?: 'AlexaQuestion';
  /** The answer */
  answer: Markdown;
  /**
   * An id representing the attribute that the question/answer concerns (e.g.
   * 'height'). Unique within a group of questions for an entity
   */
  attributeId: Scalars['ID']['output'];
  /** The question */
  question: Markdown;
};

/** Pagination for Alexa questions which always has a known total number of edges. */
export type AlexaQuestionConnection = {
  __typename?: 'AlexaQuestionConnection';
  /** Pages of Alexa questions. */
  edges: Array<Maybe<AlexaQuestionEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Alexa questions. */
export type AlexaQuestionEdge = {
  __typename?: 'AlexaQuestionEdge';
  /** A Alexa question node */
  node: AlexaQuestion;
};

/** Alternate version details */
export type AlternateVersion = {
  __typename?: 'AlternateVersion';
  /** Alternate version as displayable article */
  displayableArticle: DisplayableArticle;
  /** The alternate version text */
  text: Markdown;
};

/** Pagination for alternate version types which always has a known total number of edges. */
export type AlternateVersionConnection = {
  __typename?: 'AlternateVersionConnection';
  /** Pages of alternate versions */
  edges: Array<Maybe<AlternateVersionEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of alternate versions */
export type AlternateVersionEdge = {
  __typename?: 'AlternateVersionEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An alternate version node */
  node: AlternateVersion;
  /** Position of the node in this context, eg: AlternateVersion 4 out of 46 */
  position: Scalars['Int']['output'];
};

/**
 * Example: if you want to match titles of alternate version 'car chase' OR 'excessive', PLUS
 * the title must contain 'omits nudity', specify anyAlternateTextTerms: ['car chase', 'excessive'] plus
 * allAlternateTextTerms: ['omits nudity']. Note that this is term match rather than
 * phrase match. 'omits nudity' would match titles that contain 'omits the nudity'; 'chase car' would
 * match titles that contain 'car chase'.
 */
export type AlternateVersionMatchingSearchConstraint = {
  /** A title match must contain ALL of these search terms in at least one of its alternate versions. */
  allAlternateVersionTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these search terms in at least one of its alternate versions. */
  anyAlternateVersionTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type AmazonMusicProduct = {
  __typename?: 'AmazonMusicProduct';
  /** The Amazon Standard Identification Number for the product */
  amazonId: AmazonStandardId;
  /** Artist data for the product */
  artists?: Maybe<Array<Maybe<AmazonMusicProductArtist>>>;
  /** The format of the product being offered, e.g. CD */
  format: AmazonMusicProductFormat;
  /** Image for the product */
  image?: Maybe<Image>;
  /** The product title */
  productTitle: AmazonMusicProductTitle;
};

export type AmazonMusicProductArtist = {
  __typename?: 'AmazonMusicProductArtist';
  /** The name of the artist */
  artistName: AmazonMusicProductArtistName;
};

export type AmazonMusicProductArtistName = {
  __typename?: 'AmazonMusicProductArtistName';
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** The language the text is in */
  language: DisplayableLanguage;
  /** The text for format */
  text: Scalars['String']['output'];
};

export type AmazonMusicProductFormat = {
  __typename?: 'AmazonMusicProductFormat';
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** The language the text is in */
  language: DisplayableLanguage;
  /** The text for format */
  text: Scalars['String']['output'];
};

export type AmazonMusicProductTitle = {
  __typename?: 'AmazonMusicProductTitle';
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** The language the text is in */
  language: DisplayableLanguage;
  /** The product title */
  text: Scalars['String']['output'];
};

export type AmazonStandardId = {
  __typename?: 'AmazonStandardId';
  /** Amazon Standard Identification Number */
  asin: Scalars['ID']['output'];
  /** Amazon marketplace identifier */
  obfuscatedMarketplaceId: Scalars['ID']['output'];
  /** Region of the external identifier e.g. US */
  region: Scalars['String']['output'];
};

export type AnswerItem = Image | Name | Title;

/** Contains the eligibility status for apps to serve 3p ads and configuration map for slots on each mobile app page. */
export type AppAdsInfoOutput = {
  __typename?: 'AppAdsInfoOutput';
  /** A map using ad layout types as keys containing a list of slots and their information as values. */
  adLayoutSlotConfig: Array<Maybe<AdLayoutConfiguration>>;
  /**
   * Represents whether the app is currently eligible to request and serve 3p ads
   * based on user's geo and the enablement status of the feature.
   * A value of true indicates the apps can request 3p ads and a value of false indicates they should not.
   */
  thirdPartyAdsEligibility: Scalars['Boolean']['output'];
};

/** The configuration of APS placements for an individual IMDb ad slot. */
export type ApsConfiguration = {
  __typename?: 'ApsConfiguration';
  /** The APS slot object for the given IMDb ad slot. */
  apsSlot: ApsSlot;
  /**
   * The APS slot object for the given IMDb ad slot on ad refresh requests.
   * A missing value indicates the client cannot make a 3p ad request for this slot on ad refresh.
   */
  apsSlotAdRefresh?: Maybe<ApsSlot>;
};

/** The APS slot level information needed for 3p ad requests. */
export type ApsSlot = {
  __typename?: 'ApsSlot';
  /** The slot id generated by APS for the given ad slot. */
  apsSlotId: Scalars['ID']['output'];
  /** The slot name associated with the slot id in APS for the given ad slot (e.g. app-title-inline20). */
  apsSlotName: Scalars['String']['output'];
};

/**
 * Key-value pair for APS slot parameters.
 * (e.g. { key: "ggProduct", value: "inScreen" }
 *  used for APS adhesion ads)
 */
export type ApsSlotParam = {
  __typename?: 'ApsSlotParam';
  /** The key of the parameter */
  key: Scalars['String']['output'];
  /** The value of the parameter */
  value: Scalars['String']['output'];
};

/** Filter of Archived  or Unarchived credits */
export enum ArchivedOrUnarchivedFilter {
  AllCredits = 'ALL_CREDITS',
  ArchivedOnly = 'ARCHIVED_ONLY',
  UnarchivedOnly = 'UNARCHIVED_ONLY'
}

/**
 * An aspect ratio, along with any attributes. For example, the aspect ratio for the IMAX and IMAX3D versions might be
 * 2.35:1.
 */
export type AspectRatio = {
  __typename?: 'AspectRatio';
  /** Aspect ratio */
  aspectRatio: Scalars['String']['output'];
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** Aspect ratio as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationProperty;
};

/** Aspect ratios for this title. */
export type AspectRatios = {
  __typename?: 'AspectRatios';
  /** The list of aspect ratio items */
  items: Array<Maybe<AspectRatio>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of aspect ratio items */
  total: Scalars['Int']['output'];
};

/** The broad groups of professions that attachments can be filtered on */
export enum AttachmentGroup {
  Cast = 'CAST',
  CastingDirectors = 'CASTING_DIRECTORS',
  Filmmakers = 'FILMMAKERS',
  Writers = 'WRITERS'
}

/**
 * Filter search by broad groups of professions
 *
 * Example:
 * AttachmentSearchConstraint: {
 *     attachmentGroup: 'CASTING_DIRECTORS'
 * }
 */
export type AttachmentSearchConstraint = {
  attachmentGroup: AttachmentGroup;
};

export type AuthProviderDeprecationMessage = {
  __typename?: 'AuthProviderDeprecationMessage';
  /** Deprecation reason message with a user's obfuscated email address. */
  message: LocalizedMarkdown;
  /** URLs for actions to take based on this deprecated provider (i.e. resetting password, learn more, etc.) */
  urls: Array<Maybe<AuthProviderDeprecationUrl>>;
};

export type AuthProviderDeprecationUrl = {
  __typename?: 'AuthProviderDeprecationUrl';
  /** The url label to create a hyperlink. */
  label: AuthProviderDeprecationUrlLabel;
  /** The url value. */
  value: Scalars['URL']['output'];
};

export type AuthProviderDeprecationUrlLabel = {
  __typename?: 'AuthProviderDeprecationUrlLabel';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type AuthProviderStatus = {
  __typename?: 'AuthProviderStatus';
  /** The auth provider type */
  provider: AuthProviderType;
  /**
   * Link if the provider is not linked.
   * Not provided if provider is already linked.
   */
  providerLinkingURL?: Maybe<Scalars['URL']['output']>;
};

export enum AuthProviderType {
  /** For LWA login */
  Amazon = 'AMAZON',
  /** For AAP Login */
  AmazonAap = 'AMAZON_AAP',
  /** For Amazon login with email gating association handle */
  AmazonEmailGating = 'AMAZON_EMAIL_GATING',
  Apple = 'APPLE',
  Google = 'GOOGLE',
  Imdb = 'IMDB'
}

export type AwardCategory = {
  __typename?: 'AwardCategory';
  text?: Maybe<Scalars['String']['output']>;
};

export type AwardCompany = {
  __typename?: 'AwardCompany';
  /** The associated company */
  company: Company;
  /** The award company displayable property, e.g. '[link=co0274041] (production company/broadcaster)' */
  displayableProperty: DisplayableAwardedEntity;
  /** Note associated with the company */
  note?: Maybe<Markdown>;
};

export type AwardDetails = {
  __typename?: 'AwardDetails';
  /** Nominations for an award grouped by its category */
  awardNominationCategories?: Maybe<AwardNominationsWithCategoryConnection>;
  /** Edition of this event (e.g. The Golden Globes 2013) for which this award nomination occurred. */
  eventEdition: EventEdition;
  /** Award Id */
  id: Scalars['ID']['output'];
  /** Award name */
  text: Scalars['String']['output'];
};


export type AwardDetailsAwardNominationCategoriesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for AwardDetails types which always has a known total number of edges. */
export type AwardDetailsConnection = {
  __typename?: 'AwardDetailsConnection';
  /** Pages of award details */
  edges: Array<Maybe<AwardDetailsEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of award details */
export type AwardDetailsEdge = {
  __typename?: 'AwardDetailsEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An AwardDetails node */
  node: AwardDetails;
  /** Position of the node in this context, eg: AwardDetails 4 out of 312 */
  position: Scalars['Int']['output'];
};

export type AwardEventNominationSearchInput = {
  /**
   * Event Id associated with an award.
   * For example, specify `ev0000003` to match titles that have been nominated for an Oscar
   */
  eventId: Scalars['ID']['input'];
  /**
   * Search-specific identifier for an award category associated with the event, limited options available.
   * If not specified, titles that have been nominated for any award from the specified event will be matched.
   * Fetch a curated list of award events with category ids via query `searchMetadata.advancedSearchAwardOptions`
   * An invalid award category id will cause an error. For more information about what options are available,
   * see https://w.amazon.com/bin/view/IMDb/GraphQL/Search/ClientUsage/#HAwardConstraintCategories
   */
  searchAwardCategoryId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Optionally specify whether a title can only be matched if it was, or was not, selected as a winner of an award.
   * If omitted, a title will be matched if it was nominated for the award, regardless of whether it won or not.
   */
  winnerFilter?: InputMaybe<AwardWinnerSearchFilter>;
};

export type AwardName = {
  __typename?: 'AwardName';
  /** The award name displayable property, e.g. '[link=nm0745074] (unit production manager) (plaque)' */
  displayableProperty: DisplayableAwardedEntity;
  /** The associated name */
  name: Name;
  /** Note associated with the name */
  note?: Maybe<Markdown>;
};

export type AwardNomination = {
  __typename?: 'AwardNomination';
  /** Details about the award, such as the name and year */
  award: AwardDetails;
  /** Title(s) and/or name(s) the award is for */
  awardedEntities: AwardedEntities;
  /** The category in which the award was given. Example: Best Motion Picture of the Year. */
  category?: Maybe<AwardCategory>;
  /** Optional specific episode(s) for which the nomination is associated with */
  forEpisodes?: Maybe<Array<Maybe<Title>>>;
  /** Optional song title(s) for which the nomination is associated with */
  forSongTitles?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Award Nomination ID */
  id: Scalars['ID']['output'];
  /** Did the title/name win this award */
  isWinner: Scalars['Boolean']['output'];
  /** Additional notes associated with the award. */
  notes?: Maybe<Markdown>;
  /** Optional date and time when the award win was officially announced. */
  winAnnouncementDate?: Maybe<DisplayableDate>;
  /** The ranking of this nomination, when applicable. */
  winningRank?: Maybe<Scalars['Int']['output']>;
};

export type AwardNominationCategoriesFilter = {
  /** Filter for/out given nomination award categories */
  categories?: InputMaybe<NominationCategoriesFilter>;
};

/** Pagination for award types which always has a known total number of edges. */
export type AwardNominationConnection = {
  __typename?: 'AwardNominationConnection';
  /** Pages of award nominations */
  edges: Array<Maybe<AwardNominationEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of awards */
export type AwardNominationEdge = {
  __typename?: 'AwardNominationEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An award nomination node */
  node: AwardNomination;
  /** Position of the node in this context, eg: Award 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type AwardNominationsFilter = {
  /** Filter awards by award id */
  awards?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter awards by event id */
  events?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter nominations on win status */
  wins?: InputMaybe<WinsFilter>;
};

export type AwardNominationsSort = {
  by: AwardNominationsSortBy;
  order: SortOrder;
};

/** Default sort is done by sorting nomination id */
export enum AwardNominationsSortBy {
  /** Sorts by prestigious awards first, then reverse chronological by year */
  Prestigious = 'PRESTIGIOUS'
}

export type AwardNominationsWithCategory = {
  __typename?: 'AwardNominationsWithCategory';
  /** Nominations belong to the category */
  awardNominations?: Maybe<AwardNominationConnection>;
  /**
   * The category of the nomination e.g. 'Best Picture'
   * Category can be null because we have nominations without category, those
   * nominations will be listed under the category 'null'
   */
  category?: Maybe<AwardCategory>;
};


export type AwardNominationsWithCategoryAwardNominationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<AwardNominationsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<AwardNominationsSort>;
};

/** Pagination for AwardNominationsWithCategory types which always has a known total number of edges. */
export type AwardNominationsWithCategoryConnection = {
  __typename?: 'AwardNominationsWithCategoryConnection';
  /** Pages of awardNominations with category */
  edges: Array<Maybe<AwardNominationsWithCategoryEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of awardNominations with category */
export type AwardNominationsWithCategoryEdge = {
  __typename?: 'AwardNominationsWithCategoryEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An AwardNominationsWithCategory node */
  node: AwardNominationsWithCategory;
  /** Position of the node in this context, eg: AwardNominationsWithCategory 4 out of 312 */
  position: Scalars['Int']['output'];
};

/**
 * Constrain title search results based on the awards they have been nominated for and/or won.
 * Any combination of `any`, `all`, and `exclude` inputs can be specified.
 */
export type AwardSearchConstraint = {
  /** A title must match ALL of the specified award event nominations. */
  allEventNominations?: InputMaybe<Array<InputMaybe<AwardEventNominationSearchInput>>>;
  /** A title must match AT LEAST ONE of the specified award event nominations. */
  anyEventNominations?: InputMaybe<Array<InputMaybe<AwardEventNominationSearchInput>>>;
  /**
   * A title must match NONE of the specified award event nominations.
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeEventNominations?: InputMaybe<Array<InputMaybe<AwardEventNominationSearchInput>>>;
  /** @experimental experimental field, constrain to awards in this date range */
  experimental_awardDateRange?: InputMaybe<DateRange>;
  /** @experimental experimental field, constrain to any titles that have a number of award wins in this range */
  experimental_numAwardsRange?: InputMaybe<IntRangeInput>;
  /** @experimental experimental field, constrain to any titles that have a number of award nominations in this range */
  experimental_numNominationsRange?: InputMaybe<IntRangeInput>;
};

export type AwardTitle = {
  __typename?: 'AwardTitle';
  /** The award title displayable property, e.g. '[link=tt3513498] (as Queen Watevra Wa'Nabi)' */
  displayableProperty: DisplayableAwardedEntity;
  /** Note associated with the title */
  note?: Maybe<Markdown>;
  /** The associated title */
  title: Title;
};

export enum AwardWinnerSearchFilter {
  NonWinnerOnly = 'NON_WINNER_ONLY',
  WinnerOnly = 'WINNER_ONLY'
}

export type AwardedCompanies = {
  __typename?: 'AwardedCompanies';
  /**
   * The company/companies that this nomination is primarily form, multiple companies may share
   * an award. Ordered by display preference
   */
  awardCompanies?: Maybe<Array<Maybe<AwardCompany>>>;
};

export type AwardedEntities = AwardedNames | AwardedTitles;

export type AwardedNames = {
  __typename?: 'AwardedNames';
  /**
   * The name(s) that this nomination is primarily for. There is typically one name, but multiple names may share
   * an award. Ordered by display preference.
   */
  awardNames: Array<Maybe<AwardName>>;
  /** Optional companies associated with the primary name(s) for this award nomination */
  secondaryAwardCompanies?: Maybe<Array<Maybe<AwardCompany>>>;
  /** Optional titles associated with the primary name(s) for this award nomination */
  secondaryAwardTitles?: Maybe<Array<Maybe<AwardTitle>>>;
};

export type AwardedTitles = {
  __typename?: 'AwardedTitles';
  /**
   * The title(s) that this nomination is primarily for. There is typically one title, but multiple titles may share
   * an award. Ordered by display preference.
   */
  awardTitles: Array<Maybe<AwardTitle>>;
  /** Optional companies associated with the primary name(s) for this award nomination */
  secondaryAwardCompanies?: Maybe<Array<Maybe<AwardCompany>>>;
  /** Optional names associated with the primary title(s) for this award nomination */
  secondaryAwardNames?: Maybe<Array<Maybe<AwardName>>>;
};

export type AwardsEvent = {
  __typename?: 'AwardsEvent';
  /**
   * A list of all the event's editions sorted by year, followed by
   * instanceWithinYear, with the most recent first (e.g. 2023, 2022 edition 2,
   * 2022 edition 1, ...)
   */
  editions?: Maybe<EventEditionConnection>;
  /** Event ID */
  id: Scalars['ID']['output'];
  /** The location of the event */
  location?: Maybe<DisplayableLocation>;
  /** Event name */
  text: Scalars['String']['output'];
  /** List of trivia items related to the event with potential markdown links for movies/people */
  trivia?: Maybe<Array<Maybe<Markdown>>>;
  /** The urls for the event */
  urls?: Maybe<Array<Maybe<EventUrl>>>;
};


export type AwardsEventEditionsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type AwardsFilter = {
  /** Filter out given Awards IDs */
  excludeAwards?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter for given Awards IDs */
  includeAwards?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Badge represents an achievement that can be earned by customers */
export type Badge = {
  __typename?: 'Badge';
  /** Localized description of the badge and awarding criteria */
  description: LocalizedMarkdown;
  /** Unique identifier for the badge */
  id: Scalars['ID']['output'];
  /**
   * Image data associated with the badge.
   * Includes `url` field for fetching the image asset from media storage.
   * Includes `fileType` field indicating the delivered image type.
   * Includes `accessibilityText` field which is intended to be used for screen reader accessibility.
   * Includes `height` and `width` fields for determining image size ratio.
   * Throws UNSUPPORTED_IMAGE_TYPE if the service cannot provide the requested image type. Supports SVG initially.
   */
  image: MediaServiceImage;
  /** Additional title information e.g. 2025 for an Oscars titled badge */
  subtitle?: Maybe<CommonLocalizedDisplayableConcept>;
  /** The localized display title of the badge */
  title: CommonLocalizedDisplayableConcept;
};


/** Badge represents an achievement that can be earned by customers */
export type BadgeImageArgs = {
  fileType: ImageFileType;
};

/** Connection type for paginated badge results */
export type BadgeConnection = {
  __typename?: 'BadgeConnection';
  /** A list of edges containing badge nodes */
  edges: Array<Maybe<BadgeEdge>>;
  /** Information about pagination in a connection */
  pageInfo: PageInfo;
  /** Total number of badges for the user */
  total: Scalars['Int']['output'];
};

/** An edge in a connection */
export type BadgeEdge = {
  __typename?: 'BadgeEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['ID']['output'];
  /** The earned badge node at the end of the edge */
  node: Badge;
};

/**
 * BadgeGuideEntry is a help page description for directions on how to achieve one or many badges.
 * e.g. All Oscars badge awarding criteria is represented as the Oscars BadgeGuideEntry
 */
export type BadgeGuideEntry = {
  __typename?: 'BadgeGuideEntry';
  /** Localized description of the entry and awarding criteria */
  description: LocalizedMarkdown;
  /**
   * Image data associated with the entry.
   * Includes `url` field for fetching the image asset from media storage.
   * Includes `fileType` field indicating the delivered image type.
   * Includes `accessibilityText` field which is intended to be used for screen reader accessibility.
   * Includes `height` and `width` fields for determining image size ratio.
   * Throws UNSUPPORTED_IMAGE_TYPE if the service cannot provide the requested image type. Supports SVG initially.
   */
  image: MediaServiceImage;
  /** Additional title information e.g. 20XX for the Oscars entry */
  subtitle?: Maybe<CommonLocalizedDisplayableConcept>;
  /** Localized display title of the entry. e.g. Oscars */
  title: CommonLocalizedDisplayableConcept;
};


/**
 * BadgeGuideEntry is a help page description for directions on how to achieve one or many badges.
 * e.g. All Oscars badge awarding criteria is represented as the Oscars BadgeGuideEntry
 */
export type BadgeGuideEntryImageArgs = {
  fileType: ImageFileType;
};

/** Connection type for paginated badge guide entry results */
export type BadgeGuideEntryConnection = {
  __typename?: 'BadgeGuideEntryConnection';
  /** A list of edges containing badge guide entry nodes */
  edges: Array<Maybe<BadgeGuideEntryEdge>>;
  /** Information about pagination in a connection */
  pageInfo: PageInfo;
  /** Total number of badges for the user */
  total: Scalars['Int']['output'];
};

/** An edge in a connection */
export type BadgeGuideEntryEdge = {
  __typename?: 'BadgeGuideEntryEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['ID']['output'];
  /** The badge guide entry node at the end of the edge */
  node: BadgeGuideEntry;
};

export type Banner = {
  __typename?: 'Banner';
  /** Link provided by the image source, if required by the license */
  attributionUrl: Scalars['String']['output'];
  /** Original height of the banner image resource, in pixels */
  height: Scalars['Int']['output'];
  /** DEPRECATED: recommend using `url` instead - URL for the image resource */
  imageUrl: Scalars['String']['output'];
  /** URL for the image resource */
  url: Scalars['String']['output'];
  /** Original width of the banner image resource, in pixels */
  width: Scalars['Int']['output'];
};

export type BiographySearchConstraint = {
  /** Match names whose biography was written by AT LEAST ONE of these authors */
  anyBiographyAuthors?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Match names containing searchText in their biography */
  searchText?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The constraints here are combined (AND), using both allows matching names born on a certain date in a certain range.
 * example:
 * birthDateConstraint: {
 *     birthday: "--09-02",
 *     birthDateRange: {
 *         start:"1996-01-01",
 *         end: "2022-12-31"
 *     }
 *
 * }
 *
 * the above constraint will match names born on September 2nd, between 1996 and 2022.
 */
export type BirthDateSearchConstraint = {
  birthDateRange?: InputMaybe<DateRange>;
  birthday?: InputMaybe<Scalars['MonthDay']['input']>;
};

export type BirthName = {
  __typename?: 'BirthName';
  /** The birthName as a displayable property */
  displayableProperty: DisplayableBirthNameProperty;
  /** The birthName as raw data */
  text: Scalars['String']['output'];
};

/**
 * Matches names based on where they were born.
 * There is no fuzzy matching.
 * For example: 'Venice Italy' will be matched by 'Venice' and 'Italy' but not 'Venice Ita'
 */
export type BirthPlaceSearchConstraint = {
  birthPlace: Scalars['String']['input'];
};

export type BlogLink = {
  __typename?: 'BlogLink';
  label?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

/**
 * Represents a boolean validation constraint with associated error feedback that can be evaluated client-side.
 * Used to enforce true/false conditions in form elements such as whether input is required or optional.
 */
export type BooleanValidationConstraint = {
  __typename?: 'BooleanValidationConstraint';
  /** The feedback to display to the customer related to the constraint. */
  feedback: ValidationFeedbackContent;
  /** The required boolean value for validation */
  value: Scalars['Boolean']['output'];
};

export enum BoxOfficeArea {
  /** Domestic refers to gross box-office revenue from North America (U.S., Canada, and Puerto Rico) */
  Domestic = 'DOMESTIC',
  /** International covers the entire world excluding Domestic */
  International = 'INTERNATIONAL',
  /** Worldwide covers the entire world */
  Worldwide = 'WORLDWIDE'
}

/**
 * Displayable BoxOfficeArea type.
 * See sections 'Area Rollups and Special Areas' and 'Individual Areas' at
 * https://developer.imdb.com/documentation/bulk-data-documentation/data-dictionary/box-office.
 */
export type BoxOfficeAreaType = {
  __typename?: 'BoxOfficeAreaType';
  /** A non-localized field representing the BoxOfficeAreaType code, e.g. 'XDOM'. */
  code: Scalars['String']['output'];
  /** An Opaque unique Identifier for the BoxOfficeAreaType. */
  id: Scalars['ID']['output'];
  /** The language the text is written in. */
  language: DisplayableLanguage;
  /** The displayable BoxOfficeAreaType, e.g. 'Domestic'. */
  text: Scalars['String']['output'];
};

export type BoxOfficeGross = {
  __typename?: 'BoxOfficeGross';
  total: Money;
};

/**
 * BoxOfficeRelease: a program of content designed to be consumed in a single
 * session that is exhibited in a specific Box Office Area in a continuous period of time.
 * Most releases consist of a single film shown during a limited run in a cinema, but other cases refer to more than one title.
 * For example a double-bill (two full-length movies shown back-to-back with a single ticket)
 * or the "Oscar Shorts" program (theatrically exhibited collection of multiple films back to back with a single ticket).
 */
export type BoxOfficeRelease = {
  __typename?: 'BoxOfficeRelease';
  /** Titles in the release */
  titles: Array<Maybe<Title>>;
  /** Number of weeks this release has been running */
  weeksRunning?: Maybe<Scalars['Int']['output']>;
};

/**
 * Box Office Area Filter for box office results. Please provide either the Box Office Area or the Country, not both.
 * Throws GRAPHQL_VALIDATION_FAILED if both boxOfficeArea and country code fields are not empty.
 */
export type BoxOfficeReleasesAreaFilter = {
  /**
   * Box Office Area code: Box Office area codes for which the grosses are calculated.
   * See sections 'Area Rollups and Special Areas' and 'Individual Areas' at
   * https://developer.imdb.com/documentation/bulk-data-documentation/data-dictionary/box-office.
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid box office area code is provided.
   */
  boxOfficeArea?: InputMaybe<Scalars['String']['input']>;
  /**
   * Country code in ISO 3166 (IMDbLocaleConfig:region_codes.json)
   * This is a convenience option: will be mapped internally to the Box Office Area code of interest to users of this country.
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid country code is provided.
   */
  country?: InputMaybe<Scalars['String']['input']>;
};

export type BoxOfficeWeekendChart = {
  __typename?: 'BoxOfficeWeekendChart';
  entries: Array<Maybe<ChartEntry>>;
  weekendEndDate: Scalars['Date']['output'];
  weekendStartDate: Scalars['Date']['output'];
};

/** Domain type based on business */
export enum BusinessDomain {
  Consumer = 'CONSUMER',
  Pro = 'PRO'
}

export type CallToAction = {
  __typename?: 'CallToAction';
  landingPagePro?: Maybe<LinkCallToAction>;
  nameBanner?: Maybe<MarkdownSlotCallToAction>;
  nameClaimPageForFree?: Maybe<SectionCallToAction>;
  nameDiscoverMoreInsights?: Maybe<LinkCallToAction>;
  nameImagesReels?: Maybe<LinkCallToAction>;
  nameProUpsell?: Maybe<MultiLinkCallToAction>;
  nameViewStarMeter?: Maybe<LinkCallToAction>;
  navbarProFlyout?: Maybe<ImageAndLinkCallToAction>;
  titleProUpsell?: Maybe<LinkCallToAction>;
};


export type CallToActionLandingPageProArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};


export type CallToActionNameBannerArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};


export type CallToActionNameClaimPageForFreeArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};


export type CallToActionNameDiscoverMoreInsightsArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};


export type CallToActionNameImagesReelsArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};


export type CallToActionNameProUpsellArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};


export type CallToActionNameViewStarMeterArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};


export type CallToActionNavbarProFlyoutArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};


export type CallToActionTitleProUpsellArgs = {
  resultOverride?: InputMaybe<Scalars['ResultID']['input']>;
};

export type CallToActionContextInput = {
  /**
   * Optional parameter specifying the const ID for the context.
   * For example, CTAs on name pages would provide the nconst, while CTAs on title pages would provide
   * the tconst. If all requested CTAs do not need a constId, then it could be omitted.
   */
  constId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Optional parameter to specify if the user is logged in.
   * This parameter is provided for browser cache to allow query to differ for logged in/logged out user.
   * Responses for logged out user can be cached, while responses for logged in user can not.
   * The back-end graphlet ignores this input argument.
   */
  isLoggedIn?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Generic type for an image resource which has height, url, width, and optional caption for accessibility */
export type CallToActionImage = {
  __typename?: 'CallToActionImage';
  /** Image caption text */
  caption?: Maybe<LocalizedMarkdown>;
  /** Original height of the image resource, in pixels */
  height: Scalars['Int']['output'];
  /** URL for the image resource */
  url: Scalars['String']['output'];
  /** Original width of the image resource, in pixels */
  width: Scalars['Int']['output'];
};

/** Generic type for a localized text which has an ID or token, associated display text, and the language of the display text */
export type CallToActionText = {
  __typename?: 'CallToActionText';
  /** The text ID or token */
  id: Scalars['ID']['output'];
  /** The language for the display text */
  language: DisplayableLanguage;
  /** The localized display text */
  text: Scalars['String']['output'];
};

/** A camera (or lens), along with any attributes. For example, a wide angle lens used for outdoor shots. */
export type Camera = {
  __typename?: 'Camera';
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** Camera */
  camera: Scalars['String']['output'];
  /** Camera as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationProperty;
};

/** Cameras for this title. */
export type Cameras = {
  __typename?: 'Cameras';
  /** The list of camera items */
  items: Array<Maybe<Camera>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of camera items */
  total: Scalars['Int']['output'];
};

export type CanRate = {
  __typename?: 'CanRate';
  isRatable: Scalars['Boolean']['output'];
};

/** Cast details */
export type Cast = Credit & {
  __typename?: 'Cast';
  attributes?: Maybe<Array<Maybe<CreditAttribute>>>;
  category: CreditCategory;
  /** Characters (e.g. 'Neo') */
  characters?: Maybe<Array<Maybe<Character>>>;
  episodeCredits?: Maybe<EpisodeCastConnection>;
  name: Name;
  /**
   * A cast credit may have an optional position attribute indicating the order of
   * appearance within the titles ending credits. This position can be null for
   * some or all of the titles credits. By default (see CreditConnection.orderBy),
   * the cast credit that has a value in their position field will be ordered first
   * (by that number), then all other cast credits that have a null in their
   * position field will be ordered alphabetically.
   */
  position?: Maybe<Scalars['Int']['output']>;
  title: Title;
};


/** Cast details */
export type CastAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Cast details */
export type CastCharactersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Cast details */
export type CastEpisodeCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<EpisodeCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<EpisodeCreditsSort>;
};

export type CategorizedWatchOptions = {
  __typename?: 'CategorizedWatchOptions';
  /** Localized categoryName of the watch option category. */
  categoryName: LocalizedString;
  /**
   * Returns a list with the maximum number of watch options in this category.
   * NO FILTERS, NO PAGINATION
   */
  watchOptions: Array<Maybe<WatchOption>>;
};


export type CategorizedWatchOptionsWatchOptionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type CategorizedWatchOptionsList = {
  __typename?: 'CategorizedWatchOptionsList';
  categorizedWatchOptionsList: Array<Maybe<CategorizedWatchOptions>>;
};

export type Certificate = {
  __typename?: 'Certificate';
  /** Additional descriptive attributes about the rating */
  attributes: Array<Maybe<DisplayableAttribute>>;
  country: DisplayableCountry;
  id: Scalars['String']['output'];
  rating: Scalars['String']['output'];
  ratingReason?: Maybe<Scalars['String']['output']>;
  ratingsBody?: Maybe<RatingsBody>;
  /** The certificate id assigned by the ratings body */
  ratingsBodyCertificateId?: Maybe<Scalars['String']['output']>;
};


export type CertificateAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Match titles that are assigned the specified certificates */
export type CertificateSearchConstraint = {
  /**
   * Specify certificates by their region and rating name.
   * For example: region 'US' and rating name 'R'.
   */
  anyRegionCertificateRatings?: InputMaybe<Array<InputMaybe<RegionCertificateRatingInput>>>;
  /**
   * Titles with any of the specified certificates will not be matched.
   *
   * If the same input is specified in the any and exclude constraints,
   * then the results should be empty.
   */
  excludeRegionCertificateRatings?: InputMaybe<Array<InputMaybe<RegionCertificateRatingInput>>>;
};

export type CertificatesConnection = {
  __typename?: 'CertificatesConnection';
  /** Pages of certificates */
  edges: Array<Maybe<CertificatesEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type CertificatesEdge = {
  __typename?: 'CertificatesEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Certificate node */
  node: Certificate;
  /** Position of the node in this context */
  position: Scalars['Int']['output'];
};

export type CertificatesFilter = {
  /** Filter out for specific country code e.g FR, CA */
  excludeCountries?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter for specific country code e.g FR, CA */
  includeCountries?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  ratingsBody?: InputMaybe<Scalars['ID']['input']>;
};

export type ChangeLoginSecurityRedirectUrlInput = {
  /** Association handle of the login context i.e. imdb_us */
  associationHandle: Scalars['String']['input'];
  /**
   * Unique identifier for client request.
   * For web, 'Unique browser ID' i.e ubid context identifier, which in practice means an identifier for the domain+browser combination.
   */
  clientContext: Scalars['String']['input'];
  /** Optional URL to return to post login & security change, otherwise defaults to main IMDb account settings page (/registration/accountsettings/) */
  returnURL?: InputMaybe<Scalars['URL']['input']>;
  /** 'Login & Security' sub page to redirect to, if omitted redirects to the root 'Login & Security' page */
  subPageType?: InputMaybe<ChangeLoginSecuritySubPageType>;
};

export type ChangeLoginSecurityRedirectUrlOutput = {
  __typename?: 'ChangeLoginSecurityRedirectURLOutput';
  /** Redirect URL for user login & security page or user instructions to access their login & security settings */
  redirectURL: Scalars['URL']['output'];
};

export enum ChangeLoginSecuritySubPageType {
  /** Change Email page */
  ChangeEmail = 'CHANGE_EMAIL',
  /** Change Password page */
  ChangePassword = 'CHANGE_PASSWORD'
}

/** Character details. */
export type Character = {
  __typename?: 'Character';
  /** Opaque ID, suitable for caching this concept. */
  id?: Maybe<Scalars['ID']['output']>;
  language?: Maybe<DisplayableLanguage>;
  name: Scalars['String']['output'];
};

export type CharacterConnection = {
  __typename?: 'CharacterConnection';
  /** Pages of Character */
  edges: Array<Maybe<CharacterEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Character */
export type CharacterEdge = {
  __typename?: 'CharacterEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the Character */
  node: Character;
};

/**
 * Example:
 * 1. if you want to match titles with character name ('Micky Mouse' OR 'Pluto')
 * specify anyCharacterName: ['Micky Mouse', 'Pluto'].
 *
 * 2. if you want to match titles where name const ('nm0000138') played a character called ('Jordan')
 * specify characterSearchConstraint: { anyCharacterName: ['Jordan'], shouldLimitToCreditedNameIds: true }
 *  and
 * creditedNameConstraint: { anyNameIds: ['nm0000138'] }
 */
export type CharacterSearchConstraint = {
  /** A title match must contain AT LEAST ONE of these character names. */
  anyCharacterNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * If this is set to true when a CreditedNameConstraint anyNameIds, or allNameIds is specified, then a title match
   * must contain AT LEAST ONE of these character names, where AT LEAST ONE of the name ids
   * is playing them.
   *
   * the constraint will behave the same whether anyNameIds or allNameIds were used, meaning
   * characterSearchConstraint: { anyCharacterName: ['Jordan'], shouldLimitToCreditedNameIds: true }
   *  and
   * creditedNameConstraint: { anyNameIds: ['nm1706767', 'nm0000138', 'nm0000190'] }
   *  will return the same results
   * if anyNameIds was replaced with allNameIds, and specifying both allNameIds and anyNameIds will just combine the
   * name ids that are matched against the specified characters.
   */
  shouldLimitToCreditedNameIds?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChartEntry = {
  __typename?: 'ChartEntry';
  title: Title;
  weekendGross: BoxOfficeGross;
};

export type ChartNameEdge = {
  __typename?: 'ChartNameEdge';
  /** Current rank of the chart item */
  currentRank: Scalars['Int']['output'];
  cursor: Scalars['ID']['output'];
  node: Name;
  /**
   * If a previous rank exists, this is a set of fields comparing the current rank
   * to the previous rank
   */
  rankChange?: Maybe<RankChange>;
};

export type ChartNameOptions = {
  chartType: ChartNameType;
};

export type ChartNameSearchConnection = {
  __typename?: 'ChartNameSearchConnection';
  edges: Array<Maybe<ChartNameEdge>>;
  facet?: Maybe<Array<Maybe<SearchFacet>>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};


export type ChartNameSearchConnectionFacetArgs = {
  facetField: NameFacetField;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Enum exposing all the available name chart types */
export enum ChartNameType {
  MostPopularNames = 'MOST_POPULAR_NAMES'
}

export type ChartTitleEdge = {
  __typename?: 'ChartTitleEdge';
  /** Current rank of the chart item */
  currentRank: Scalars['Int']['output'];
  cursor: Scalars['ID']['output'];
  node: Title;
  /**
   * If a previous rank exists, this is a set of fields comparing the current rank
   * to the previous rank
   */
  rankChange?: Maybe<RankChange>;
};

export type ChartTitleOptions = {
  chartType: ChartTitleType;
};

export type ChartTitleSearchConnection = {
  __typename?: 'ChartTitleSearchConnection';
  edges: Array<Maybe<ChartTitleEdge>>;
  facet?: Maybe<Array<Maybe<SearchFacet>>>;
  /**
   * The number of titles in the filtered list that a customer has rated.
   * Customer Id is required for this field or an authentication error will be thrown.
   */
  myRatedCount?: Maybe<Scalars['Int']['output']>;
  /**
   * The percentage of titles in the filtered list that a customer has rated.  We round the percentage to the nearest
   * integer but we may change the precision depending on Product's requirement update.
   * Customer Id is required for this field or an authentication error will be thrown.
   */
  myRatedPercentage?: Maybe<LocalizedString>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};


export type ChartTitleSearchConnectionFacetArgs = {
  facetField: TitleFacetField;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Enum exposing all the available title chart types */
export enum ChartTitleType {
  LowestRatedMovies = 'LOWEST_RATED_MOVIES',
  MostPopularMovies = 'MOST_POPULAR_MOVIES',
  MostPopularTvShows = 'MOST_POPULAR_TV_SHOWS',
  TopRatedEnglishMovies = 'TOP_RATED_ENGLISH_MOVIES',
  TopRatedIndianMovies = 'TOP_RATED_INDIAN_MOVIES',
  TopRatedMalayalamMovies = 'TOP_RATED_MALAYALAM_MOVIES',
  TopRatedMovies = 'TOP_RATED_MOVIES',
  TopRatedTamilMovies = 'TOP_RATED_TAMIL_MOVIES',
  TopRatedTeluguMovies = 'TOP_RATED_TELUGU_MOVIES',
  TopRatedTvShows = 'TOP_RATED_TV_SHOWS'
}

/** Defines standard form constraints for a checkbox type of input. */
export type CheckboxFieldConstraints = {
  __typename?: 'CheckboxFieldConstraints';
  /**
   * Specifies whether selecting the checkbox is required, i.e.:
   * - If isRequired is true, the checkbox must be checked by the customer (e.g. a
   * confirmation dialog or "I agree to the terms and conditions").
   * - If isRequired is false, the checkbox can be either checked or unchecked
   * (e.g. a checkbox to confirm if a credit is uncredited/not listed in the end credits)
   */
  isRequired?: Maybe<BooleanValidationConstraint>;
};

/**
 * Cinema type
 * Extends external type.
 */
export type Cinema = {
  __typename?: 'Cinema';
  /**
   * Accessibility information for the cinema.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  accessibility?: Maybe<CinemaAccessibility>;
  /**
   * Contact details for the cinema.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  contactDetails?: Maybe<CinemaContactDetails>;
  /**
   * Distance from the requested location to the cinema.
   * 'location.radiusInMeters' has no effect on the result of this query
   *
   * Errors:
   * - Throws `BAD_USER_INPUT` with symbol `location.postalCode` if the location is unknown.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  distanceToCinema?: Maybe<DistanceToCinema>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  id: Scalars['ID']['output'];
  /**
   * Location information for the cinema.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  location?: Maybe<CinemaLocation>;
  /**
   * Name of the cinema.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  name?: Maybe<CinemaName>;
};


/**
 * Cinema type
 * Extends external type.
 */
export type CinemaDistanceToCinemaArgs = {
  location: ShowtimesLocation;
};

/** Accessibility information for a cinema. */
export type CinemaAccessibility = {
  __typename?: 'CinemaAccessibility';
  /** Indicates if the cinema provides hearing devices. */
  audioAccessibility?: Maybe<CinemaAudioAccessibility>;
  /** Indicates if the cinema has wheelchair access. */
  wheelchairAccessibility?: Maybe<CinemaWheelchairAccessibility>;
};

/** Audio accessibility information for a cinema. */
export type CinemaAudioAccessibility = {
  __typename?: 'CinemaAudioAccessibility';
  /** Indicates if the cinema provides hearing devices. */
  hasHearingDevices?: Maybe<Scalars['Boolean']['output']>;
};

/** Connection type for a paginated cinema result. */
export type CinemaConnection = {
  __typename?: 'CinemaConnection';
  /** Edges of CinemaConnection. */
  edges: Array<Maybe<CinemaEdge>>;
  /** Pagination information. */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set. */
  total: Scalars['Int']['output'];
};

/** Contact details for a cinema. */
export type CinemaContactDetails = {
  __typename?: 'CinemaContactDetails';
  /**
   * Phone number for the cinema.
   * A null `phoneNumber` value indicates that there is no phoneNumber available.
   */
  phoneNumber?: Maybe<Scalars['String']['output']>;
};

/** Edge type for a Cinema in a paginated result. */
export type CinemaEdge = {
  __typename?: 'CinemaEdge';
  /** Cursor for pagination. */
  cursor: Scalars['ID']['output'];
  /** Cinema information. */
  node: Cinema;
  /** Position of this edge in the result set. */
  position: Scalars['Int']['output'];
};

/** Location data of a cinema. */
export type CinemaLocation = {
  __typename?: 'CinemaLocation';
  /** Unique identifier for this cinema location. */
  id: Scalars['ID']['output'];
  /** Language of the cinema location display text. */
  language: DisplayableLanguage;
  /** Displayable text for this cinema location. */
  text: Scalars['String']['output'];
};

/** The name of a cinema. */
export type CinemaName = {
  __typename?: 'CinemaName';
  /** Unique identifier for this cinema name. */
  id: Scalars['ID']['output'];
  /** Language of the cinema name display text. */
  language: DisplayableLanguage;
  /** Text indicating the name of this cinema. */
  text: Scalars['String']['output'];
};

/** Wheelchair accessibility information for a cinema. */
export type CinemaWheelchairAccessibility = {
  __typename?: 'CinemaWheelchairAccessibility';
  /** Indicates if the cinema has wheelchair access. */
  hasWheelchairAccess?: Maybe<Scalars['Boolean']['output']>;
};

export type ClaimedName = {
  __typename?: 'ClaimedName';
  /** The requesting customer's claimed name */
  name?: Maybe<Name>;
  /** The status of name claiming */
  status: ClaimedNameStatus;
};

export enum ClaimedNameStatus {
  /** Customer's name claiming is blocked (usually by customer service admins) */
  Blocked = 'BLOCKED',
  /** Customer has claimed the name */
  Claimed = 'CLAIMED',
  /** Customer has not requested to claim a name */
  NotRequested = 'NOT_REQUESTED',
  /** Customer's name claiming is pending manual approval */
  PendingApproval = 'PENDING_APPROVAL',
  /** The new name page requested by customer is being created */
  PendingCreation = 'PENDING_CREATION',
  /** Customer had claimed the name page before but not anymore */
  PreviousClaimed = 'PREVIOUS_CLAIMED',
  /** Customer's name claiming is in an unknown status */
  Unknown = 'UNKNOWN'
}

export type ClientSort = {
  by?: InputMaybe<ClientSortBy>;
  order: SortOrder;
};

export enum ClientSortBy {
  /** Sort names alphabetically ASC: A-Z */
  Name = 'NAME',
  /**
   * Sort names based on their starMeterCurrentWeekRank
   *
   * ASC: Lower popularity score means that the name is more popular,
   * so the most popular names will be first
   */
  Popularity = 'POPULARITY'
}

/**
 * A coloration, along with any attributes. For example, we could have a color picture that used technicolor, with black
 * and white flashback scenes.
 */
export type Coloration = {
  __typename?: 'Coloration';
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** An ID for this coloration, suitable for use in URLs. For example, `black_and_white` or `color`. */
  conceptId: Scalars['String']['output'];
  /** Coloration as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationProperty;
  /** An opaque ID, suitable for caching the concept. */
  id: Scalars['ID']['output'];
  /** The display text */
  text: Scalars['String']['output'];
};

/**
 * Example: if you want to match titles of colorations COLOR OR ACES AND NOT BLACK_AND_WHITE,
 * specify anyColorationTypes: [COLOR,ACES] plus excludeColorationTypes: [BLACK_AND_WHITE]
 */
export type ColorationSearchConstraint = {
  /** A title match must contain AT LEAST ONE of these colorations */
  anyColorationTypes?: InputMaybe<Array<InputMaybe<ColorationType>>>;
  /**
   * A title match must contain NONE of these colorations
   *
   * If the same input is specified in the any and exclude constraints,
   * then the results should be empty.
   */
  excludeColorationTypes?: InputMaybe<Array<InputMaybe<ColorationType>>>;
};

export enum ColorationType {
  Aces = 'ACES',
  BlackAndWhite = 'BLACK_AND_WHITE',
  Color = 'COLOR',
  Colorized = 'COLORIZED'
}

/** Colorations for this title. */
export type Colorations = {
  __typename?: 'Colorations';
  /** The list of coloration items */
  items: Array<Maybe<Coloration>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of coloration items */
  total: Scalars['Int']['output'];
};

export type ComingSoonSort = {
  /** Field to sort by */
  sortBy: ComingSoonSortBy;
  /** ASC or DESC sorting order */
  sortOrder: SortOrder;
};

export enum ComingSoonSortBy {
  /** Movie meter value */
  Popularity = 'POPULARITY',
  /** Release Date for sorting purposes */
  ReleaseDate = 'RELEASE_DATE'
}

export enum ComingSoonType {
  /** Feature films */
  Movie = 'MOVIE',
  /** Series/miniseries with upcoming episodes and made-for-TV movies */
  Tv = 'TV',
  /** TV Episodes */
  TvEpisode = 'TV_EPISODE'
}

/** Implementation of the LocalizedDisplayableConcept interface. See LocalizedDisplayableConcept docs */
export type CommonLocalizedDisplayableConcept = {
  __typename?: 'CommonLocalizedDisplayableConcept';
  /** Type token */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** The display text */
  text: Scalars['String']['output'];
};

export type Company = {
  __typename?: 'Company';
  /**
   * The acronyms of a given company
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  acronyms?: Maybe<CompanyAcronymConnection>;
  /**
   * The affiliations of a given company
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  affiliations?: Maybe<CompanyAffiliationConnection>;
  /**
   * Details of the company bio. Returns null if no bio available.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedCompany
   * - CTI: IMDb/GraphQL/Managed Company
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  bio?: Maybe<CompanyBio>;
  /**
   * Details about the branches (generally the different offices) of this company.
   * Larger companies like Disney have offices in multiple locations, each one
   * with its own staff, contact details, etc.
   *
   * Not all companies have branch information, and some companies only have one.
   *
   * Will return an empty set of edges if we have no branch information for the
   * company.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  branches?: Maybe<CompanyBranchConnection>;
  /**
   * The names represented by this company in some capacity, like
   * the names this company provides PR or Legal services for.
   *
   * Generally when a company represents a name there are employees
   * at the company specifically associated with that representation
   * but not all companies have associated representatives.
   *
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  clients?: Maybe<CompanyClientConnection>;
  /**
   * The localized text for the company.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  companyText?: Maybe<CompanyText>;
  /**
   * The types of a given company
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  companyTypes?: Maybe<Array<Maybe<CompanyType>>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  country?: Maybe<LocalizedDisplayableCountry>;
  /**
   * @experimental Experimental: DO NOT USE
   *
   * Details about the branches (generally the different offices) of this company.
   * Larger companies like Disney have offices in multiple locations, each one
   * with its own staff, contact details, etc.
   *
   * Not all companies have branch information, and some companies only have one.
   *
   * Will return an empty set of edges if we have no branch information for the
   * company.
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  experimental_branches?: Maybe<Experimental_CompanyBranchConnection>;
  /**
   * @experimental Experimental: DO NOT USE
   *
   * The names represented by this company in some capacity, like
   * the names this company provides PR or Legal services for.
   *
   * Generally when a company represents a name there are employees
   * at the company specifically associated with that representation
   * but not all companies have associated representatives.
   *
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  experimental_clients?: Maybe<Experimental_CompanyClientConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  id: Scalars['ID']['output'];
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  images?: Maybe<ImageConnection>;
  /**
   * Key staff for the company, ordered by StarMeter ranking (ASC) by default.
   * Defaults to 10 results if first is omitted.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedCompany
   * - CTI: IMDb/GraphQL/Managed Company
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  keyStaff?: Maybe<CompanyKeyStaffConnection>;
  /**
   * Known for clients for this company, ordered by relevance.
   * Defaults to 10 results if first is omitted.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedCompany
   * - CTI: IMDb/GraphQL/Managed Company
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  knownForClients?: Maybe<CompanyKnownForClientConnection>;
  /**
   * Known for titles for this company, ordered by relevance.
   * Defaults to 10 results if first is omitted.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedCompany
   * - CTI: IMDb/GraphQL/Managed Company
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  knownForTitles?: Maybe<CompanyKnownForTitleConnection>;
  /**
   * Data that company managers control for consumption by company manager and IMDb admins.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedCompany
   * - CTI: IMDb/GraphQL/Managed Company
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  managedData?: Maybe<ManagedCompanyData>;
  /**
   * CompanyMeter rank information
   * Ranking information beyond 5000 requires entitlement proving Pro subscription.
   * Use useEntitlement = false to access non entitled version.
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ranking
   * - CTI: IMDb/GraphQL/ProRanking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  meterRank?: Maybe<CompanyMeterRanking>;
  /**
   * History of IMDbPro COMPANYmeter rankings of a company.
   * Requires entitlement proving Pro subscription.
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ranking
   * - CTI: IMDb/GraphQL/ProRanking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  meterRankingHistory?: Maybe<CompanyMeterRankingHistory>;
  /**
   * The primary image for the company.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  primaryImage?: Maybe<Image>;
  /**
   * All occupations used by staff at this company. Returns null if the company has no staff.
   * Occupations is a limited set of 10 possibilities (as of 2025) so there is no need for pagination.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedCompany
   * - CTI: IMDb/GraphQL/Managed Company
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  staffOccupations?: Maybe<Array<Maybe<CompanyEmployeeOccupation>>>;
};


export type CompanyAcronymsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CompanyAffiliationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<CompanyAffiliationSort>;
};


export type CompanyBranchesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


export type CompanyClientsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<ClientSort>;
};


export type CompanyCompanyTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type CompanyExperimental_BranchesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


export type CompanyExperimental_ClientsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<ClientSort>;
};


export type CompanyImagesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  bust?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<CompanyImagesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CompanyKeyStaffArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<KeyStaffFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<KeyStaffSort>;
};


export type CompanyKnownForClientsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type CompanyKnownForTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type CompanyMeterRankArgs = {
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CompanyMeterRankingHistoryArgs = {
  input?: InputMaybe<CompanyMeterRankingHistoryInput>;
};

/** An acronym of a company */
export type CompanyAcronym = {
  __typename?: 'CompanyAcronym';
  /** Company acronym ID */
  id: Scalars['ID']['output'];
  /** The language the text is written in */
  language: DisplayableLanguage;
  /** The displayable acronym , e.g. 'CAA' for Creative Artists Agency */
  text: Scalars['String']['output'];
};

/** Pagination for CompanyAcronym which always has a known total number of edges */
export type CompanyAcronymConnection = {
  __typename?: 'CompanyAcronymConnection';
  /** Pages of CompanyAcronym */
  edges: Array<Maybe<CompanyAcronymEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of CompanyAcronym */
export type CompanyAcronymEdge = {
  __typename?: 'CompanyAcronymEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the page */
  node: CompanyAcronym;
  /** Position of the node in this context, eg: CompanyAcronym 4 out of 31 */
  position: Scalars['Int']['output'];
};

/** The affiliated company */
export type CompanyAffiliation = {
  __typename?: 'CompanyAffiliation';
  /** The company that is affiliated */
  company: Company;
  /** Company affiliation ID */
  id: Scalars['ID']['output'];
  /** The language the text is written in */
  language: DisplayableLanguage;
  /** The displayable affiliation, e.g. 'Subsidiary of' */
  text: Scalars['String']['output'];
};

/** Pagination for CompanyAffiliation which always has a known total number of edges */
export type CompanyAffiliationConnection = {
  __typename?: 'CompanyAffiliationConnection';
  /** Pages of CompanyAffiliation */
  edges: Array<Maybe<CompanyAffiliationEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of CompanyAffiliation */
export type CompanyAffiliationEdge = {
  __typename?: 'CompanyAffiliationEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the page */
  node: CompanyAffiliation;
  /** Position of the node in this context, eg: CompanyAffiliation 4 out of 31 */
  position: Scalars['Int']['output'];
};

/** Sort options for company affiliations */
export type CompanyAffiliationSort = {
  /** Field to sort by */
  by: CompanyAffiliationSortBy;
  /** Sort order */
  order: SortOrder;
};

/** Fields available for sorting company affiliations */
export enum CompanyAffiliationSortBy {
  /** Sort by affiliation type alphabetically using CompanyAffiliation.text */
  AffiliationType = 'AFFILIATION_TYPE',
  /** Sort by affiliated company ID (default behavior) */
  CompanyId = 'COMPANY_ID',
  /** Sort by affiliated company name alphabetically using Company.companyText */
  CompanyName = 'COMPANY_NAME'
}

export type CompanyBio = {
  __typename?: 'CompanyBio';
  /** The bio as a displayable article */
  displayableArticle: DisplayableArticle;
  /** Unique ID for this bio item */
  id: Scalars['ID']['output'];
  /** The language of the bio text */
  language: DisplayableLanguage;
  /** The bio text */
  text: Markdown;
};

export type CompanyBranch = {
  __typename?: 'CompanyBranch';
  /** Ways to contact this part of the company directly */
  directContact?: Maybe<CompanyContactDetails>;
  /** An obfuscated persistent id to uniquely identify this data */
  id: Scalars['ID']['output'];
  /** Branch name */
  name?: Maybe<LocalizedString>;
};

export type CompanyBranchConnection = {
  __typename?: 'CompanyBranchConnection';
  edges: Array<Maybe<CompanyBranchEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type CompanyBranchEdge = {
  __typename?: 'CompanyBranchEdge';
  cursor: Scalars['ID']['output'];
  node: CompanyBranch;
  position: Scalars['Int']['output'];
};

export type CompanyClient = {
  __typename?: 'CompanyClient';
  /**
   * The employees working at this company who work with the client
   * in this type of relationship
   *
   * Returns nothing if we have no information about the individual
   * employees at this company who work specifically with this client.
   */
  agents?: Maybe<Array<Maybe<Agent>>>;
  /** The name being represented */
  client: Name;
  /** An obfuscated persistent id to uniquely identify this data */
  id: Scalars['ID']['output'];
};

export type CompanyClientConnection = {
  __typename?: 'CompanyClientConnection';
  edges: Array<Maybe<CompanyClientEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type CompanyClientEdge = {
  __typename?: 'CompanyClientEdge';
  cursor: Scalars['ID']['output'];
  node: CompanyClient;
  position: Scalars['Int']['output'];
};

export type CompanyContactDetails = {
  __typename?: 'CompanyContactDetails';
  emailAddress?: Maybe<Scalars['String']['output']>;
  faxNumber?: Maybe<LocalizedString>;
  phoneNumbers?: Maybe<Array<Maybe<LocalizedString>>>;
  /** A physical mailing address for this company or this company's specific office */
  physicalAddress?: Maybe<Location>;
  website?: Maybe<WebsiteLink>;
};

export type CompanyCredit = {
  __typename?: 'CompanyCredit';
  /** This field may contain distribution format, opening credit and other attributes related to credit of a company */
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** Category (e.g. 'Production'). */
  category: CompanyCreditCategory;
  /** The company credited */
  company: Company;
  /** The countries in which this company was involved with this title */
  countries?: Maybe<Array<Maybe<DisplayableCountry>>>;
  /** Company credit as displayable property */
  displayableProperty: DisplayableTitleCompanyCreditProperty;
  /**
   * For distribution companies it lists the different formats the company is
   * distributing the title in. For other company credits it always returns null.
   */
  distributionFormats?: Maybe<Array<Maybe<DistributionFormat>>>;
  /** The title on which this credit appears */
  title: Title;
  /** Start and optionally end year(s) that this company was involved with this title */
  yearsInvolved?: Maybe<YearRange>;
};


export type CompanyCreditAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type CompanyCreditCountriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** The category for the company credit, e.g. sales, distribution etc. */
export type CompanyCreditCategory = {
  __typename?: 'CompanyCreditCategory';
  /** The unique identifier for the credit category */
  id: Scalars['ID']['output'];
  /** The displayable text for the credit category */
  text: Scalars['String']['output'];
};

export type CompanyCreditCategoryWithCompanyCredits = {
  __typename?: 'CompanyCreditCategoryWithCompanyCredits';
  category?: Maybe<CompanyCreditCategory>;
  companyCredits?: Maybe<CompanyCreditConnection>;
  restriction?: Maybe<CompanyCreditRestriction>;
};


export type CompanyCreditCategoryWithCompanyCreditsCompanyCreditsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for CompanyCredit type. */
export type CompanyCreditConnection = {
  __typename?: 'CompanyCreditConnection';
  /** Pages of credits */
  edges: Array<Maybe<CompanyCreditEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<CompanyCreditRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of credits */
export type CompanyCreditEdge = {
  __typename?: 'CompanyCreditEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A CompanyCredit node */
  node: CompanyCredit;
  /** Position of the node in this context, eg: credit 4 out of 312 */
  position: Scalars['Int']['output'];
};

/** Information about restrictions applied to Company Credits */
export type CompanyCreditRestriction = {
  __typename?: 'CompanyCreditRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

export type CompanyCreditsFilter = {
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** The occupation the client held while employed by the company */
export type CompanyEmployeeOccupation = {
  __typename?: 'CompanyEmployeeOccupation';
  /** The unique identifier for a particular occupation */
  id: Scalars['ID']['output'];
  /** The language that the text is in */
  language: DisplayableLanguage;
  /** The localized text describing the job, e.g. talent agent, executive */
  text: Scalars['String']['output'];
};

/** The title a company employee held while working for a company */
export type CompanyEmployeeTitle = {
  __typename?: 'CompanyEmployeeTitle';
  /** The unique identifier for a particular title */
  id: Scalars['ID']['output'];
  /** The language that the text is in */
  language: DisplayableLanguage;
  /** The localized text describing the title, e.g. managing partner */
  text: Scalars['String']['output'];
};

/** The employment relationship a staff member has with a company */
export type CompanyEmployment = {
  __typename?: 'CompanyEmployment';
  /** The name of the branch that the employee works */
  branch?: Maybe<EmployeeBranchName>;
  /** The occupation the staff memeber performed for this company, e.g. talent agent, executive */
  occupation: CompanyEmployeeOccupation;
  /** The title the staff member had at this company, e.g. managing partner */
  title: CompanyEmployeeTitle;
};

export type CompanyImagesFilter = {
  /** Return only images which are one of these types */
  types?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** The job for a company credit that has detail beyond the job category, free form text */
export type CompanyJob = {
  __typename?: 'CompanyJob';
  /** Unique identifier that matches the text string itself since jobs are free form text */
  id: Scalars['ID']['output'];
  /** The language that the text is in */
  language: DisplayableLanguage;
  /** The text describing the job */
  text: Scalars['String']['output'];
};

/** A key staff memeber of a company */
export type CompanyKeyStaff = {
  __typename?: 'CompanyKeyStaff';
  /** A key staff memeber for this company */
  name: Name;
  /** A summary of the relationship the staff member has with this company */
  summary: CompanyKeyStaffSummary;
};

/** Pagination for company key staff which always has a known total number of edges */
export type CompanyKeyStaffConnection = {
  __typename?: 'CompanyKeyStaffConnection';
  /** Pages of company key staff for this company */
  edges: Array<Maybe<CompanyKeyStaffEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of staff members available in the pool for this company */
  recordPoolSize: Scalars['Int']['output'];
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of company key staff */
export type CompanyKeyStaffEdge = {
  __typename?: 'CompanyKeyStaffEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A company key staff node */
  node: CompanyKeyStaff;
  /** Position of the node in this context, eg: CompanyKeyStaffEdge 4 out of 100 */
  position: Scalars['Int']['output'];
};

/** A summary of the relationship a company has a the key staff member */
export type CompanyKeyStaffSummary = {
  __typename?: 'CompanyKeyStaffSummary';
  /** How this company has employed this staff member */
  employment?: Maybe<Array<Maybe<CompanyEmployment>>>;
};


/** A summary of the relationship a company has a the key staff member */
export type CompanyKeyStaffSummaryEmploymentArgs = {
  limit: Scalars['Int']['input'];
};

/** Page of company key staff version */
export type CompanyKeyStaffVersionEdge = {
  __typename?: 'CompanyKeyStaffVersionEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A key saff version node */
  node: ManagedCompanyKnownForKeyStaffVersion;
  /** Position of the node in this context, eg: ManagedCompanyKnownForKeyStaffVersion 4 out of 100 */
  position: Scalars['Int']['output'];
};

/** A known for client for a company */
export type CompanyKnownForClient = {
  __typename?: 'CompanyKnownForClient';
  /** A client this company is known for */
  name: Name;
  /** A summary of the relationship the known for client has with this company */
  summary: CompanyKnownForClientSummary;
};

/** Pagination for company known for client which always has a known total number of edges */
export type CompanyKnownForClientConnection = {
  __typename?: 'CompanyKnownForClientConnection';
  /** Pages of company known for client for this company */
  edges: Array<Maybe<CompanyKnownForClientEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of clients available in the pool for this company */
  recordPoolSize: Scalars['Int']['output'];
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of company known for client */
export type CompanyKnownForClientEdge = {
  __typename?: 'CompanyKnownForClientEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A company known for client node */
  node: CompanyKnownForClient;
  /** Position of the node in this context, eg: CompanyKnownForClient 4 out of 100 */
  position: Scalars['Int']['output'];
};

/** A summary of the relationship the company has with the client it is known for */
export type CompanyKnownForClientSummary = {
  __typename?: 'CompanyKnownForClientSummary';
  /** The ways in which this company represented this client */
  representation?: Maybe<Array<Maybe<CompanyRepresentationCategory>>>;
  /** The ways in which this company represents this client aggregated by representation type */
  representationCategories?: Maybe<Array<Maybe<CompanyRepresentationCategories>>>;
};


/** A summary of the relationship the company has with the client it is known for */
export type CompanyKnownForClientSummaryRepresentationArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Page of company known for client version */
export type CompanyKnownForClientVersionEdge = {
  __typename?: 'CompanyKnownForClientVersionEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A known for client version node */
  node: ManagedCompanyKnownForClientVersion;
  /** Position of the node in this context, eg: ManagedCompanyKnownForClientVersion 4 out of 100 */
  position: Scalars['Int']['output'];
};

/** The job category for a company credit */
export type CompanyKnownForCreditCategory = {
  __typename?: 'CompanyKnownForCreditCategory';
  /** Unique identifier for the credit category */
  id: Scalars['ID']['output'];
  /** The language the text is in */
  language: DisplayableLanguage;
  /** The text describing the credit category */
  text: Scalars['String']['output'];
};

/** The job a company did on a particular known for */
export type CompanyKnownForJob = {
  __typename?: 'CompanyKnownForJob';
  /** The job category, e.g. distribution, production etc. */
  category: CompanyKnownForCreditCategory;
  /** The job that has detail beyond the job category, free form text */
  job?: Maybe<CompanyJob>;
};

/** The status of a known for category for consumption by IMDb admins */
export enum CompanyKnownForStatus {
  /** Indicates that the known for is active and can be modified */
  Active = 'ACTIVE',
  /** Indicates that the known for is blocked from modification */
  Blocked = 'BLOCKED'
}

/** A Known for title for a company */
export type CompanyKnownForTitle = {
  __typename?: 'CompanyKnownForTitle';
  /** A summary of the relationship the known for title has with this company */
  summary: CompanyKnownForTitleSummary;
  /** A title this company is known for */
  title: Title;
};

/** Pagination for company known for title which always has a known total number of edges */
export type CompanyKnownForTitleConnection = {
  __typename?: 'CompanyKnownForTitleConnection';
  /** Pages of company known for title for this company */
  edges: Array<Maybe<CompanyKnownForTitleEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of titles available in the pool for this company */
  recordPoolSize: Scalars['Int']['output'];
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of company known for title */
export type CompanyKnownForTitleEdge = {
  __typename?: 'CompanyKnownForTitleEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A company known for title node */
  node: CompanyKnownForTitle;
  /** Position of the node in this context, eg: CompanyKnownForTitle 4 out of 100 */
  position: Scalars['Int']['output'];
};

/** A summary of the relationship a company has with a title it is known for */
export type CompanyKnownForTitleSummary = {
  __typename?: 'CompanyKnownForTitleSummary';
  /** The countries the company did work for the known for title in */
  countries?: Maybe<Array<Maybe<DisplayableCountry>>>;
  /** The jobs this company performed on the known for title */
  jobs: Array<Maybe<CompanyKnownForJob>>;
  /** The year range the company was associated with the known for title. A single displayed if the start matches the end. */
  yearRange?: Maybe<YearRange>;
};

/** Page of company known for title version */
export type CompanyKnownForTitleVersionEdge = {
  __typename?: 'CompanyKnownForTitleVersionEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A known for title version node */
  node: ManagedCompanyKnownForTitleVersion;
  /** Position of the node in this context, eg: ManagedCompanyKnownForTitleVersion 4 out of 100 */
  position: Scalars['Int']['output'];
};

export type CompanyMetadata = {
  __typename?: 'CompanyMetadata';
  /** All the company credit categories */
  companyCreditCategories: Array<Maybe<CompanyCreditCategory>>;
};

export type CompanyMeterRanking = {
  __typename?: 'CompanyMeterRanking';
  /**
   * The current IMDbPro CompanyMeter ranking of the company. A lower value is better.
   * Ranking information beyond 5000 requires entitlement proving Pro subscription.
   */
  currentRank: Scalars['Int']['output'];
  /**
   * If a previous rank exists, this is a set of fields comparing the current rank
   * to the previous rank
   */
  rankChange?: Maybe<MeterRankChange>;
};

export type CompanyMeterRankingHistory = {
  __typename?: 'CompanyMeterRankingHistory';
  /**
   * The best historical IMDbPro COMPANYmeter ranking of a company.
   * A lower value is better. By default, returns the values over all time.
   * Requires entitlement proving Pro subscription.
   */
  bestRank?: Maybe<MeterRankingHistoryEntry>;
  /**
   * History of IMDbPro COMPANYmeter rankings of a company.
   * Requires entitlement proving Pro subscription.
   */
  ranks?: Maybe<Array<Maybe<MeterRankingHistoryEntry>>>;
  restriction?: Maybe<MeterRestriction>;
};

export type CompanyMeterRankingHistoryInput = {
  /**
   * Last date to obtain COMPANYmeter history for. If not provided, default is most recent ranking date.
   * If there is no ranking on end date, the date is the most recent date before this one.
   */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /**
   * First date to obtain COMPANYmeter history for. If not provided, default is first ranking date.
   * If there is no ranking on start date, the date is the earliest date after this one.
   */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** A breakdown of a type of representative that represents this client */
export type CompanyRepresentationCategories = {
  __typename?: 'CompanyRepresentationCategories';
  /** The unique id for the representation type */
  id: Scalars['ID']['output'];
  /** The language that the text is in */
  language: DisplayableLanguage;
  /** The text for the representation type, will be plural for total > 1. Agent types rolled up to 'agent'/'agents' */
  text: Scalars['String']['output'];
  /** The total number of this type of representative that represent the client */
  total: Scalars['Int']['output'];
};

/** The type of client representation a company performed for a client */
export type CompanyRepresentationCategory = {
  __typename?: 'CompanyRepresentationCategory';
  /** The unique identifier for a particular category */
  id: Scalars['ID']['output'];
  /** The language that the text is in */
  language: DisplayableLanguage;
  /** The localized text describing the type of representation, e.g. talent agent */
  text: Scalars['String']['output'];
};

export type CompanyText = {
  __typename?: 'CompanyText';
  text: Scalars['String']['output'];
};

/** The type of a company */
export type CompanyType = {
  __typename?: 'CompanyType';
  /** Company type ID */
  id: Scalars['ID']['output'];
  /** The language the text is written in */
  language: DisplayableLanguage;
  /** The displayable company type, e.g. 'Talent Agency' */
  text: Scalars['String']['output'];
};

export type ConnectionCategoryWithConnections = {
  __typename?: 'ConnectionCategoryWithConnections';
  category: TitleConnectionCategory;
  connections?: Maybe<TitleConnectionConnection>;
};


export type ConnectionCategoryWithConnectionsConnectionsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type ConnectionsFilter = {
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Common interface for all consent types */
export type Consent = {
  consentOperation: ConsentOperation;
  consentType: ConsentType;
  /**
   * This is the time at which this consent
   * is no longer valid for this user.
   */
  expirationDate: Scalars['DateTime']['output'];
};

export enum ConsentOperation {
  /** Customized consent, can be returned by Queries but not used as Mutation input. */
  Custom = 'CUSTOM',
  /**
   * Opt in to the consent. i.e. Yes or 'accept all'
   * Note: Default consent operation for a given type
   * is provided in the consentRequirement
   */
  In = 'IN',
  /**
   * Opt out of the consent. i.e. No or 'reject all'
   * Note: Default consent operation for a given type
   * is provided in the consentRequirement
   */
  Out = 'OUT'
}

export enum ConsentType {
  /**
   * Consent for not sharing customer information with third parties.
   * For IMDb, this disables cross contextual behavioral advertising.
   */
  ThirdPartyDataSharing = 'THIRD_PARTY_DATA_SHARING',
  /**
   * Used for Cookie/Tracker consent. Corresponds to "CookieConsent"
   * model in TollhouseService. https://tiny.amazon.com/1hii9awk1/codeamazpackPRIVblobb59emode
   */
  TrackingCookie = 'TRACKING_COOKIE'
}

export enum ContentRestrictionReason {
  /** The title is announced */
  ProAnnouncedTitle = 'PRO_ANNOUNCED_TITLE',
  /** The title is in development */
  ProInDevTitle = 'PRO_IN_DEV_TITLE'
}

export type ContentWarnings = {
  __typename?: 'ContentWarnings';
  /** A boolean flag that indicates whether IMDb considers this person's work to be primarily pornographic or adult genre. */
  isPrimarilyAdultActor: Scalars['Boolean']['output'];
};

/** All of the context required to render a contribution link. */
export type ContributionContext = {
  /**
   * Determines which site we are rendering from. Valid: 'consumer', 'pro'.
   * Defaults to 'consumer'.
   * See: https://tiny.amazon.com/t8frko7h
   */
  business?: InputMaybe<Scalars['String']['input']>;
  /** Optional flag to determine if this is in an iframe or behind a redirect */
  isInIframe?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Where to redirect to once contribution is done. Accepts variable substitutions.
   * {id}
   *  will be substituted with the item's ID you are trying to contribute to (eg: Name, Title, Image)
   * {relatedId}
   *  if provided will be substituted with the ID of the context this
   * item is in, if applicable (eg: Name that Image is in the gallery of)
   */
  returnUrl: Scalars['URL']['input'];
};

/** Contains the URL for contributing to this data type. Is a type for extendability. */
export type ContributionLink = {
  __typename?: 'ContributionLink';
  url: Scalars['URL']['output'];
};

export type Contributor = {
  __typename?: 'Contributor';
  /** The user ID */
  id: Scalars['ID']['output'];
  /** The user profile for this contributor */
  user?: Maybe<UserProfile>;
};

export type ContributorLeaderboard = {
  __typename?: 'ContributorLeaderboard';
  /** Description of the leaderboard, to appear under title */
  description?: Maybe<LocalizedString>;
  id: Scalars['ID']['output'];
  /** Have rankings been finalized or can they still change */
  isFinalized: Scalars['Boolean']['output'];
  /** Date last updated */
  lastUpdated: Scalars['DateTime']['output'];
  /** Public url of the leaderboard */
  leaderboardUrl: Scalars['URL']['output'];
  /**
   * Month of leaderboard if appropriate (null for ALL_TIME and YEAR periods)
   * 1=Jan, 2=Feb, 3=Mar etc
   */
  month?: Maybe<Scalars['Int']['output']>;
  /** Type of period that the leaderboard covers */
  period: ContributorLeaderboardPeriodType;
  /**
   * Paginated rankings in ascending order, jumpTo option for jumping to a specific contributorId or rank in the leaderboard.
   * Please do not use cursors (after, before, jumpTo) in rankings queries when
   * nested within the results of a paginated leaderboard query
   * to avoid unintended side effects.
   */
  rankings: ContributorRankingsConnection;
  /** Title of the leaderboard */
  title: LocalizedString;
  /** Total approved items for this period and type */
  totalApprovedItems: Scalars['Int']['output'];
  /** Total contributors for this period and type */
  totalContributors: Scalars['Int']['output'];
  /** Year of leaderboard if appropriate (null for ALL_TIME periods) */
  year?: Maybe<Scalars['Int']['output']>;
};


export type ContributorLeaderboardRankingsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ContributorLeaderboardRankingsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<ContributorRankSort>;
};

export type ContributorLeaderboardConnection = {
  __typename?: 'ContributorLeaderboardConnection';
  edges: Array<Maybe<ContributorLeaderboardEdge>>;
  pageInfo: PageInfo;
};

export type ContributorLeaderboardEdge = {
  __typename?: 'ContributorLeaderboardEdge';
  cursor: Scalars['ID']['output'];
  node: ContributorLeaderboard;
};

export type ContributorLeaderboardPeriodType = {
  __typename?: 'ContributorLeaderboardPeriodType';
  id: ContributorLeaderboardPeriodTypeId;
};

export enum ContributorLeaderboardPeriodTypeId {
  AllTime = 'ALL_TIME',
  Month = 'MONTH',
  Year = 'YEAR'
}

export type ContributorLeaderboardRank = {
  __typename?: 'ContributorLeaderboardRank';
  /** Leaderboard this ranking is sourced from */
  leaderboard: ContributorLeaderboard;
  /** Rank position and counts */
  ranking: ContributorRank;
};

export type ContributorLeaderboardRankConnection = {
  __typename?: 'ContributorLeaderboardRankConnection';
  edges: Array<Maybe<ContributorLeaderboardRankEdge>>;
  pageInfo: PageInfo;
};

export type ContributorLeaderboardRankEdge = {
  __typename?: 'ContributorLeaderboardRankEdge';
  cursor: Scalars['ID']['output'];
  node: ContributorLeaderboardRank;
};

export type ContributorLeaderboardRankingsFilter = {
  /** Limit the returned and sorted results to a maximum rank to support top ranking queries */
  maximumRank?: InputMaybe<Scalars['Int']['input']>;
};

export type ContributorLeaderboards = {
  __typename?: 'ContributorLeaderboards';
  /** Returns page of all leaderboards in reverse chronological order */
  all: ContributorLeaderboardConnection;
  /** Returns the all-time leaderboard */
  allTime?: Maybe<ContributorLeaderboard>;
  /** Returns the leaderboard for a specific month */
  month?: Maybe<ContributorLeaderboard>;
  /** Returns page of monthly leaderboards in reverse chronological order */
  months: ContributorLeaderboardConnection;
  /** Returns the leaderboard for a specific year */
  year?: Maybe<ContributorLeaderboard>;
  /** Returns page of yearly leaderboards in reverse chronological order */
  years: ContributorLeaderboardConnection;
};


export type ContributorLeaderboardsAllArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type ContributorLeaderboardsMonthArgs = {
  month: Scalars['Int']['input'];
  year: Scalars['Int']['input'];
};


export type ContributorLeaderboardsMonthsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ContributorLeaderboardsByMonthFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type ContributorLeaderboardsYearArgs = {
  year: Scalars['Int']['input'];
};


export type ContributorLeaderboardsYearsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ContributorLeaderboardsByYearFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type ContributorLeaderboardsByMonthFilter = {
  /** Optionally filter by leaderboards for specific months */
  months?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Optionally filter by leaderboards for specific years */
  years?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

export type ContributorLeaderboardsByYearFilter = {
  /** Optionally filter by leaderboards for specific years */
  years?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

export type ContributorRank = {
  __typename?: 'ContributorRank';
  /** Number of contribution items submitted and subsequently approved */
  approvedItems: Scalars['Int']['output'];
  /** Difference in items contributed from last period */
  approvedItemsDelta?: Maybe<Scalars['Int']['output']>;
  /** Contributor ranked at this position, null means they are anonymous */
  contributor?: Maybe<Contributor>;
  id: Scalars['ID']['output'];
  /** Numerical rank position, where 1 is the contributor with the highest approved contribution items. */
  rank: Scalars['Int']['output'];
  /** Difference in rank from last period */
  rankDelta?: Maybe<Scalars['Int']['output']>;
};

export type ContributorRankEdge = {
  __typename?: 'ContributorRankEdge';
  cursor: Scalars['ID']['output'];
  node: ContributorRank;
};

export type ContributorRankSort = {
  by?: InputMaybe<ContributorRankSortBy>;
  order?: InputMaybe<SortOrder>;
};

export enum ContributorRankSortBy {
  /** Sort contributors by delta in their number of approved items from the previous period */
  ApprovedItemsDelta = 'APPROVED_ITEMS_DELTA',
  /** Sort contributors by approved contribution item count (i.e number of items accepted into the IMDb catalog) */
  Rank = 'RANK',
  /** Sort contributors by delta in their rank from the previous period */
  RankDelta = 'RANK_DELTA'
}

export type ContributorRankingsConnection = {
  __typename?: 'ContributorRankingsConnection';
  edges: Array<Maybe<ContributorRankEdge>>;
  pageInfo: PageInfo;
};

export type ContributorRankingsFilter = {
  /** User id of contributor to filter on */
  contributorId: Scalars['ID']['input'];
  /** Optionally filter by rankings for leaderboards for specific months */
  months?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Returns ranking for leaderboards of all period types if omitted */
  period?: InputMaybe<Array<InputMaybe<ContributorLeaderboardPeriodTypeId>>>;
  /** Optionally filter by rankings for leaderboards for specific years */
  years?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** Closed interval of a countable value */
export type CountInterval = {
  max?: InputMaybe<Scalars['Int']['input']>;
  min?: InputMaybe<Scalars['Int']['input']>;
};

export type CountriesOfOrigin = {
  __typename?: 'CountriesOfOrigin';
  countries: Array<Maybe<CountryOfOrigin>>;
  /** DEPRECATED - DO NOT USE */
  language: DisplayableLanguage;
};


export type CountriesOfOriginCountriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export enum Country {
  Ad = 'AD',
  Ae = 'AE',
  Af = 'AF',
  Ag = 'AG',
  Ai = 'AI',
  Al = 'AL',
  Am = 'AM',
  An = 'AN',
  Ao = 'AO',
  Aq = 'AQ',
  Ar = 'AR',
  As = 'AS',
  At = 'AT',
  Au = 'AU',
  Aw = 'AW',
  Ax = 'AX',
  Az = 'AZ',
  Ba = 'BA',
  Bb = 'BB',
  Bd = 'BD',
  Be = 'BE',
  Bf = 'BF',
  Bg = 'BG',
  Bh = 'BH',
  Bi = 'BI',
  Bj = 'BJ',
  Bl = 'BL',
  Bm = 'BM',
  Bn = 'BN',
  Bo = 'BO',
  Bq = 'BQ',
  Br = 'BR',
  Bs = 'BS',
  Bt = 'BT',
  Bv = 'BV',
  Bw = 'BW',
  By = 'BY',
  Bz = 'BZ',
  Ca = 'CA',
  Cc = 'CC',
  Cd = 'CD',
  Cf = 'CF',
  Cg = 'CG',
  Ch = 'CH',
  Ci = 'CI',
  Ck = 'CK',
  Cl = 'CL',
  Cm = 'CM',
  Cn = 'CN',
  Co = 'CO',
  Cr = 'CR',
  Cs = 'CS',
  Cu = 'CU',
  Cv = 'CV',
  Cw = 'CW',
  Cx = 'CX',
  Cy = 'CY',
  Cz = 'CZ',
  De = 'DE',
  Dj = 'DJ',
  Dk = 'DK',
  Dm = 'DM',
  Do = 'DO',
  Dz = 'DZ',
  Ec = 'EC',
  Ee = 'EE',
  Eg = 'EG',
  Eh = 'EH',
  Er = 'ER',
  Es = 'ES',
  Et = 'ET',
  Fi = 'FI',
  Fj = 'FJ',
  Fk = 'FK',
  Fm = 'FM',
  Fo = 'FO',
  Fr = 'FR',
  Ga = 'GA',
  Gb = 'GB',
  Gd = 'GD',
  Ge = 'GE',
  Gf = 'GF',
  Gg = 'GG',
  Gh = 'GH',
  Gi = 'GI',
  Gl = 'GL',
  Gm = 'GM',
  Gn = 'GN',
  Gp = 'GP',
  Gq = 'GQ',
  Gr = 'GR',
  Gs = 'GS',
  Gt = 'GT',
  Gu = 'GU',
  Gw = 'GW',
  Gy = 'GY',
  Hk = 'HK',
  Hm = 'HM',
  Hn = 'HN',
  Hr = 'HR',
  Ht = 'HT',
  Hu = 'HU',
  Id = 'ID',
  Ie = 'IE',
  Il = 'IL',
  Im = 'IM',
  In = 'IN',
  Io = 'IO',
  Iq = 'IQ',
  Ir = 'IR',
  Is = 'IS',
  It = 'IT',
  Je = 'JE',
  Jm = 'JM',
  Jo = 'JO',
  Jp = 'JP',
  Ke = 'KE',
  Kg = 'KG',
  Kh = 'KH',
  Ki = 'KI',
  Km = 'KM',
  Kn = 'KN',
  Kp = 'KP',
  Kr = 'KR',
  Kw = 'KW',
  Ky = 'KY',
  Kz = 'KZ',
  La = 'LA',
  Lb = 'LB',
  Lc = 'LC',
  Li = 'LI',
  Lk = 'LK',
  Lr = 'LR',
  Ls = 'LS',
  Lt = 'LT',
  Lu = 'LU',
  Lv = 'LV',
  Ly = 'LY',
  Ma = 'MA',
  Mc = 'MC',
  Md = 'MD',
  Me = 'ME',
  Mf = 'MF',
  Mg = 'MG',
  Mh = 'MH',
  Mk = 'MK',
  Ml = 'ML',
  Mm = 'MM',
  Mn = 'MN',
  Mo = 'MO',
  Mp = 'MP',
  Mq = 'MQ',
  Mr = 'MR',
  Ms = 'MS',
  Mt = 'MT',
  Mu = 'MU',
  Mv = 'MV',
  Mw = 'MW',
  Mx = 'MX',
  My = 'MY',
  Mz = 'MZ',
  Na = 'NA',
  Nc = 'NC',
  Ne = 'NE',
  Nf = 'NF',
  Ng = 'NG',
  Ni = 'NI',
  Nl = 'NL',
  No = 'NO',
  NonUs = 'NON_US',
  Np = 'NP',
  Nr = 'NR',
  Nu = 'NU',
  Nz = 'NZ',
  Om = 'OM',
  Pa = 'PA',
  Pe = 'PE',
  Pf = 'PF',
  Pg = 'PG',
  Ph = 'PH',
  Pk = 'PK',
  Pl = 'PL',
  Pm = 'PM',
  Pn = 'PN',
  Pr = 'PR',
  Ps = 'PS',
  Pt = 'PT',
  Pw = 'PW',
  Py = 'PY',
  Qa = 'QA',
  Re = 'RE',
  Ro = 'RO',
  Rs = 'RS',
  Ru = 'RU',
  Rw = 'RW',
  Sa = 'SA',
  Sb = 'SB',
  Sc = 'SC',
  Sd = 'SD',
  Se = 'SE',
  Sg = 'SG',
  Sh = 'SH',
  Si = 'SI',
  Sj = 'SJ',
  Sk = 'SK',
  Sl = 'SL',
  Sm = 'SM',
  Sn = 'SN',
  So = 'SO',
  Sr = 'SR',
  Ss = 'SS',
  St = 'ST',
  Sv = 'SV',
  Sx = 'SX',
  Sy = 'SY',
  Sz = 'SZ',
  Tc = 'TC',
  Td = 'TD',
  Tf = 'TF',
  Tg = 'TG',
  Th = 'TH',
  Tj = 'TJ',
  Tk = 'TK',
  Tl = 'TL',
  Tm = 'TM',
  Tn = 'TN',
  To = 'TO',
  Tr = 'TR',
  Tt = 'TT',
  Tv = 'TV',
  Tw = 'TW',
  Tz = 'TZ',
  Ua = 'UA',
  Ug = 'UG',
  Um = 'UM',
  Us = 'US',
  Uy = 'UY',
  Uz = 'UZ',
  Va = 'VA',
  Vc = 'VC',
  Ve = 'VE',
  Vg = 'VG',
  Vi = 'VI',
  Vn = 'VN',
  Vu = 'VU',
  Wf = 'WF',
  Ws = 'WS',
  Ye = 'YE',
  Yt = 'YT',
  Za = 'ZA',
  Zm = 'ZM',
  Zw = 'ZW'
}

export type CountryAttributeMetadata = {
  __typename?: 'CountryAttributeMetadata';
  /** The maximum number of values a customer can have for a country-related attribute. A null value means no limit */
  limit?: Maybe<Scalars['Int']['output']>;
  /** All valid countries */
  validValues: Array<Maybe<LocalizedDisplayableCountry>>;
};

export type CountryOfOrigin = {
  __typename?: 'CountryOfOrigin';
  /** Country of origin as displayable property */
  displayableProperty: DisplayableTitleCountryOfOriginProperty;
  /** The country code - either an ISO 3166 code or an internally defined code if no ISO code exists for that country. */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** Display text for the country (e.g. 'United States'). */
  text: Scalars['String']['output'];
};

/** Crazy credit details */
export type CrazyCredit = {
  __typename?: 'CrazyCredit';
  /** Crazy credit as a displayable article */
  displayableArticle: DisplayableArticle;
  /** Crazy credit ID */
  id: Scalars['ID']['output'];
  /** Votes from users about whether this crazy credit item is interesting. */
  interestScore: InterestScore;
  /** The crazy credit text */
  text: Markdown;
};

/** Pagination for crazy credit types which always has a known total number of edges. */
export type CrazyCreditConnection = {
  __typename?: 'CrazyCreditConnection';
  /** Pages of crazy credits */
  edges: Array<Maybe<CrazyCreditEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of crazy credits */
export type CrazyCreditEdge = {
  __typename?: 'CrazyCreditEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A crazy credit node */
  node: CrazyCredit;
  /** Position of the node in this context, eg: CrazyCredit 4 out of 46 */
  position: Scalars['Int']['output'];
};

/**
 * Example: if you want to match titles of crazy credit 'Ian Underwood' OR 'Ian Underworld', PLUS
 * the title must contain 'incorrectly', specify anyCrazyCreditTextTerms: ['Ian Underwood', 'Ian Underworld'] plus
 * allCrazyCreditTextTerms: ['incorrectly']. Note that this is term match rather than
 * phrase match, e.g., 'Ian Underwood' would match titles that contain 'Underwood, Ian'
 */
export type CrazyCreditMatchingSearchConstraint = {
  /** A title match must contain ALL of these search terms in at least one of its crazy credits. */
  allCrazyCreditTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these search terms in at least one of its crazy credits. */
  anyCrazyCreditTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type CreateAccountRedirectUrlInput = {
  /** Association handle of the login context for IMDb account creation i.e. imdb_us */
  associationHandle: Scalars['String']['input'];
  /** Optional URL to return to post account creation, defaults to home page if omitted */
  returnURL?: InputMaybe<Scalars['URL']['input']>;
  /** Optional prefilled email for use on Pro when signing in with an Amazon account email that matches an IMDb account email */
  signInPrefilledEmail?: InputMaybe<Scalars['String']['input']>;
};

export type CreateAccountRedirectUrlOutput = {
  __typename?: 'CreateAccountRedirectURLOutput';
  /** Redirect URL for user account creation */
  redirectURL: Scalars['URL']['output'];
};

export type CreativeSize = {
  __typename?: 'CreativeSize';
  /** The height of the creative in pixels */
  height: Scalars['Int']['output'];
  /** The width of the creative in pixels */
  width: Scalars['Int']['output'];
};

/**
 * Credit details. Open question: do we want to add a persistent ID for credits?
 * Without this we require a nameID, titleID and Category to uniquely identify it.
 */
export type Credit = {
  /**
   * Category (e.g. 'Producer').
   * Open question: the name of this field comes from TitleCreditsBaseV5. Should we change it?
   */
  category: CreditCategory;
  /** The person credited */
  name: Name;
  /** The title on which this credit appears */
  title: Title;
};

export type CreditAggregation = {
  /**
   * Defines how credits are aggregated together into a single CreditV2 result.
   *
   * Aggregation allows clients to choose the level of detail to show for credits, avoiding repetition of the same
   * named individual across many roles or appearances.
   *
   * Parameter is modelled as a string to allow for altering the list of allowed values over time. Supported values are:
   *
   * NAME: All credits for a single name on a single title are aggregated together.
   * This supports experiences like Filmmakers tab on pro.imdb.com, where all work by a name within a category is
   * shown together.
   * For example, see Hugh Wilson in https://pro.imdb.com/title/tt0116130/filmmakers.
   *
   * NAME_WITHOUT_ORDERABLE_GROUPS: All credits for a single name on a single title are aggregated together,
   * except for groupings that support hierarchies (for example the Writer grouping). For these, aggregation is disabled.
   * This allows for the hierarchy of writer credits to be vended, capturing a single writer's individual contributions
   * to a title in the correct order.
   * For example, see Hugh Wilson in https://www.imdb.com/title/tt0116130/fullcredits/#writer.
   */
  aggregationType?: InputMaybe<Scalars['String']['input']>;
};

export type CreditAttribute = {
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type CreditCategory = {
  __typename?: 'CreditCategory';
  /**
   * Unique ID for this category within IMDb's catalog systems.
   * Allows lookup of category metadata for later display, for example for localising credits fetched previously
   * and stored offline.
   * This ID is stable across languages, unlike the `id` field.
   */
  categoryId?: Maybe<Scalars['String']['output']>;
  /** A list of the most relevant credited roles for this name credit category e.g 'lighting rigger' */
  featuredCreditedRoles?: Maybe<Array<Maybe<DisplayableFeaturedCreditedRole>>>;
  /**
   * Opaque ID, suitable for caching this concept.
   * As an ID of a LocalizedDisplayableConcept, the ID must change based on the language of the returned content.
   * This is to ensure that caches can distinguish between different languages of the same content.
   */
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  /** Displayable text for this category. */
  text: Scalars['String']['output'];
  /**
   * The set of traits associated with this name credit category.
   * Supported values are: 'CAST_TRAIT', 'CREW_TRAIT', 'ADDITIONAL_APPEARANCES_TRAIT'.
   * For details see CreditCategoryTrait type.
   */
  traits?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};


export type CreditCategoryFeaturedCreditedRolesArgs = {
  limit: Scalars['Int']['input'];
};

/** Arg for the variant of the credit category display label */
export enum CreditCategoryDisplayVariant {
  Plural = 'PLURAL',
  Single = 'SINGLE',
  TitleHeading = 'TITLE_HEADING'
}

export type CreditCategorySummary = {
  __typename?: 'CreditCategorySummary';
  /** The credit category */
  category: CreditCategory;
  /** The total number of credits for the category */
  total: Scalars['Int']['output'];
};

/**
 * Enumeration of credit category traits that are allow-listed for use in credit field filters.
 *
 * Note that response types will vend traits as strings, not CreditCategoryTrait values. This is to avoid risk of
 * breaking clients when new values are added to the enum.
 */
export enum CreditCategoryTrait {
  /**
   * Identifies categories where the person appears as themselves in a on-screen
   * capacity. Specifically, their Self role is not captured in a more specific
   * category like Host or Judge.
   */
  AdditionalAppearancesTrait = 'ADDITIONAL_APPEARANCES_TRAIT',
  /** Identifies categories that make up the 'Cast' of a title */
  CastTrait = 'CAST_TRAIT',
  /** Identifies categories that make up the 'Crew' of a title */
  CrewTrait = 'CREW_TRAIT',
  /**
   * Identifies categories for crew typically responsible for the creative shape of
   * a feature movie. Not exhaustive, intended as a summary of credits only.
   */
  MajorCreativeInputTrait = 'MAJOR_CREATIVE_INPUT_TRAIT',
  /** Identifies categories where the name is in a 'Self' role on the title */
  SelfTrait = 'SELF_TRAIT',
  /** Identifies categories where the name is in a 'Thanks' role on the title */
  ThanksTrait = 'THANKS_TRAIT',
  /**
   * Identifies categories that are a catch-all of credits that do not belong in
   * the taxonomy of other categories. Allows clients to put less emphasis on the
   * category as a signifier of the work done by a name on a title.
   */
  UncategorizedTrait = 'UNCATEGORIZED_TRAIT',
  /**
   * Identifies categories that are still in testing phase and should be hidden
   * from public-facing interfaces such as search filters, dropdowns, and selection
   * controls. The presence of this trait indicates the category exists in the
   * system but is not yet ready for general availability in user experiences.
   */
  UndergoingTestingTrait = 'UNDERGOING_TESTING_TRAIT'
}

/** Pagination for Credit type on a Title. */
export type CreditConnection = {
  __typename?: 'CreditConnection';
  /** Indicates whether the requested filmography data accurately reflects the onscreen cast or crew credits */
  completenessStatus?: Maybe<CreditsCompletenessStatus>;
  /** Pages of credits */
  edges: Array<Maybe<CreditEdge>>;
  /** How the credits are ordered */
  orderBy?: Maybe<CreditsOrderedBy>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<CreditRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};


/** Pagination for Credit type on a Title. */
export type CreditConnectionCompletenessStatusArgs = {
  filter?: InputMaybe<CreditsCompletenessStatusFilter>;
};

/** Page of credits */
export type CreditEdge = {
  __typename?: 'CreditEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Credit node */
  node: Credit;
  /** Position of the node in this context, eg: Credit 4 out of 31 */
  position: Scalars['Int']['output'];
};

/**
 * Credits are assigned to exactly one category, but may be displayed in different
 * groupings to better represent talent contributions. These groupings provide
 * flexible presentation of credits that may differ from their strict categorical
 * classification.
 */
export type CreditGrouping = {
  __typename?: 'CreditGrouping';
  /**
   * ID for this credit grouping.
   * Stable identifier that remains constant across localizations, used for filtering and pagination.
   */
  groupingId: Scalars['String']['output'];
  /** Opaque ID, suitable for caching this concept. */
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

/** Pagination for NameCreditGrouping type */
export type CreditGroupingConnection = {
  __typename?: 'CreditGroupingConnection';
  /** Pages of NameCreditGroupings */
  edges: Array<Maybe<CreditGroupingEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<CreditRestriction>;
  /** Total number of groupings in the entire set */
  total: Scalars['Int']['output'];
};

/** Single entry of NameCreditGroupings pagination */
export type CreditGroupingEdge = {
  __typename?: 'CreditGroupingEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  node: CreditGroupingNode;
  /** Position of the node in this context, eg: CreditGrouping 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type CreditGroupingNode = {
  __typename?: 'CreditGroupingNode';
  credits?: Maybe<CreditV2Connection>;
  grouping: CreditGrouping;
  /**
   * Captures details of the hierarchy of credits, for credit groups that support a hierarchy.
   * Only populated in title-sourced responses such as title.creditsV2.
   */
  hierarchy?: Maybe<CreditHierarchy>;
};


export type CreditGroupingNodeCreditsArgs = {
  first: Scalars['Int']['input'];
};


export type CreditGroupingNodeGroupingArgs = {
  filter?: InputMaybe<GroupingTextInput>;
};

export type CreditGroupingSort = {
  /**
   * Capture the order of CreditGrouping items in a listing.
   *
   * This is modelled as a string to allow for altering the list of allowed values over time. Supported values are:
   *
   * CREDIT_GROUPING_IMPORTANCE: Credit grouping ordering follows this priority sequence:
   * 1. Profession - The credit categories associated with the name's professions, in profession order
   * 2. Fixed grouping order for additional and passive appearances - Credit
   * groupings that capture when a name is appearing as Self,
   *    or where they were not actively involved in the title (such as Thanks or
   * Archive credits) are moved to the end of the ordering
   * 3. Credit count - The number of credits a name has within the grouping, largest first
   * 4. Fixed grouping order - A fixed order, presenting groupings in an order similar to that seen on movie or TV
   *    end credits.
   *
   * CREDIT_GROUPING_IMPORTANCE is the default.
   */
  by?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<SortOrder>;
};

/**
 * Captures details of the hierarchy of credits, for credit groups that support a hierarchy.
 * Two examples where this exists today:
 * * Writer (https://help.imdb.com/article/contribution/filmography-credits/writers/GPLAT3NTCGA67A6R#)
 *   * This category supports a three-level hierarchy. The levels are named
 * "WriterFamily", "WriterTeam", and "WriterTeamMember".
 *   * Documentation below shows examples of this hierarchy
 * * Cast (https://help.imdb.com/article/contribution/filmography-credits/how-are-cast-credits-ordered-why-don-t-the-main-stars-appear-at-the-top-of-the-cast/G39K5N4YYV2QJ4GR)
 *   * These credits are vended as a collection of ordered credits, followed by a collection of unordered credits.
 *     Our hierarchy here is therefore one level deep, with up to two expected levelKeys at that level.
 *   * Concretely we would see a hierarchy of the form:
 *
 *     [Root]
 *       /\\
 *      /  \\
 *     A    B        # CastGrouping
 *    /|    /|\\
 *   / |   / | \\
 *  C  D  E  F  G    # CastMember
 *
 *  * In this example, C and D would be cast members with an order number associated with them. E, F, G would have no
 *    associated order, and so are in the second CastGrouping.
 */
export type CreditHierarchy = {
  __typename?: 'CreditHierarchy';
  /**
   * For each non-leaf node in our hierarchy, provide a count for the number of child nodes.
   * Allows a client to look at an individual credit record and understand its relative position in the hierarchy,
   * without knowledge of the hierarchy itself.
   * For example, given the following hierarchy:
   *
   * [Root]
   * |
   * A
   * | \\
   * B  C
   * |  | \\
   * D  E  F
   *
   * If a client is rendering the credit F, they can determine that F is the last credit within the C subtree,
   * because:
   * * This group of credits is vended with `hierarchy` containing:
   *   `{ "levels": ["WriterFamily", "WriterTeam", "WriterTeamMember"],
   *      "levelDetails": [
   *        { "levelsKey": "WriterFamily[0].WriterTeam[0]", childCount: 1 }
   * ,
   *        { "levelsKey": "WriterFamily[0].WriterTeam[1]", childCount: 2 }
   * ,
   *      ]
   *    }
   * `
   * * F is vended with `hierarchyDetail` of
   *   `[ { "level": "WriterFamily", "position": 0 }
   * , { "level": "WriterTeam",
   *   "position": 1 }
   * , { "level": "WriterTeamMember", "position": 1 }
   *  ]`
   * * A client can see that within "WriterFamily[0].WriterTeam[1]", F's WriterTeamMember-level position (2) matches the
   *   total childCount for that node in the `hierarchy` data.
   */
  levelDetails?: Maybe<Array<Maybe<CreditHierarchyLevelDetail>>>;
  /**
   * Ordered list of levels. Allows a client to understand the content of `levelDetails`,
   * and the `hierarchyDetails` against a grouped credit edge (see CreditGroupingEdge).
   * For the Writer group this would return `["WriterFamily", "WriterTeam", "WriterTeamMember"]`.
   */
  levels: Array<Maybe<Scalars['String']['output']>>;
};

/**
 * Captures an individual CreditV2's position within a credit group's hierarchy.
 * This type captures the position within a single level of the hierarchy.
 * An array of these can identify a credit's unique position within a multi-level hierarchy.
 * Values are zero-indexed.
 * For example, for the Writer credit group (with levels "WriterFamily", "WriterTeam", "WriterTeamMember"),
 * and hierarchy of shape:
 *
 *       [Root]
 *       |
 *       A          # WriterFamily
 *      / \\
 *     /   \\
 *    B     C       # WriterTeam
 *   /|    /|\\
 *  / |   / | \\
 * D  E  F  G  H    # WriterTeamMember
 *
 * Node "F" would have values:
 * `[
 *    { "level": "WriterFamily", "position": 0 }
 * ,
 *    { "level": "WriterTeam", "position": 1 }
 * ,
 *    { "level": "WriterTeamMember", "position": 0 }
 *
 *  ]`
 */
export type CreditHierarchyDetail = {
  __typename?: 'CreditHierarchyDetail';
  /** Name of the level of hierarchy we are giving a position for. */
  level: Scalars['String']['output'];
  /**
   * This credit's relative position within this level of the hierarchy.
   * Values are zero-indexed.
   * Considers sibling nodes under the same parent, and not other nodes from the same level but
   * with different parents.
   */
  position: Scalars['Int']['output'];
};

export type CreditHierarchyLevelDetail = {
  __typename?: 'CreditHierarchyLevelDetail';
  /**
   * Count of the number of children beneath this node in the hierarchy.
   * Does not count children of children.
   * In the example above, the childCount for node "C" is 2 (counting nodes "E" and "F").
   */
  childCount: Scalars['Int']['output'];
  /**
   * Unique ID for this displayable text.
   * ID will encode the titleId for this title as well as `levelsKey`, as each
   * title can have different headers for their hierarchies.
   * Required as part of LocalizedDisplayableConcept interface to support caching.
   */
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  /**
   * Identifies a single node in a hierarchy, in xpath-like syntax
   * For the three-level Writer hierarchy, a levelsKey value would be "WriterFamily[0].WriterTeam[1]".
   * This corresponds to node "C" in the following hierarchy:
   *
   * [Root]
   * |
   * A
   * | \\
   * B  C
   * |  | \\
   * D  E  F
   *
   * We only represent nodes with children with a CreditHierarchyLevelDetail. Leaf nodes would not be
   * expected to have a value, since their childCount is always zero.
   * Null values are possible, for credit groups that have no inherent hierarchy but do have text to associate with
   * the credits. For example in Writers grouping, a series of hierarchical credits can be followed by unordered credits.
   * These are vended with no levelsKey but with other fields like text populated.
   */
  levelsKey?: Maybe<Scalars['String']['output']>;
  /**
   * Descriptive text for this level of the hierarchy.
   * For Cast, we could expect en-US text of the form "(in credits order) verified as complete" and
   * "Rest of cast listed alphabetically". Some levels will have no text to show, in which case we vend an
   * empty text, not null.
   */
  text: Markdown;
};

/**
 * Filters that apply to credits at the contributed credit level.
 * Each specified filter is AND-ed together.
 * For filters that accept a list of values, the filter is an OR across that list, so any
 * credit matching one value meets the filter's criteria.
 */
export type CreditLevelCreditsFilterSet = {
  /**
   * Filter for credits with attributes of "(archive footage)" or "(archive sound)".
   * By default, all credits are included, including those marked as "(archive footage)" or "(archive sound)".
   */
  archived?: InputMaybe<ArchivedOrUnarchivedFilter>;
  /**
   * Filter for credited or uncredited credits only.
   * By default, all credits are included, including those marked as "(uncredited)".
   */
  credited?: InputMaybe<CreditedOrUncreditedFilter>;
  /**
   * Filter for credits with specified role only.
   * Clients would typically fetch the credited role first from name.creditsV2.creditedRolesConnection then use the role text
   * to filter credits in subsequent calls.
   * By default, all credits are included.
   */
  creditedRole?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filter out specific credit groupings. Individual grouping IDs are found in name.creditGroupings responses.
   * Clients would often make a call to name.creditGroupings, retrieve an initial page of credits per grouping, then
   * fetch additional pages using this API.
   * Cannot be used in conjunction with "groupings": a contributed credit can only have one of these values;
   * if you specify values to include and exclude, the behaviour for unspecified values is ambiguous.
   * By default, credits for all groupings are included.
   */
  excludeGroupings?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Drop credits that have at least one of the given traits on their credit category.
   * By default, credits are not filtered by trait.
   */
  excludeTraits?: InputMaybe<Array<InputMaybe<CreditCategoryTrait>>>;
  /**
   * Filter for specific credit groupings. Individual grouping IDs are found in name.creditGroupings responses.
   * Clients would often make a call to name.creditGroupings, retrieve an initial page of credits per grouping, then
   * fetch additional pages using this API.
   * Cannot be used in conjunction with "excludeGroupings": a contributed credit can only have one of these values;
   * if you specify values to include and exclude, the behaviour for unspecified values is ambiguous.
   * By default, credits for all groupings are included.
   */
  groupings?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Keep credits that have at least one of the given traits on their credit category.
   * By default, credits are not filtered by trait.
   */
  includeTraits?: InputMaybe<Array<InputMaybe<CreditCategoryTrait>>>;
  /**
   * Filter the returned groupings based on their relationship to the name's listed professions.
   * By default, credits are not filtered by professions.
   */
  professions?: InputMaybe<ProfessionsFilter>;
};

/** Information about restrictions applied to Credits */
export type CreditRestriction = {
  __typename?: 'CreditRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

/**
 * Details of a credit for a name on a title. Distinct from Company Credits or Crazy Credits.
 * Successor to Credit type.
 * Denotes the role(s) a person had on a title.
 * Fields within this record may be aggregations or summaries of work done, depending on how the data was requested.
 *
 * When requesting credits for a series, roles performed on the episodes of that series are rolled up to the series level.
 * Each rolled-up role comes with its own listing of the episodes that the role was performed on.
 * If the attributes of a role are not shared across all episodes, we drop that detail.
 * * Example: Kaley Cuoco (nm0192505) was credited as Kaley Cuoco-Sweeting for some but not all episodes of
 * The Big Bang Theory (tt0898266). When viewing credits at the series level, this attribute is dropped. The attribute
 * is still present at an episode level.
 *
 * Characters and CreditedRoles for a series are ordered by most recent value first. This ensures a person's most recent
 * contribution to a title (and so the work they are most likely to demonstrate their skillset) is shown first.
 * This also helps to highlight the roles that users are likely to be exploring, particularly for long-running shows
 * where acting roles change over time (for example, Saturday Night Live).
 * Note that the ordering of these fields differs when using name.knownForV2 (see its documentation for details).
 *
 * Appearance credits (such as acting and self-appearances) are contributed to IMDb's catalog as a single credit per title.
 * * Example: Ryan Reynolds (nm0005351) plays Deadpool and Nicepool in Deadpool & Wolverine (tt6263850).
 * This is different to crew credits, where a single person can have many roles on a title, even within a single
 * credit category.
 * * Example: Hugh Wilson (nm0933505) is both screenplay and story writer for Down Periscope (tt0116130), and these are
 * captured in the catalog as separate credits.
 *
 * The CreditV2 shape maintains this distinction. For appearance credits, the individual roles played can be accessed
 * individually from the `CreditV2.creditedRoles.characters` field.
 *
 * When a person performs different appearance roles across episodes in a TV series, we maintain this cast-specific
 * difference in data shape. All appearance work is aggregated into a single CreditV2 entry, with a single
 * `creditedRoles.text` value that includes up to 100 roles, and all roles available in the `characters` field.
 * * Example: Kaley Cuoco (nm0192505) plays two different roles across episodes in The Big Bang Theory (tt0898266).
 * This is vended at the series level as a single credit with one `creditedRoles.text` ("Penny/Penny Hofstatder") and
 * two character values (["Penny", "Penny Hofstatder"]).
 * Character names are ordered by their frequency across episodes, then by which occurs first in release order.
 */
export type CreditV2 = {
  __typename?: 'CreditV2';
  /**
   * List of credited roles and related details.
   * Only supports fetching an initial page of credits. To continue pagination, use name.creditedRoles  (yet to be built).
   */
  creditedRoles?: Maybe<CreditedRoleConnection>;
  /**
   * Details of per-episode credits for when the parent credit is a series.
   * Only supports fetching an initial page of credits. To continue pagination, use name.episodeCredits (yet to be built).
   */
  episodeCredits?: Maybe<EpisodeCreditConnection>;
  /**
   * Details of this credit position in its group's hierarchy, if any.
   * Is only present when fetching credit data from a title source.
   * See CreditHierarchyDetail for details.
   */
  hierarchyDetails?: Maybe<Array<Maybe<CreditHierarchyDetail>>>;
  /** Opaque ID, suitable for caching this concept. */
  id: Scalars['ID']['output'];
  /** The person credited */
  name: Name;
  /** The title on which this credit appears */
  title: Title;
};


/**
 * Details of a credit for a name on a title. Distinct from Company Credits or Crazy Credits.
 * Successor to Credit type.
 * Denotes the role(s) a person had on a title.
 * Fields within this record may be aggregations or summaries of work done, depending on how the data was requested.
 *
 * When requesting credits for a series, roles performed on the episodes of that series are rolled up to the series level.
 * Each rolled-up role comes with its own listing of the episodes that the role was performed on.
 * If the attributes of a role are not shared across all episodes, we drop that detail.
 * * Example: Kaley Cuoco (nm0192505) was credited as Kaley Cuoco-Sweeting for some but not all episodes of
 * The Big Bang Theory (tt0898266). When viewing credits at the series level, this attribute is dropped. The attribute
 * is still present at an episode level.
 *
 * Characters and CreditedRoles for a series are ordered by most recent value first. This ensures a person's most recent
 * contribution to a title (and so the work they are most likely to demonstrate their skillset) is shown first.
 * This also helps to highlight the roles that users are likely to be exploring, particularly for long-running shows
 * where acting roles change over time (for example, Saturday Night Live).
 * Note that the ordering of these fields differs when using name.knownForV2 (see its documentation for details).
 *
 * Appearance credits (such as acting and self-appearances) are contributed to IMDb's catalog as a single credit per title.
 * * Example: Ryan Reynolds (nm0005351) plays Deadpool and Nicepool in Deadpool & Wolverine (tt6263850).
 * This is different to crew credits, where a single person can have many roles on a title, even within a single
 * credit category.
 * * Example: Hugh Wilson (nm0933505) is both screenplay and story writer for Down Periscope (tt0116130), and these are
 * captured in the catalog as separate credits.
 *
 * The CreditV2 shape maintains this distinction. For appearance credits, the individual roles played can be accessed
 * individually from the `CreditV2.creditedRoles.characters` field.
 *
 * When a person performs different appearance roles across episodes in a TV series, we maintain this cast-specific
 * difference in data shape. All appearance work is aggregated into a single CreditV2 entry, with a single
 * `creditedRoles.text` value that includes up to 100 roles, and all roles available in the `characters` field.
 * * Example: Kaley Cuoco (nm0192505) plays two different roles across episodes in The Big Bang Theory (tt0898266).
 * This is vended at the series level as a single credit with one `creditedRoles.text` ("Penny/Penny Hofstatder") and
 * two character values (["Penny", "Penny Hofstatder"]).
 * Character names are ordered by their frequency across episodes, then by which occurs first in release order.
 */
export type CreditV2CreditedRolesArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Details of a credit for a name on a title. Distinct from Company Credits or Crazy Credits.
 * Successor to Credit type.
 * Denotes the role(s) a person had on a title.
 * Fields within this record may be aggregations or summaries of work done, depending on how the data was requested.
 *
 * When requesting credits for a series, roles performed on the episodes of that series are rolled up to the series level.
 * Each rolled-up role comes with its own listing of the episodes that the role was performed on.
 * If the attributes of a role are not shared across all episodes, we drop that detail.
 * * Example: Kaley Cuoco (nm0192505) was credited as Kaley Cuoco-Sweeting for some but not all episodes of
 * The Big Bang Theory (tt0898266). When viewing credits at the series level, this attribute is dropped. The attribute
 * is still present at an episode level.
 *
 * Characters and CreditedRoles for a series are ordered by most recent value first. This ensures a person's most recent
 * contribution to a title (and so the work they are most likely to demonstrate their skillset) is shown first.
 * This also helps to highlight the roles that users are likely to be exploring, particularly for long-running shows
 * where acting roles change over time (for example, Saturday Night Live).
 * Note that the ordering of these fields differs when using name.knownForV2 (see its documentation for details).
 *
 * Appearance credits (such as acting and self-appearances) are contributed to IMDb's catalog as a single credit per title.
 * * Example: Ryan Reynolds (nm0005351) plays Deadpool and Nicepool in Deadpool & Wolverine (tt6263850).
 * This is different to crew credits, where a single person can have many roles on a title, even within a single
 * credit category.
 * * Example: Hugh Wilson (nm0933505) is both screenplay and story writer for Down Periscope (tt0116130), and these are
 * captured in the catalog as separate credits.
 *
 * The CreditV2 shape maintains this distinction. For appearance credits, the individual roles played can be accessed
 * individually from the `CreditV2.creditedRoles.characters` field.
 *
 * When a person performs different appearance roles across episodes in a TV series, we maintain this cast-specific
 * difference in data shape. All appearance work is aggregated into a single CreditV2 entry, with a single
 * `creditedRoles.text` value that includes up to 100 roles, and all roles available in the `characters` field.
 * * Example: Kaley Cuoco (nm0192505) plays two different roles across episodes in The Big Bang Theory (tt0898266).
 * This is vended at the series level as a single credit with one `creditedRoles.text` ("Penny/Penny Hofstatder") and
 * two character values (["Penny", "Penny Hofstatder"]).
 * Character names are ordered by their frequency across episodes, then by which occurs first in release order.
 */
export type CreditV2EpisodeCreditsArgs = {
  filter?: InputMaybe<EpisodeCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<EpisodeCreditsSort>;
};

/** Pagination for CreditV2 type */
export type CreditV2Connection = {
  __typename?: 'CreditV2Connection';
  /** Pages of credits */
  edges: Array<Maybe<CreditV2Edge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<CreditRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of credits */
export type CreditV2Edge = {
  __typename?: 'CreditV2Edge';
  cursor: Scalars['ID']['output'];
  /** A Credit node */
  node: CreditV2;
  /** Position of the node in this context, eg: CreditV2 4 out of 31. 1-indexed values */
  position: Scalars['Int']['output'];
};

export type CreditedAsCreditAttribute = CreditAttribute & {
  __typename?: 'CreditedAsCreditAttribute';
  creditedAs: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

/**
 * Example: if you want to match titles with companyIds ('co0764707' OR 'co0854530') PLUS 'co0005073' PLUS NOT 'co0921192',
 * specify anyCompanyIds: ['co0764707', 'co0854530'] plus allCompanyIds: ['co0005073'] plus excludeCompanyIds: ['co0921192']
 */
export type CreditedCompanySearchConstraint = {
  /** A title match must contain ALL of these companies */
  allCompanyIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Used alongside the `anyCompanyIds` and/or `allCompanyIds` fields to match titles that have company credits for
   * the companyId(s) AND those credits are for ONE OF the categories specified.
   *
   * This has no effect on `excludeCompanyIds`. Throws `GRAPHQL_VALIDATION_FAILED` if the field is used without
   * passing in any companyIds (`anyCompanyIds` and/or `allCompanyIds`).
   *
   * Example: To match titles where co0005073 is the production company, you would specify allCompanyIds: ['co0005073']
   * plus anyCompanyCategories: ['production']
   */
  anyCompanyCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** A title match must contain AT LEAST ONE of these companies */
  anyCompanyIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * A title match must contain NONE of these companies
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeCompanyIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/**
 * Example: if you want to match titles with nameIds ('nm0634240' OR 'nm5397459') AND 'nm1139258' AND NOT 'nm0331516',
 * specify anyNameIds: ['nm0634240', 'nm5397459'], allNameIds: ['nm1139258'], and excludeNameIds: [nm0331516']
 */
export type CreditedNameConstraint = {
  /** A title match must contain ALL of these names */
  allNameIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** A title match must contain AT LEAST ONE of these names */
  anyNameIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * A title match must contain NONE of these names
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeNameIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Filter of Credited or Uncredited credits */
export enum CreditedOrUncreditedFilter {
  AllCredits = 'ALL_CREDITS',
  CreditedOnly = 'CREDITED_ONLY',
  UncreditedOnly = 'UNCREDITED_ONLY'
}

export type CreditedRole = {
  __typename?: 'CreditedRole';
  /**
   * List of attributes related to this credited role.
   * Attributes are ordered based on a fixed ordering of attribute type. We prioritise contextual information
   * (like what segments of a title the role relates to and whether the person only appears in archive footage) over
   * credit accuracy markers (like whether the person is uncredited, rumored, or does not appear onscreen while still
   * receiving a credit).
   */
  attributes?: Maybe<Array<Maybe<CreditAttribute>>>;
  /**
   * The category this role belongs to.
   * When retrieving credits in the context of a name (such as name.knownForV2 field), the text's natural gender
   * is chosen to match the gender of the person, if known.
   * category.categoryId is always populated when accessed within this context.
   */
  category: CreditCategory;
  /**
   * For appearance credits, a breakdown of multiple characters into individual strings. This field will be populated
   * with at least one value for all appearance credits, even where the credited role for that credit is blank (in
   * which case we vend the category text as the role).
   * For crew credits, this field will always be null.
   * Allows clients to display a subset of characters.
   * Only supports fetching an initial page of credits. To continue pagination, use name.characters (yet to be built).
   */
  characters?: Maybe<CharacterConnection>;
  /**
   * Details of per-episode credits for when the parent credit is a series.
   * Only supports fetching an initial page of credits. To continue pagination, use name.episodeCredits (yet to be built).
   */
  episodeCredits?: Maybe<EpisodeCreditConnection>;
  /** Opaque ID, suitable for caching this concept. */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language?: Maybe<DisplayableLanguage>;
  /**
   * Role this person performed on this title. Optional, as some roles are implicit or duplicate the category of the credit.
   * See CreditV2 for details of how aggregation of data applies to this field.
   */
  text?: Maybe<Scalars['String']['output']>;
};


export type CreditedRoleAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type CreditedRoleCharactersArgs = {
  disambiguateSelf?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type CreditedRoleEpisodeCreditsArgs = {
  filter?: InputMaybe<EpisodeCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<EpisodeCreditsSort>;
};


export type CreditedRoleTextArgs = {
  disambiguateSelf?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CreditedRoleConnection = {
  __typename?: 'CreditedRoleConnection';
  /** Pages of CreditedRole */
  edges: Array<Maybe<CreditedRoleEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of CreditedRole */
export type CreditedRoleEdge = {
  __typename?: 'CreditedRoleEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the CreditedRole */
  node: CreditedRole;
};

export type CreditedRoleSort = {
  /**
   * Captures the ordering of credited roles within a CreditV2. This ensures consistent ordering of roles
   * when a name has performed many different roles on a title. This is often seen on long-running series.
   *
   * This is modelled as a string to allow for altering the list of allowed values over time. Supported values are:
   *
   * CREDITED_ROLE_IMPORTANCE: Credit ordering follows this priority sequence:
   * 1. Profession - The credit categories associated with the name's professions, in profession order
   * 2. Latest release date - For series, most recent episode release date that this credit applies to
   * 3. Episode count - For a series, higher episode counts appear first
   * 4. Credited status - Credited roles take precedence over uncredited
   * 5. Role - Alphabetical comparison of the credited role text
   * 6. Title ID - A final tie-break by episode title ID to ensure consistent ordering (largest first)
   *
   * CREDITED_ROLE_IMPORTANCE is the default.
   */
  by?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<SortOrder>;
};

export type CreditedWithNameEdge = {
  __typename?: 'CreditedWithNameEdge';
  /** Cursor ID of the credited with name */
  cursor: Scalars['ID']['output'];
  /** A credited with name item */
  node: CreditedWithNameItem;
  /** Position of the node in this context, eg: CreditedWithNameEdge 2 out of 10 */
  position: Scalars['Int']['output'];
};

export type CreditedWithNameItem = {
  __typename?: 'CreditedWithNameItem';
  /** The credited with name */
  name: Name;
};

export type CreditedWithNamesConnection = {
  __typename?: 'CreditedWithNamesConnection';
  /** A page of credited with names */
  edges: Array<Maybe<CreditedWithNameEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of credited with names */
  total: Scalars['Int']['output'];
};

export type CreditsCompletenessStatus = {
  __typename?: 'CreditsCompletenessStatus';
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

export type CreditsCompletenessStatusFilter = {
  /** Excludes by returning null. Uses the following values: 'unknown', 'complete', 'complete_and_verified' */
  excludeValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/**
 * Captures several functional parameter choices in a single value, enabling consistent results across many callsites.
 *
 * A CreditsModePreset can provide settings for filter, sort, and other functional inputs.
 * Clients can still provide additional filters, but the preset may override or conflict with them.
 */
export enum CreditsModePreset {
  /**
   * Credits are filtered to remove mention of passive roles, such as Thanks and Archive Footage.
   * Names are typically not known for roles where they were passively involved in the title.
   */
  KnownFor = 'KNOWN_FOR',
  /**
   * Applies the filters from "KNOWN_FOR". Additionally, contributed credits are
   * aggregated to the category level. If a name has performed several different Producer roles across episodes in a
   * TV series, these would be presented as a single CreditedRole within the CreditV2 response value for that title.
   */
  KnownForWithCategoryAggregation = 'KNOWN_FOR_WITH_CATEGORY_AGGREGATION',
  /** No preset is used */
  None = 'NONE'
}

export type CreditsOrderedBy = {
  __typename?: 'CreditsOrderedBy';
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

/** Crew details */
export type Crew = Credit & {
  __typename?: 'Crew';
  attributes?: Maybe<Array<Maybe<CreditAttribute>>>;
  category: CreditCategory;
  episodeCredits?: Maybe<EpisodeCrewConnection>;
  /** List of job and related Attributes */
  jobDetails?: Maybe<Array<Maybe<CrewJobDetails>>>;
  /**
   * List of jobs (e.g. 'Executive Producer')
   * Open questions: the name of this field comes from TitleCreditsBaseV5. Should we change it?
   */
  jobs?: Maybe<Array<Maybe<CrewJob>>>;
  name: Name;
  title: Title;
};


/** Crew details */
export type CrewAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Crew details */
export type CrewEpisodeCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<EpisodeCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<EpisodeCreditsSort>;
};


/** Crew details */
export type CrewJobDetailsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Crew details */
export type CrewJobsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type CrewJob = {
  __typename?: 'CrewJob';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type CrewJobDetails = {
  __typename?: 'CrewJobDetails';
  /** List of attributes related to the Job */
  attributes?: Maybe<Array<Maybe<CreditAttribute>>>;
  /** Crew Job as a standardized displayableProperty */
  displayableProperty?: Maybe<CrewJobDisplayableProperty>;
  /** Job information */
  job: CrewJob;
  /** The language of the display text */
  language?: Maybe<DisplayableLanguage>;
};


export type CrewJobDetailsAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type CrewJobDisplayableProperty = {
  __typename?: 'CrewJobDisplayableProperty';
  /** The crew job text qualifiers in Markdown such as uncredited, voice etc. */
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  /** Displayable text for Job and attribute */
  value: Markdown;
};

/** Parameters used to define how an image should be cropped */
export type CroppingParameters = {
  __typename?: 'CroppingParameters';
  /** The height of the cropped image */
  height: Scalars['Int']['output'];
  /** The width of the cropped image */
  width: Scalars['Int']['output'];
  /** The x-coordinate by which to offset the crop box */
  xOffset: Scalars['Int']['output'];
  /** The y-coordinate by which to offset the crop box */
  yOffset: Scalars['Int']['output'];
};

/**
 * Example: if you want to match titles with production status stages
 * ('in_development' OR 'pre_production') AND NOT 'abandoned',
 * specify anyProductionStageIds: ['in_development', 'pre_production'], and excludeProductionStageIds: ['abandoned']
 */
export type CurrentProductionStatusStageConstraint = {
  /** A title match must contain AT LEAST ONE of these production status stages */
  anyProductionStageIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * A title match must contain NONE of these production status stages
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeProductionStageIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Featured images that customer selected manually */
export type CustomFeaturedImages = {
  __typename?: 'CustomFeaturedImages';
  images?: Maybe<Array<Maybe<Image>>>;
  /** True if data status is EDITED */
  isAdminEdited: Scalars['Boolean']['output'];
  isAdminNotificationSeen: Scalars['Boolean']['output'];
  /** True if data status is BLOCKED */
  isBlocked: Scalars['Boolean']['output'];
  /** True if custom selections within this type should override automatic ones */
  isPublished: Scalars['Boolean']['output'];
  /** True if data status is RESET */
  isReset: Scalars['Boolean']['output'];
  lastEdited?: Maybe<Scalars['DateTime']['output']>;
  lastEditedByAdmin?: Maybe<Scalars['DateTime']['output']>;
};

/** Known for titles that customer selected manually */
export type CustomKnownFor = {
  __typename?: 'CustomKnownFor';
  /** True if data status is EDITED */
  isAdminEdited: Scalars['Boolean']['output'];
  isAdminNotificationSeen: Scalars['Boolean']['output'];
  /** True if data status is BLOCKED */
  isBlocked: Scalars['Boolean']['output'];
  /** True if custom selections within this type should override automatic ones */
  isPublished: Scalars['Boolean']['output'];
  /** True if data status is RESET */
  isReset: Scalars['Boolean']['output'];
  lastEdited?: Maybe<Scalars['DateTime']['output']>;
  lastEditedByAdmin?: Maybe<Scalars['DateTime']['output']>;
  /** Known for titles that customer selected manually last time. Max number of titles is 4 */
  titles?: Maybe<Array<Maybe<Title>>>;
};

/** Primary image that the name owner had edited */
export type CustomPrimaryImage = {
  __typename?: 'CustomPrimaryImage';
  /** Parameters used to define the cropping on the image */
  imageEditParameters?: Maybe<ImageEditParameters>;
  /** The original image, without any cropping or rotation customizations applied */
  originalImage: Image;
};

/** A type to represent dates that cannot be represented in ISO 8601 format, e.g. missing year in 23 March. */
export type DateComponents = {
  __typename?: 'DateComponents';
  /** The day as per Gregorian calendar. */
  day?: Maybe<Scalars['Int']['output']>;
  /** If the date is approximate, e.g. circa 370 BC. */
  isApproximate: Scalars['Boolean']['output'];
  /** If the date is before Common Era as per Gregorian calendar. */
  isBCE: Scalars['Boolean']['output'];
  /** The month of the date as per Gregorian calendar. */
  month?: Maybe<Scalars['Int']['output']>;
  /**
   * The year of the date as per Gregorian calendar, can contain non-numerical
   * wildcard to signify decade or century, e.g. 1 May 197?.
   */
  partialYear?: Maybe<Scalars['String']['output']>;
  /** The year of the date as per Gregorian calendar. */
  year?: Maybe<Scalars['Int']['output']>;
};

export type DateRange = {
  end?: InputMaybe<Scalars['Date']['input']>;
  start?: InputMaybe<Scalars['Date']['input']>;
};

export type DeathDateSearchConstraint = {
  deathDateRange: DateRange;
};

/**
 * Matches names based on where they died.
 * There is no fuzzy matching.
 * For example: 'Venice Italy' will be matched by 'Venice' and 'Italy' but not 'Venice Ita'
 */
export type DeathPlaceSearchConstraint = {
  deathPlace: Scalars['String']['input'];
};

export enum DeletionDialogInput {
  /** Retrieve the dialog for confirming deletion */
  Confirm = 'CONFIRM',
  /** Retrieve the dialog for requesting deletion */
  Request = 'REQUEST'
}

export type DeletionDialogOutput = {
  __typename?: 'DeletionDialogOutput';
  deletionPrompt: LocalizedMarkdown;
  /**
   * A prompt to instruct Amazon Account Pool customers to initiate the deletion process on Amazon page.
   * Null if not Amazon Account Pool customers.
   */
  redirectionPrompt?: Maybe<DeletionDialogRedirectionPrompt>;
  /**
   * For REQUEST dialogs, this will be the requestId to pass in to requestAccountDeletion
   * mutation. This is not needed for other types of dialogs.
   */
  requestId?: Maybe<Scalars['String']['output']>;
};

export type DeletionDialogRedirectionPrompt = {
  __typename?: 'DeletionDialogRedirectionPrompt';
  /** Link to the Amazon page. */
  action: RedirectLink;
  /** Text to instruct customers to initiate the deletion process on Amazon page. */
  message: LocalizedMarkdown;
};

export type Demographic = {
  __typename?: 'Demographic';
  age?: Maybe<Age>;
  country?: Maybe<Country>;
  displayText: LocalizedString;
  gender?: Maybe<Gender>;
  userCategory?: Maybe<UserCategory>;
};

/** A single component of a demographic data value */
export type DemographicDataComponent = {
  __typename?: 'DemographicDataComponent';
  /** The id of the demographic data component e.g. asian */
  id: Scalars['ID']['output'];
  /** The language of the displayable text */
  language: DisplayableLanguage;
  /** The localized displayable text of the demographic data component e.g. Asian */
  text: Scalars['String']['output'];
};

/** Common input type for filtering demographic data items */
export type DemographicDataFilter = {
  /** Types to exclude in the response items (mutually exclusive to 'includeTypes') */
  excludeTypes?: InputMaybe<Array<InputMaybe<DemographicDataTypeValue>>>;
  /** Types to include in the response items (mutually exclusive to 'excludeTypes') */
  includeTypes?: InputMaybe<Array<InputMaybe<DemographicDataTypeValue>>>;
  /** If set to true returns selfVerified items only, if set to false returns non-selfVerified items only */
  selfVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Visibility levels to include in the response items */
  visibility?: InputMaybe<VisibilityLevel>;
};

/** A single demographic data item */
export type DemographicDataItem = {
  __typename?: 'DemographicDataItem';
  /** The selfVerified status of the demographic data item */
  selfVerified: SelfVerified;
  /** The type of the demographic data item */
  type: DemographicDataType;
  /** The value of the demographic data item */
  value: DemographicDataValue;
};

/** A single demographic data type */
export type DemographicDataType = {
  __typename?: 'DemographicDataType';
  /** The id of the demographic data type e.g. gender_identity */
  id: Scalars['ID']['output'];
  /** The language of the displayable text */
  language: DisplayableLanguage;
  /** The localized displayable text of the demographic data type e.g. Gender Identity */
  text: Scalars['String']['output'];
  /** The enum value for the demographic data type */
  value: DemographicDataTypeValue;
};

/** Enum values for the valid demographic data types */
export enum DemographicDataTypeValue {
  BirthDate = 'BIRTH_DATE',
  BirthYear = 'BIRTH_YEAR',
  Citizenship = 'CITIZENSHIP',
  Disability = 'DISABILITY',
  Ethnicity = 'ETHNICITY',
  GenderIdentity = 'GENDER_IDENTITY',
  IdentifiesAsDisabled = 'IDENTIFIES_AS_DISABLED',
  IdentifiesAsTransgender = 'IDENTIFIES_AS_TRANSGENDER',
  Nationality = 'NATIONALITY',
  Pronoun = 'PRONOUN',
  SexualOrientation = 'SEXUAL_ORIENTATION'
}

/** A single demographic data value */
export type DemographicDataValue = {
  __typename?: 'DemographicDataValue';
  /** The individual components that make up the value */
  components: Array<Maybe<DemographicDataComponent>>;
  /** The id of the demographic data value e.g. male */
  id: Scalars['ID']['output'];
  /** The language of the displayable text */
  language: DisplayableLanguage;
  /** The localized displayable text of the demographic data value e.g. Male */
  text: Scalars['String']['output'];
};

export type DemographicFilter = {
  age?: InputMaybe<Age>;
  country?: InputMaybe<Country>;
  gender?: InputMaybe<Gender>;
  userCategory?: InputMaybe<UserCategory>;
};

export type DemographicRatings = {
  __typename?: 'DemographicRatings';
  aggregate?: Maybe<Scalars['Float']['output']>;
  demographic: Demographic;
  voteCount: Scalars['Int']['output'];
};

/**
 * Device info used in the display and video ads flows for apps.
 * This information is used upstream in Amazon Advertising systems for targeting and metrics.
 */
export type DeviceInfo = {
  /** Carrier of the device (eg. AT&T) */
  carrier?: InputMaybe<Scalars['String']['input']>;
  /** The make of the device the request originates from (eg. Samsung) */
  make: Scalars['String']['input'];
  /** The model of the device the request originates from (eg. Galaxy S4) */
  model: Scalars['String']['input'];
  /** The OS type of the device the request originates from (eg. iOS) */
  os: Scalars['String']['input'];
  /** The OS version of the device the request originates from (eg. 4.4.2) */
  osVersion?: InputMaybe<Scalars['String']['input']>;
  /** Scaling Factor of the phone screen (eg. 3.0) */
  scalingFactor?: InputMaybe<Scalars['String']['input']>;
};

export type DirectContactDetails = {
  __typename?: 'DirectContactDetails';
  emailAddress?: Maybe<Scalars['String']['output']>;
  faxNumber?: Maybe<LocalizedString>;
  phoneNumbers?: Maybe<Array<Maybe<LocalizedString>>>;
  website?: Maybe<WebsiteLink>;
};

export type Disambiguation = {
  __typename?: 'Disambiguation';
  number: Scalars['Int']['output'];
  text: Scalars['String']['output'];
};

/** Required and optional parameters used to make an AAX request that come from the context of the client. */
export type DisplayAdTargetingParameters = {
  /** The layout of the page being targeted, indicating the slots it supports. */
  adLayout: Scalars['String']['input'];
  /** The primary const of the page element being targeted for ads. */
  pageConst?: InputMaybe<Scalars['ID']['input']>;
  /** A list of ad slots that are eligible to be refreshed (i.e. render new ads on a set interval). */
  refreshableSlots?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The subSectionType of a special section - i.e. 'winners' is a subSectionType under 'oscars' special section. */
  subSectionType?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Required parameters used to make an AAX request that come from the context of the app client.
 * Includes app-specific parameters and general targeting parameters.
 */
export type DisplayAdsForAppInput = {
  /**
   * A set of parameters needed from app clients to target ads.
   * These parameters are used in both display and video ad flows.
   */
  adParametersApp: AdParametersApp;
  /** A set of parameters used to target display ads across all site variants. */
  displayAdTargetingParameters: DisplayAdTargetingParameters;
};

export type DisplayLabels = {
  __typename?: 'DisplayLabels';
  primaryLabel: Scalars['String']['output'];
  secondaryLabel?: Maybe<Scalars['String']['output']>;
};

/** Generic type for a display-ready article representation of the parent type */
export type DisplayableArticle = {
  __typename?: 'DisplayableArticle';
  /** An optional body for the article */
  body?: Maybe<Markdown>;
  /** An optional footer for the article */
  footer?: Maybe<Markdown>;
  /** An optional header for the article */
  header?: Maybe<Markdown>;
};

/** Generic type for a concept which has display text and an optional ID */
export type DisplayableAttribute = {
  __typename?: 'DisplayableAttribute';
  /** Type token */
  id?: Maybe<Scalars['ID']['output']>;
  /** The display text */
  text: Scalars['String']['output'];
};

export type DisplayableAwardedEntity = {
  __typename?: 'DisplayableAwardedEntity';
  value: Markdown;
};

export type DisplayableBirthNameProperty = {
  __typename?: 'DisplayableBirthNameProperty';
  value: Markdown;
};

/** Type for the display of a country */
export type DisplayableCountry = {
  __typename?: 'DisplayableCountry';
  /** The country code - either an ISO 3166 code or an internally defined code if no ISO code exists for that country. */
  id: Scalars['ID']['output'];
  /** Display text for the country (e.g. 'United States'). */
  text: Scalars['String']['output'];
};

export type DisplayableDate = {
  __typename?: 'DisplayableDate';
  /** A date in ISO 8601. */
  date?: Maybe<Scalars['Date']['output']>;
  /** Details of the individual date components, usually when ISO date is not available. */
  dateComponents?: Maybe<DateComponents>;
  /** The date as a displayable property, e.g. '23 June 1970' */
  displayableProperty: DisplayableDateProperty;
};

export type DisplayableDateProperty = {
  __typename?: 'DisplayableDateProperty';
  /** Language of the displayed value. */
  language: DisplayableLanguage;
  /** A complete, formatted date that can be displayed. */
  value: Markdown;
};

export type DisplayableDateRange = {
  __typename?: 'DisplayableDateRange';
  /** Filming end date, use displayableProperty for localized value */
  endDate?: Maybe<DisplayableDate>;
  /** Filming start date, use displayableProperty for localized value */
  startDate?: Maybe<DisplayableDate>;
};

export type DisplayableEpisodeNumber = {
  __typename?: 'DisplayableEpisodeNumber';
  /** Displayable season number/text as a standardized localizedDisplayableConcept */
  displayableSeason: LocalizedDisplayableSeason;
  /** Displayable episode number as a standardized localizedDisplayableConcept */
  episodeNumber: LocalizedDisplayableEpisodeNumber;
};

export type DisplayableExternalLinkProperty = {
  __typename?: 'DisplayableExternalLinkProperty';
  /** The external link as a markdown object */
  value: Markdown;
};

/**
 * Featured roles represents common roles associated with credit category.
 * Can be used in search scenario to suggest role values for selected credit category.
 */
export type DisplayableFeaturedCreditedRole = {
  __typename?: 'DisplayableFeaturedCreditedRole';
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** The localized text */
  text: Scalars['String']['output'];
};

export type DisplayableLanguage = {
  __typename?: 'DisplayableLanguage';
  /** The language code - either an ISO 639 code or an internally defined code if no ISO code exists for the language. */
  id: Scalars['ID']['output'];
  /** Display text for the language (e.g. 'American English'). */
  text: Scalars['String']['output'];
};

export type DisplayableLocation = {
  __typename?: 'DisplayableLocation';
  /** The location as a displayable property, e.g. 'Shawnee, Oklahoma, USA' */
  displayableProperty: DisplayableLocationProperty;
  /** Location text. */
  text?: Maybe<Scalars['String']['output']>;
};

export type DisplayableLocationProperty = {
  __typename?: 'DisplayableLocationProperty';
  /** Language of the displayed value. */
  language: DisplayableLanguage;
  /** A complete, formatted location that can be displayed. */
  value: Markdown;
};

export type DisplayableNameAgeDetailsProperty = {
  __typename?: 'DisplayableNameAgeDetailsProperty';
  /** Name's age value that can be displayed */
  value: Markdown;
};

/** Name AKA as a Displayable Property */
export type DisplayableNameAkaProperty = {
  __typename?: 'DisplayableNameAkaProperty';
  /** The displayable name aka */
  value: Markdown;
};

export type DisplayableNameDeathCause = {
  __typename?: 'DisplayableNameDeathCause';
  /** The cause of death as a displayable property, e.g. 'accidental drowning' */
  displayableProperty: DisplayableNameDeathCauseProperty;
  /** The cause of death of a person. */
  text?: Maybe<Scalars['String']['output']>;
};

export type DisplayableNameDeathCauseProperty = {
  __typename?: 'DisplayableNameDeathCauseProperty';
  /** Language of the displayed value. */
  language: DisplayableLanguage;
  /** The cause of death property that can be displayed. */
  value: Markdown;
};

export type DisplayableNameFilmBiographyProperty = {
  __typename?: 'DisplayableNameFilmBiographyProperty';
  /** The biographical title about the person. */
  value: Markdown;
};

export type DisplayableNameHeightProperty = {
  __typename?: 'DisplayableNameHeightProperty';
  language: DisplayableLanguage;
  value: Markdown;
};

export type DisplayableNameOtherWorkProperty = {
  __typename?: 'DisplayableNameOtherWorkProperty';
  /** The work qualifiers, e.g. ['2009', 'Stage'] */
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  /** The details of the work this person was involved in */
  value: Markdown;
};

export type DisplayableNamePortrayalProperty = {
  __typename?: 'DisplayableNamePortrayalProperty';
  /** The title in which the person was portrayed by an actor. */
  value: Markdown;
};

export type DisplayableNamePrintBiographyProperty = {
  __typename?: 'DisplayableNamePrintBiographyProperty';
  /** The biographical book formatted as <Author>. <Title>. <Publisher>. ISBN: <ISBN> */
  value: Markdown;
};

export type DisplayableNameSpouseProperty = {
  __typename?: 'DisplayableNameSpouseProperty';
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** A list of qualifiers including the time range, number of children, e.g. (9 July 2009 - 16 October 2018) (1 child) */
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  /** The spouse name as plain text, or as nmconst link if person is an IMDb name */
  value: Markdown;
};

export type DisplayableNickNameProperty = {
  __typename?: 'DisplayableNickNameProperty';
  value: Markdown;
};

export type DisplayableProfession = {
  __typename?: 'DisplayableProfession';
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** The localized text */
  text: Scalars['String']['output'];
};

export type DisplayableProfessionCategory = {
  __typename?: 'DisplayableProfessionCategory';
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** The localized text */
  text: Scalars['String']['output'];
};

export type DisplayableProfessionDescription = {
  __typename?: 'DisplayableProfessionDescription';
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** The localized text */
  text: Scalars['String']['output'];
};

export type DisplayablePrompt = {
  __typename?: 'DisplayablePrompt';
  constId: Scalars['ID']['output'];
  display: Scalars['Boolean']['output'];
  promptType: PromptType;
};

export type DisplayablePublicityListingProperty = {
  __typename?: 'DisplayablePublicityListingProperty';
  /** The name and region of the publication. e.g The New York Post (US) */
  key: Markdown;
  /** The title of the publication, and optional date and authorship, in a display ready format */
  value: Markdown;
};

export type DisplayableRelationNameProperty = {
  __typename?: 'DisplayableRelationNameProperty';
  /** The displayable relative name */
  value: Markdown;
};

export type DisplayableSalaryProperty = {
  __typename?: 'DisplayableSalaryProperty';
  /** The title for which this salary applies. */
  key: Markdown;
  /** The salary as a diplayable properity. */
  value: Markdown;
};

export type DisplayableSeasonConnection = {
  __typename?: 'DisplayableSeasonConnection';
  /** Pages of DisplayableSeason */
  edges: Array<Maybe<DisplayableSeasonEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of DisplayableSeason */
export type DisplayableSeasonEdge = {
  __typename?: 'DisplayableSeasonEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the DisplayableSeason */
  node: LocalizedDisplayableSeason;
  /** Position of the node in this context, eg: DisplayableSeason 4 out of 8 */
  position: Scalars['Int']['output'];
};

export type DisplayableSeasonsSort = {
  /**
   * Ascending sorted in increasing order by numerical seasons
   * followed by non-numerical season in alphabetical order e.g. [1, 2, 3, C, D]
   *
   * Descending sorting in decreasing order by numerical seasons
   * followed by non-numerical season in reverse alphabetical order e.g. [3, 2, 1, D, C]
   */
  order: SortOrder;
};

export type DisplayableSongTitle = {
  __typename?: 'DisplayableSongTitle';
  /** Type token */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** The display text */
  text: Scalars['String']['output'];
};

export type DisplayableSpouseTimeRange = {
  __typename?: 'DisplayableSpouseTimeRange';
  /** The time range as a localised, displayable property, e.g. '12 janvier 2020 - prsent' */
  displayableProperty: DisplayableSpouseTimeRangeProperty;
  /** The start date of this time range */
  fromDate?: Maybe<DisplayableDate>;
  /** The end date of this time range */
  toDate?: Maybe<DisplayableDate>;
};

export type DisplayableSpouseTimeRangeProperty = {
  __typename?: 'DisplayableSpouseTimeRangeProperty';
  /** Language of the displayed value. */
  language: DisplayableLanguage;
  /** A complete, formatted time range that can be displayed. */
  value: Markdown;
};

export type DisplayableTechnicalSpecificationLocalizedProperty = {
  __typename?: 'DisplayableTechnicalSpecificationLocalizedProperty';
  language: DisplayableLanguage;
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  value: Markdown;
};

export type DisplayableTechnicalSpecificationProperty = {
  __typename?: 'DisplayableTechnicalSpecificationProperty';
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  value: Markdown;
};

export type DisplayableTitleAkaProperty = {
  __typename?: 'DisplayableTitleAkaProperty';
  /** The country of the alternative title text */
  key: Markdown;
  /** The language of this title text */
  language?: Maybe<DisplayableLanguage>;
  /** The alternative title text qualifiers such as 'Alternative Title' and 'Working Title' */
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  /** The alternative title text */
  value: Markdown;
};

/** Company credit displayable property */
export type DisplayableTitleCompanyCreditProperty = {
  __typename?: 'DisplayableTitleCompanyCreditProperty';
  /** The company credit qualifiers, e.g. ['2009', 'Netherlands', 'Blu-ray'] */
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  /** The company credit value as link in Markdown */
  value: Markdown;
};

export type DisplayableTitleCountryOfOriginProperty = {
  __typename?: 'DisplayableTitleCountryOfOriginProperty';
  /** The language of the display text */
  language: DisplayableLanguage;
  /** The country of origin (e.g. 'United States') */
  value: Markdown;
};

/** Filming location displayable property */
export type DisplayableTitleFilmingLocationProperty = {
  __typename?: 'DisplayableTitleFilmingLocationProperty';
  /** The language of the localized text */
  language?: Maybe<DisplayableLanguage>;
  /** The filming location qualifiers such as 'Butch in his car encounters Marsellus Wallace' and 'Exterior' */
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  /** The filming location localized text */
  value: Markdown;
};

/** Genre displayable property */
export type DisplayableTitleGenreProperty = {
  __typename?: 'DisplayableTitleGenreProperty';
  /** The language the text is written in */
  language: DisplayableLanguage;
  /** The genre Markdown */
  value: Markdown;
};

export type DisplayableTitleReleaseDateProperty = {
  __typename?: 'DisplayableTitleReleaseDateProperty';
  /** The country in Markdown */
  key: Markdown;
  /** The release date qualifiers in Markdown such as internet, re-release, and Digital Film Festival */
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  /** The formatted release date in Markdown */
  value: Markdown;
};

export type DisplayableTitleRuntimeProperty = {
  __typename?: 'DisplayableTitleRuntimeProperty';
  language: DisplayableLanguage;
  qualifiersInMarkdownList?: Maybe<Array<Maybe<Markdown>>>;
  value: Markdown;
};

export type DisplayableTitleSpokenLanguageProperty = {
  __typename?: 'DisplayableTitleSpokenLanguageProperty';
  /** The language of the display text. */
  language: DisplayableLanguage;
  /** Display text for the language (e.g. 'English'). */
  value: Markdown;
};

/** Tagline displayable property */
export type DisplayableTitleTaglineProperty = {
  __typename?: 'DisplayableTitleTaglineProperty';
  /** The tagline Markdown */
  value: Markdown;
};

export type DisplayableTitleTypeProperty = {
  __typename?: 'DisplayableTitleTypeProperty';
  /** The title type Markdown */
  value: Markdown;
};

export type DisplayableYearConnection = {
  __typename?: 'DisplayableYearConnection';
  /** Pages of DisplayableYear */
  edges: Array<Maybe<DisplayableYearEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of DisplayableYear */
export type DisplayableYearEdge = {
  __typename?: 'DisplayableYearEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the DisplayableYear */
  node: LocalizedDisplayableEpisodeYear;
  /** Position of the node in this context, eg: DisplayableYear 4 out of 8 */
  position: Scalars['Int']['output'];
};

export type DisplayableYearsSort = {
  /**
   * Ascending sorting in increasing order by numerical years
   * followed by non-numerical in alphabetical order e.g. [2015, 2018, 2020, UNKNOWN]
   *
   * Descending sorting in decreasing order by numerical years
   * followed by non-numerical in reverse alphabetical order e.g. [2020, 2018, 2015, 2018, UNKNOWN]
   */
  order: SortOrder;
};

/** The distance from a requested location to a cinema. */
export type DistanceToCinema = {
  __typename?: 'DistanceToCinema';
  /** Integer representing the distance from the requested location to the cinema in meters. */
  distanceInMeters: Scalars['Int']['output'];
  /** Unique identifier for this distance. */
  id: Scalars['ID']['output'];
  /** Language of the distance display text. */
  language: DisplayableLanguage;
  /**
   * Localized text indicating the distance from the requested location to the cinema.
   * e.g. `3 miles` or `4.8 km`.
   */
  text: Scalars['String']['output'];
};

/** The distribution format of a title */
export type DistributionFormat = {
  __typename?: 'DistributionFormat';
  /** The id of the distribution format. */
  id: Scalars['ID']['output'];
  /** The language of the distribution format */
  language: DisplayableLanguage;
  /** Display text for the distribution format (e.g. 'Blu-ray'). */
  text: Scalars['String']['output'];
};

/**
 * Represents a user's preference for a specific type of email notification.
 * Contains both the notification details (title, description) and the user's subscription status.
 * Each preference represents a specific email topic that a user can subscribe to or opt out from.
 */
export type EmailPreference = {
  __typename?: 'EmailPreference';
  /** Detailed explanation of what this email notification contains. */
  description: LocalizedString;
  /** Unique identifier for this email preference. */
  id: Scalars['ID']['output'];
  /**
   * Indicates whether the user is currently subscribed to this email notification.
   * true means the user will receive emails, false means the user has opted out.
   */
  subscribed: Scalars['Boolean']['output'];
  /** Display name of the email notification. */
  title: LocalizedString;
};

/**
 * Represents all email notification preferences for a user.
 * Contains a master marketing preference toggle and categorized lists of specific email preferences.
 */
export type EmailPreferences = {
  __typename?: 'EmailPreferences';
  /**
   * User's overall marketing email preference.
   * When false, the user is opted out of ALL marketing emails regardless of individual preferences.
   * When true, individual marketing preferences determine which specific marketing emails the user receives.
   */
  allMarketingPreference: Scalars['Boolean']['output'];
  /**
   * List of marketing email preferences available to the user.
   * These are promotional emails that are subject to the allMarketingPreference.
   * Results are ordered alphabetically by email preference id.
   */
  marketingPreferences: Array<Maybe<EmailPreference>>;
  /**
   * List of subscription email preferences available to the user.
   * These are subscription emails that are not affected by the allMarketingPreference toggle.
   * Results are ordered alphabetically by email preference id.
   */
  subscriptionPreferences: Array<Maybe<EmailPreference>>;
};

export type EmployeeBranchName = {
  __typename?: 'EmployeeBranchName';
  /** The unique identifier for the branch name */
  id: Scalars['ID']['output'];
  /** The language that the text is in */
  language: DisplayableLanguage;
  /** The name of the branch */
  text: Scalars['String']['output'];
};

export type EmploymentConnection = {
  __typename?: 'EmploymentConnection';
  edges: Array<Maybe<EmploymentEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type EmploymentEdge = {
  __typename?: 'EmploymentEdge';
  cursor: Scalars['ID']['output'];
  node: PersonalEmployment;
  position: Scalars['Int']['output'];
};

export type EngagementStatistics = {
  __typename?: 'EngagementStatistics';
  /** The follower statistics for a followable entity. Follower stats will not be vended if the count is below 1000. */
  followerStatistics?: Maybe<FollowerStatistics>;
  /** The watchlist statistics for a title. Watchlist stats will not be vended if the count is below 1000. */
  watchlistStatistics?: Maybe<WatchlistStatistics>;
};

/** Pagination for Cast credit type on a Cast credit (for episode credits of a series title). */
export type EpisodeCastConnection = {
  __typename?: 'EpisodeCastConnection';
  /** All of the characters in this list of Cast credits */
  characters?: Maybe<Array<Maybe<Character>>>;
  /**
   * The seasons of episodes in the connection
   *
   * Sorted in increasing order by numerical seasons
   * followed by non-numerical season in alphabetical order e.g. [1, 2, 3, C, D]
   */
  displayableSeasons?: Maybe<DisplayableSeasonConnection>;
  /**
   * The years of episodes in the connection
   *
   * Sorted in increasing order by numerical years
   * followed by non-numerical in alphabetical order e.g. [2015, 2018, 2020, UNKNOWN]
   */
  displayableYears?: Maybe<DisplayableYearConnection>;
  edges: Array<Maybe<CreditEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
  /**
   * The earliest and latest release years for the Title(s) in these credits. If these would be the same,
   * only a single year is populated.
   */
  yearRange?: Maybe<YearRange>;
};


/** Pagination for Cast credit type on a Cast credit (for episode credits of a series title). */
export type EpisodeCastConnectionCharactersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Pagination for Cast credit type on a Cast credit (for episode credits of a series title). */
export type EpisodeCastConnectionDisplayableSeasonsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Pagination for Cast credit type on a Cast credit (for episode credits of a series title). */
export type EpisodeCastConnectionDisplayableYearsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for Episode types which always has a known total number of edges. */
export type EpisodeConnection = {
  __typename?: 'EpisodeConnection';
  /** Pages of episodes */
  edges: Array<Maybe<EpisodeEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type EpisodeCreditConnection = {
  __typename?: 'EpisodeCreditConnection';
  /**
   * The seasons of episodes in the connection
   *
   * Sorted in increasing order by numerical seasons
   * followed by non-numerical season in alphabetical order e.g. [1, 2, 3, C, D]
   * Field is null when no season information is present on the associated episodes.
   */
  displayableSeasons?: Maybe<DisplayableSeasonConnection>;
  /**
   * The years of episodes in the connection
   *
   * Sorted in increasing order by numerical years
   * followed by non-numerical in alphabetical order e.g. [2015, 2018, 2020, UNKNOWN].
   * Field is null when no year information is present on the associated episodes.
   */
  displayableYears?: Maybe<DisplayableYearConnection>;
  /** Results are sorted by release date ascending. */
  edges: Array<Maybe<CreditV2Edge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
  /**
   * The earliest and latest release years for the Title(s) in these credits. If these would be the same,
   * only a single year is populated.
   * Field is null when no year information is present on the associated episodes.
   */
  yearRange?: Maybe<YearRange>;
};


export type EpisodeCreditConnectionDisplayableSeasonsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type EpisodeCreditConnectionDisplayableYearsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type EpisodeCreditsFilter = {
  episodes?: InputMaybe<EpisodesFilter>;
};

export type EpisodeCreditsSort = {
  by: EpisodeCreditsSortBy;
  order: SortOrder;
};

export enum EpisodeCreditsSortBy {
  /**
   * Episode ordering follows this priority sequence:
   * 1. Release date
   * 2. Series number
   * 3. Episode number.
   */
  ReleaseDate = 'RELEASE_DATE'
}

/** Pagination for Crew credit type on a Crew credit (for episode credits of a series title). */
export type EpisodeCrewConnection = {
  __typename?: 'EpisodeCrewConnection';
  /**
   * The seasons of episodes in the connection
   *
   * Sorted in increasing order by numerical seasons
   * followed by non-numerical season in alphabetical order e.g. [1, 2, 3, C, D]
   */
  displayableSeasons?: Maybe<DisplayableSeasonConnection>;
  /**
   * The years of episodes in the connection
   *
   * Sorted in increasing order by numerical years
   * followed by non-numerical in alphabetical order e.g. [2015, 2018, 2020, UNKNOWN]
   */
  displayableYears?: Maybe<DisplayableYearConnection>;
  edges: Array<Maybe<CreditEdge>>;
  /** All of the jobs in this list of Crew credits */
  jobs?: Maybe<Array<Maybe<CrewJob>>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
  /**
   * The earliest and latest release years for the Title(s) in these credits. If these would be the same,
   * only a single year is populated.
   */
  yearRange?: Maybe<YearRange>;
};


/** Pagination for Crew credit type on a Crew credit (for episode credits of a series title). */
export type EpisodeCrewConnectionDisplayableSeasonsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Pagination for Crew credit type on a Crew credit (for episode credits of a series title). */
export type EpisodeCrewConnectionDisplayableYearsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Pagination for Crew credit type on a Crew credit (for episode credits of a series title). */
export type EpisodeCrewConnectionJobsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Page of episodes */
export type EpisodeEdge = {
  __typename?: 'EpisodeEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An episode node */
  node: Title;
  /** Position of the node in this context */
  position: Scalars['Int']['output'];
};

export type EpisodeNumberDisplayableProperty = {
  __typename?: 'EpisodeNumberDisplayableProperty';
  value: Markdown;
};

export type EpisodeReleaseDate = {
  day?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['Int']['input']>;
  year: Scalars['Int']['input'];
};

export type Episodes = {
  __typename?: 'Episodes';
  /**
   *   Displayable season as a standardized localizedDisplayableConcept
   * 
   *   Sorting is ascending by default.
   */
  displayableSeasons?: Maybe<DisplayableSeasonConnection>;
  /**
   * Displayable year as a standardized localizedDisplayableConcept
   *
   * Sorting in ascending by default.
   */
  displayableYears?: Maybe<DisplayableYearConnection>;
  episodes?: Maybe<EpisodeConnection>;
  /** A boolean flag that indicates if the series is ongoing (i.e. it has an unknown number of future episodes). */
  isOngoing?: Maybe<Scalars['Boolean']['output']>;
};


export type EpisodesDisplayableSeasonsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<DisplayableSeasonsSort>;
};


export type EpisodesDisplayableYearsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<DisplayableYearsSort>;
};


export type EpisodesEpisodesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<EpisodesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<EpisodesSort>;
};

export type EpisodesFilter = {
  /** Filter out season values e.g. ['1', '2', 'unknown'] */
  excludeSeasons?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter for season values e.g. ['1', '2', 'unknown'] */
  includeSeasons?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter for episodes with release date newer or equal the given date excluding episodes with unknown release date */
  releasedOnOrAfter?: InputMaybe<EpisodeReleaseDate>;
  /** Filter for episodes with release date older or equal the given date excluding episodes with unknown release date */
  releasedOnOrBefore?: InputMaybe<EpisodeReleaseDate>;
  /** Filter for episodes with unknown release date */
  unknownReleaseDate?: InputMaybe<UnknownReleaseDateFilter>;
};

export type EpisodesSort = {
  by: EpisodesSortBy;
  order: SortOrder;
};

export enum EpisodesSortBy {
  EpisodeThenRelease = 'EPISODE_THEN_RELEASE',
  Rating = 'RATING',
  ReleaseDate = 'RELEASE_DATE'
}

/**
 * Inputs here are AND'd together
 *
 * If the same input is specified in the any and exclude constraints,
 * then the results should be empty.
 *
 * Example: To match the Season 8, Episode 6 of tt0944947 you can search
 * anySeriesIds: ["tt0944947"], anySeasons: ["8"], anyEpisodeNumbers: ["6"]
 *
 * Example: To exclude the Season 8, Episode 6 of tt0944947 you can search
 * excludeSeriesIds: ["tt0944947"], excludeSeasons: ["8"], excludeEpisodeNumbers: ["6"]
 */
export type EpisodicSearchConstraint = {
  /**
   * Match episodes that have AT LEAST ONE of these episode numbers
   * ES: For first three episodes ['1', '2', '3']
   * ES: For episodes without episode number ['Unknown']
   */
  anyEpisodeNumbers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Match episodes are a part of AT LEAST ONE of these seasons
   * Example: To restrict to first three seasons: ['1', '2', '3']
   * Example: To restrict to Unknown season, or Holiday Special Season: ['Unknown', 'Holiday Special']
   */
  anySeasons?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Match episodes are a part of AT LEAST ONE of these series Title Ids */
  anySeriesIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Exclude episodes that have AT LEAST ONE of these episode numbers
   * ES: For all episodes except the first three ['1', '2', '3']
   * ES: For all episodes with an episode number ['Unknown']
   */
  excludeEpisodeNumbers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Exclude episodes that are a part of AT LEAST ONE of these seasons
   * Example: To restrict to none of the first three seasons: ['1', '2', '3']
   * Example: To restrict to neither Unknown season, or Holiday Special Season: ['Unknown', 'Holiday Special']
   */
  excludeSeasons?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Exclude episodes that are a part of AT LEAST ONE of these series Title Ids */
  excludeSeriesIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Pagination for Events which always has a known total number of edges. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** Pages of Events */
  edges: Array<Maybe<EventEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Events */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An AwardsEvent node */
  node: AwardsEvent;
  /** Position of the node in this context, eg: Event 4 out of 31 */
  position: Scalars['Int']['output'];
};

/** The instance of an event that took place in a specific year */
export type EventEdition = {
  __typename?: 'EventEdition';
  /** A list of awards announced in an event edition e.g. 'Oscar' */
  awards?: Maybe<AwardDetailsConnection>;
  /** The event where the event edition is happening e.g Academy Awards, USA */
  event: AwardsEvent;
  /** A unique id prefixed with 'ee' */
  id: Scalars['ID']['output'];
  /** A number that defines the sequence of editions within a year, starting with 1 */
  instanceWithinYear: Scalars['Int']['output'];
  /** List of trivia items related to the event edition with potential markdown links for movies/people */
  trivia?: Maybe<Array<Maybe<Markdown>>>;
  /** The year this edition of the event took place */
  year: Scalars['Int']['output'];
};


/** The instance of an event that took place in a specific year */
export type EventEditionAwardsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Data for a combination of Event Edition and Award. */
export type EventEditionAward = {
  __typename?: 'EventEditionAward';
  /**
   * Award Name. eg: 'Oscar'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  awardName: Scalars['String']['output'];
  /**
   * The compound ID key for an event edition and award combination
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * Award Nominations List. Sorted by win time order, most recent first.
   * An empty array indicates no winners have been announced (yet).
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  winners: Array<Maybe<AwardNomination>>;
};


/** Data for a combination of Event Edition and Award. */
export type EventEditionAwardWinnersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for EventEdition types which always has a known total number of edges. */
export type EventEditionConnection = {
  __typename?: 'EventEditionConnection';
  /** Pages of event editions */
  edges: Array<Maybe<EventEditionEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of event editions */
export type EventEditionEdge = {
  __typename?: 'EventEditionEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An EventEdition node */
  node: EventEdition;
  /** Position of the node in this context, eg: EventEdition 4 out of 312 */
  position: Scalars['Int']['output'];
};

export type EventLiveResults = {
  __typename?: 'EventLiveResults';
  /** The optional localized string to display as subtext for the widget. */
  displayDescription?: Maybe<LocalizedString>;
  /** The localized string to display as the title of the widget. */
  displayTitle: LocalizedString;
  /** The event edition and award currently live on the site. */
  eventEditionAward: EventEditionAward;
  /** The event id, e.g, ev0000003 for Oscars */
  eventId: Scalars['String']['output'];
  /** URL for the event page on the consumer website, if there is one. */
  eventPageUrl?: Maybe<Scalars['URL']['output']>;
  /** The localized blurb to act as a placeholder if there are no winners yet. */
  noWinnersBlurb: LocalizedString;
};

export type EventLiveResultsOverrideInput = {
  /** Event override will not be applied unless this is 'true' */
  enableOverride: Scalars['Boolean']['input'];
  /**
   * Optionally specify a specific event edition and award to return data for. Otherwise return
   * data for a pre-configured override event which is subject to change.
   */
  overrideEvent?: InputMaybe<OverrideLiveEventInput>;
};

export type EventMetadata = {
  __typename?: 'EventMetadata';
  /** Single event by evconst */
  event?: Maybe<AwardsEvent>;
  /** All the event Ids */
  events?: Maybe<EventConnection>;
};


export type EventMetadataEventArgs = {
  id: Scalars['ID']['input'];
};


export type EventMetadataEventsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type EventUrl = {
  __typename?: 'EventUrl';
  category: EventUrlCategory;
  url: Scalars['String']['output'];
};

export type EventUrlCategory = {
  __typename?: 'EventUrlCategory';
  /** The Url category Id, e.g. official */
  categoryId: Scalars['String']['output'];
  /** Opaque URL category ID */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** The display text for Url category, e.g. Official */
  text: Scalars['String']['output'];
};

export type EventsFilter = {
  /** Filter out given Events IDs */
  excludeEvents?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter for given Events IDs */
  includeEvents?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Experimental Field: DO NOT USE. Cast details */
export type ExperimentalCast = ExperimentalCredit & {
  __typename?: 'ExperimentalCast';
  attributes?: Maybe<Array<Maybe<CreditAttribute>>>;
  category: CreditCategory;
  /** Characters (e.g. 'Neo') */
  characters?: Maybe<Array<Maybe<Character>>>;
  /** Experimental Field: DO NOT USE */
  experimental_episodeCredits?: Maybe<ExperimentalEpisodeCastConnection>;
  name: Name;
  /**
   * A cast credit may have an optional position attribute indicating the order of
   * appearance within the titles ending credits. This position can be null for
   * some or all of the titles credits. By default (see CreditConnection.orderBy),
   * the cast credit that has a value in their position field will be ordered first
   * (by that number), then all other cast credits that have a null in their
   * position field will be ordered alphabetically.
   */
  position?: Maybe<Scalars['Int']['output']>;
  title: Title;
};


/** Experimental Field: DO NOT USE. Cast details */
export type ExperimentalCastAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Experimental Field: DO NOT USE. Cast details */
export type ExperimentalCastCharactersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Experimental Field: DO NOT USE. Cast details */
export type ExperimentalCastExperimental_EpisodeCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<EpisodeCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<EpisodeCreditsSort>;
};

/**
 * Experimental Field: DO NOT USE.
 * Credit details. Open question: do we want to add a persistent ID for credits?
 * Without this we require a nameID, titleID and Category to uniquely identify it.
 */
export type ExperimentalCredit = {
  /**
   * Category (e.g. 'Producer').
   * Open question: the name of this field comes from TitleCreditsBaseV5. Should we change it?
   */
  category: CreditCategory;
  /** The person credited */
  name: Name;
  /** The title on which this credit appears */
  title: Title;
};

/** Experimental Field: DO NOT USE. Pagination for Credit type on a Title. */
export type ExperimentalCreditConnection = {
  __typename?: 'ExperimentalCreditConnection';
  /** Indicates whether the requested filmography data accurately reflects the onscreen cast or crew credits */
  completenessStatus?: Maybe<CreditsCompletenessStatus>;
  /** Pages of credits */
  edges: Array<Maybe<ExperimentalCreditEdge>>;
  /** How the credits are ordered */
  orderBy?: Maybe<CreditsOrderedBy>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<CreditRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Experimental Field: DO NOT USE. Page of credits */
export type ExperimentalCreditEdge = {
  __typename?: 'ExperimentalCreditEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Credit node */
  node: ExperimentalCredit;
  /** Position of the node in this context, eg: Credit 4 out of 31 */
  position: Scalars['Int']['output'];
};

/** Experimental Field: DO NOT USE. Crew details */
export type ExperimentalCrew = ExperimentalCredit & {
  __typename?: 'ExperimentalCrew';
  attributes?: Maybe<Array<Maybe<CreditAttribute>>>;
  category: CreditCategory;
  /** Experimental Field: DO NOT USE */
  experimental_episodeCredits?: Maybe<ExperimentalEpisodeCrewConnection>;
  /** List of job and related Attributes */
  jobDetails?: Maybe<Array<Maybe<CrewJobDetails>>>;
  /**
   * List of jobs (e.g. 'Executive Producer')
   * Open questions: the name of this field comes from TitleCreditsBaseV5. Should we change it?
   */
  jobs?: Maybe<Array<Maybe<CrewJob>>>;
  name: Name;
  title: Title;
};


/** Experimental Field: DO NOT USE. Crew details */
export type ExperimentalCrewAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Experimental Field: DO NOT USE. Crew details */
export type ExperimentalCrewExperimental_EpisodeCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<EpisodeCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<EpisodeCreditsSort>;
};


/** Experimental Field: DO NOT USE. Crew details */
export type ExperimentalCrewJobDetailsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Experimental Field: DO NOT USE. Crew details */
export type ExperimentalCrewJobsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Experimental Field: DO NOT USE. Pagination for Cast credit type on a Cast credit (for episode credits of a series title). */
export type ExperimentalEpisodeCastConnection = {
  __typename?: 'ExperimentalEpisodeCastConnection';
  /** All of the characters in this list of Cast credits */
  characters?: Maybe<Array<Maybe<Character>>>;
  /**
   * The seasons of episodes in the connection
   *
   * Sorted in increasing order by numerical seasons
   * followed by non-numerical season in alphabetical order e.g. [1, 2, 3, C, D]
   */
  displayableSeasons?: Maybe<DisplayableSeasonConnection>;
  /**
   * The years of episodes in the connection
   *
   * Sorted in increasing order by numerical years
   * followed by non-numerical in alphabetical order e.g. [2015, 2018, 2020, UNKNOWN]
   */
  displayableYears?: Maybe<DisplayableYearConnection>;
  edges: Array<Maybe<ExperimentalCreditEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
  /**
   * The earliest and latest release years for the Title(s) in these credits. If these would be the same,
   * only a single year is populated.
   */
  yearRange?: Maybe<YearRange>;
};


/** Experimental Field: DO NOT USE. Pagination for Cast credit type on a Cast credit (for episode credits of a series title). */
export type ExperimentalEpisodeCastConnectionCharactersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Experimental Field: DO NOT USE. Pagination for Cast credit type on a Cast credit (for episode credits of a series title). */
export type ExperimentalEpisodeCastConnectionDisplayableSeasonsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Experimental Field: DO NOT USE. Pagination for Cast credit type on a Cast credit (for episode credits of a series title). */
export type ExperimentalEpisodeCastConnectionDisplayableYearsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Experimental Field: DO NOT USE. Pagination for Crew credit type on a Crew credit (for episode credits of a series title). */
export type ExperimentalEpisodeCrewConnection = {
  __typename?: 'ExperimentalEpisodeCrewConnection';
  /**
   * The seasons of episodes in the connection
   *
   * Sorted in increasing order by numerical seasons
   * followed by non-numerical season in alphabetical order e.g. [1, 2, 3, C, D]
   */
  displayableSeasons?: Maybe<DisplayableSeasonConnection>;
  /**
   * The years of episodes in the connection
   *
   * Sorted in increasing order by numerical years
   * followed by non-numerical in alphabetical order e.g. [2015, 2018, 2020, UNKNOWN]
   */
  displayableYears?: Maybe<DisplayableYearConnection>;
  edges: Array<Maybe<ExperimentalCreditEdge>>;
  /** All of the jobs in this list of Crew credits */
  jobs?: Maybe<Array<Maybe<CrewJob>>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
  /**
   * The earliest and latest release years for the Title(s) in these credits. If these would be the same,
   * only a single year is populated.
   */
  yearRange?: Maybe<YearRange>;
};


/** Experimental Field: DO NOT USE. Pagination for Crew credit type on a Crew credit (for episode credits of a series title). */
export type ExperimentalEpisodeCrewConnectionDisplayableSeasonsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Experimental Field: DO NOT USE. Pagination for Crew credit type on a Crew credit (for episode credits of a series title). */
export type ExperimentalEpisodeCrewConnectionDisplayableYearsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Experimental Field: DO NOT USE. Pagination for Crew credit type on a Crew credit (for episode credits of a series title). */
export type ExperimentalEpisodeCrewConnectionJobsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type ExperimentalNameCreditCategoryWithCredits = {
  __typename?: 'ExperimentalNameCreditCategoryWithCredits';
  category: CreditCategory;
  credits?: Maybe<ExperimentalNameCreditConnection>;
};


export type ExperimentalNameCreditCategoryWithCreditsCreditsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Experimental Field: DO NOT USE. Pagination for Credit type on a Name. */
export type ExperimentalNameCreditConnection = {
  __typename?: 'ExperimentalNameCreditConnection';
  /** Pages of credits */
  edges: Array<Maybe<ExperimentalCreditEdge>>;
  /** How the credits are ordered */
  orderBy?: Maybe<CreditsOrderedBy>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<CreditRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Experimental Field: DO NOT USE. */
export type ExperimentalTitleCreditsFilter = {
  /** Filter for specific credit categories */
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter to maintain current implementation of copying jobs to attributes */
  copy_jobs?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter for credited or uncredited credits only */
  credited?: InputMaybe<CreditedOrUncreditedFilter>;
  /** Filter out specific credit categories */
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  excludePrincipal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter credits on these specific names */
  names?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Product type information for an ad */
export type Experimental_AdProductType = {
  __typename?: 'Experimental_AdProductType';
  /** The grade of the ad product type */
  grade: Scalars['String']['output'];
  /** The name of the ad product type */
  name: Scalars['String']['output'];
  /** The symbol for the ad product type */
  symbol: Scalars['String']['output'];
};

export type Experimental_AdditionalCreditCategoriesInput = {
  /**
   * The categories to be excluded from the request.
   *
   * If no value is provided, no categories are excluded.
   */
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * The categories to be include in the request.
   *
   * If no value is provided, all categories are returned.
   */
  includeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type Experimental_AdditionalCreditItem = {
  __typename?: 'Experimental_AdditionalCreditItem';
  /** The name of the category of the credit. */
  category: LocalizedString;
  /** The name of the company or director that made the project. */
  details: LocalizedString;
  /** Unique identifier for the additional credit object. */
  id: Scalars['ID']['output'];
  /** The role or position the individual had on the project. */
  job: LocalizedString;
  /** The name or title of the project. */
  title: LocalizedString;
};

export type Experimental_AdditionalCreditItemConnection = {
  __typename?: 'Experimental_AdditionalCreditItemConnection';
  edges: Array<Maybe<Experimental_AdditionalCreditItemEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_AdditionalCreditItemEdge = {
  __typename?: 'Experimental_AdditionalCreditItemEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_AdditionalCreditItem;
  position: Scalars['Int']['output'];
};

export type Experimental_AdditionalCreditsInput = {
  /**
   * The categories to be include in the request.
   *
   * If no value is provided, all categories are returned.
   */
  includeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type Experimental_AdditionalResumeInfo = {
  __typename?: 'Experimental_AdditionalResumeInfo';
  /** The details for an additional resume info section. */
  details?: Maybe<LocalizedString>;
  /** Unique identifier for the additional resume info object. */
  id: Scalars['ID']['output'];
  /** The title for the additional resume info section. */
  title?: Maybe<LocalizedString>;
};

export type Experimental_AdditionalResumeInfoConnection = {
  __typename?: 'Experimental_AdditionalResumeInfoConnection';
  edges: Array<Maybe<Experimental_AdditionalResumeInfoEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_AdditionalResumeInfoEdge = {
  __typename?: 'Experimental_AdditionalResumeInfoEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_AdditionalResumeInfo;
  position: Scalars['Int']['output'];
};

/**
 * @experimental Experimental: DO NOT USE
 *
 * An agency that represents a name
 */
export type Experimental_Agency = {
  __typename?: 'Experimental_Agency';
  /** The company representing a name */
  company: Company;
  /**
   * @experimental Experimental: DO NOT USE
   *
   * The employees at this company who specifically represent a person.
   *
   * A name can be represented by 0, 1, or many people at a specific company.
   */
  experimental_agents?: Maybe<Array<Maybe<Experimental_Agent>>>;
};

/**
 * @experimental Experimental: DO NOT USE
 *
 * An employee of a company who represents a name in some capacity
 */
export type Experimental_Agent = {
  __typename?: 'Experimental_Agent';
  branch?: Maybe<Experimental_CompanyBranch>;
  company: Company;
  experimental_employeeContact?: Maybe<Experimental_CompanyContactDetails>;
  id: Scalars['ID']['output'];
  /**
   * Whether or not this person is the primary representative.
   *
   * Each representation type and company combination can have one point of contact
   * but is not guaranteed to have one, even if there is only one associated representative.
   *
   * For example, if a person has multiple Talent Agents at CAA, this being
   * true would indicate the associated name is the person's main Talent Agent
   * at CAA
   */
  isPrimaryAgent: Scalars['Boolean']['output'];
  jobTitle?: Maybe<LocalizedString>;
  name: Name;
  occupation?: Maybe<OccupationValue>;
  /** The type of relationship this representation has with their client */
  relationshipType: Experimental_RepresentationRelationshipType;
};

/** Information about an APS slot for Amazon Publisher Services integration */
export type Experimental_ApsSlotInfo = {
  __typename?: 'Experimental_ApsSlotInfo';
  /** The APS slot ID */
  apsSlotId: Scalars['String']['output'];
  /** The APS slot name */
  apsSlotName: Scalars['String']['output'];
  /** Parameters for the APS slot */
  apsSlotParams: Array<Maybe<Experimental_ApsSlotParam>>;
  /** The name of the ad slot */
  slotName: Scalars['String']['output'];
};

/** Key-value pair for APS slot parameters */
export type Experimental_ApsSlotParam = {
  __typename?: 'Experimental_ApsSlotParam';
  /** The key of the parameter */
  key: Scalars['String']['output'];
  /** The value of the parameter */
  value: Scalars['String']['output'];
};

/** @experimental Inputs for constraining titles for earnings */
export type Experimental_BoxOfficeEarningsSearchConstraint = {
  /** @experimental field, match titles that have a gross box office revenue in the given range ($USD) */
  experimental_boxOfficePerformanceRange?: InputMaybe<FloatRangeInput>;
  /** @experimental field, match titles that have a production budget in the given range ($USD) */
  experimental_productionBudgetRange?: InputMaybe<FloatRangeInput>;
};

/** @experimental Experimental: DO NOT USE */
export type Experimental_CompanyBranch = {
  __typename?: 'Experimental_CompanyBranch';
  /** Ways to contact this part of the company directly */
  experimental_directContact?: Maybe<Experimental_CompanyContactDetails>;
  /** An obfuscated persistent id to uniquely identify this data */
  id: Scalars['ID']['output'];
  /** Branch name */
  name?: Maybe<LocalizedString>;
};

/** @experimental Experimental: DO NOT USE */
export type Experimental_CompanyBranchConnection = {
  __typename?: 'Experimental_CompanyBranchConnection';
  edges: Array<Maybe<Experimental_CompanyBranchEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

/** @experimental Experimental: DO NOT USE */
export type Experimental_CompanyBranchEdge = {
  __typename?: 'Experimental_CompanyBranchEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_CompanyBranch;
  position: Scalars['Int']['output'];
};

export type Experimental_CompanyClient = {
  __typename?: 'Experimental_CompanyClient';
  /** The name being represented */
  client: Name;
  /**
   * The employees working at this company who work with the client
   * in this type of relationship
   *
   * Returns nothing if we have no information about the individual
   * employees at this company who work specifically with this client.
   */
  experimental_agents?: Maybe<Array<Maybe<Experimental_Agent>>>;
  /** An obfuscated persistent id to uniquely identify this data */
  id: Scalars['ID']['output'];
};

export type Experimental_CompanyClientConnection = {
  __typename?: 'Experimental_CompanyClientConnection';
  edges: Array<Maybe<Experimental_CompanyClientEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_CompanyClientEdge = {
  __typename?: 'Experimental_CompanyClientEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_CompanyClient;
  position: Scalars['Int']['output'];
};

/** @experimental Experimental: DO NOT USE */
export type Experimental_CompanyContactDetails = {
  __typename?: 'Experimental_CompanyContactDetails';
  emailAddress?: Maybe<Scalars['String']['output']>;
  faxNumber?: Maybe<LocalizedString>;
  phoneNumbers?: Maybe<Array<Maybe<LocalizedString>>>;
  /** A physical mailing address for this company or this company's specific office */
  physicalAddress?: Maybe<Location>;
  website?: Maybe<WebsiteLink>;
};

export type Experimental_DirectContactDetails = {
  __typename?: 'Experimental_DirectContactDetails';
  emailAddress?: Maybe<Scalars['String']['output']>;
  faxNumber?: Maybe<LocalizedString>;
  phoneNumbers?: Maybe<Array<Maybe<LocalizedString>>>;
  website?: Maybe<WebsiteLink>;
};

export type Experimental_EmploymentConnection = {
  __typename?: 'Experimental_EmploymentConnection';
  edges: Array<Maybe<Experimental_EmploymentEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_EmploymentEdge = {
  __typename?: 'Experimental_EmploymentEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_PersonalEmployment;
  position: Scalars['Int']['output'];
};

/** @experimental Experimental: DO NOT USE */
export type Experimental_NameRepresentation = {
  __typename?: 'Experimental_NameRepresentation';
  /** The name being represented */
  client: Name;
  /**
   * The company representing this name, if there is one
   *
   * Either agency or independentRepresentative will have data but not both
   */
  experimental_agency?: Maybe<Experimental_Agency>;
  /** An obfuscated persistent id to uniquely identify this data */
  id: Scalars['ID']['output'];
  /**
   * Someone representing this name but not associated with a company.
   *
   * Either agency or independentRepresentative will have data but not both
   */
  independentRepresentative?: Maybe<Name>;
  /** The type of relationship this representation has with the name */
  relationshipType: Experimental_RepresentationRelationshipType;
};

export type Experimental_NameRepresentationConnection = {
  __typename?: 'Experimental_NameRepresentationConnection';
  edges: Array<Maybe<Experimental_NameRepresentationEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_NameRepresentationEdge = {
  __typename?: 'Experimental_NameRepresentationEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_NameRepresentation;
  position: Scalars['Int']['output'];
};

export type Experimental_NotificationPreference = {
  __typename?: 'Experimental_NotificationPreference';
  /** True if requesting customer receives notifications for this preference type */
  interested: Scalars['Boolean']['output'];
  /** Preference type */
  type: Experimental_NotificationPreferenceType;
};

/** Preference type for a tracked page */
export type Experimental_NotificationPreferenceType = {
  __typename?: 'Experimental_NotificationPreferenceType';
  /** Unique identifier for the notification preference type */
  id: Scalars['ID']['output'];
  /** Language of the text */
  language: DisplayableLanguage;
  /** Text describing the notification preference type */
  text: Scalars['String']['output'];
};

/** @experimental Inputs for constraining searches for occupation credits */
export type Experimental_OccupationCreditSearchConstraint = {
  /**
   * @experimental field, match titles that have any of the occupations attached
   * This is a string, but may change in the future as PACE evolves
   */
  experimental_anyOccupationCreditKeywords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * @experimental field, exclude titles that have any of the occupations attached
   * This is a string, but may change in the future as PACE evolves
   */
  experimental_excludeOccupationCreditKeywords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** @experimental Experimental: DO NOT USE */
export type Experimental_PersonalEmployment = {
  __typename?: 'Experimental_PersonalEmployment';
  branch?: Maybe<Experimental_CompanyBranch>;
  company: Company;
  experimental_employeeContact?: Maybe<Experimental_CompanyContactDetails>;
  id: Scalars['ID']['output'];
  jobTitle?: Maybe<LocalizedString>;
  name: Name;
  occupation?: Maybe<OccupationValue>;
};

/** Key-value pair for plaid overrides */
export type Experimental_PlaidOverride = {
  __typename?: 'Experimental_PlaidOverride';
  /** The key for the plaid override */
  key: Scalars['String']['output'];
  /** The value for the plaid override */
  value: Scalars['String']['output'];
};

/** @experimental Inputs for constraining searches for profession catagories */
export type Experimental_ProfessionCatagorySearchConstraint = {
  /**
   * @experimental field, match titles that have any of the profession category ID's attached
   * see: imdb.id.amzn1.imdb.concept.ProfessionCategoryId
   * example: amzn1.imdb.concept.profession_category.00000000-0000-7000-0000-000000000000
   */
  experimental_anyProfessionCategoryIDs?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * @experimental field, exclude all titles that have any of the profession category ID's (ProfessionCategoryId) attached
   * see: imdb.id.amzn1.imdb.concept.ProfessionCategoryId
   * example: amzn1.imdb.concept.profession_category.00000000-0000-7000-0000-000000000000
   */
  experimental_excludeProfessionCategoryIDs?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** @experimental Experimental: DO NOT USE */
export type Experimental_RepresentationRelationshipType = {
  __typename?: 'Experimental_RepresentationRelationshipType';
  /** An obfuscated persistent id to uniquely identify this data */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /**
   * A non-localized, somewhat human readable string representing this relationship
   * type
   *
   * Intended to support filtering or search behavior where we need a unique
   * way to represent this relationship type
   *
   * Example: 'talentAgent'
   */
  relationshipTypeId: Scalars['String']['output'];
  /** The display text for this relationship type - 'Talent Agent' */
  text: Scalars['String']['output'];
};

export type Experimental_Resume = {
  __typename?: 'Experimental_Resume';
  /**
   * @experimental experimental
   * Self verified additional awards for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_additionalAwards?: Maybe<Experimental_SelfVerifiedAwardConnection>;
  /**
   * @experimental experimental
   * Self verified additional credits data for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_additionalCreditCategories?: Maybe<Experimental_ResumeAdditionalCreditsCategories>;
  /**
   * @experimental experimental
   * Self verified additional credits data for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_additionalCredits?: Maybe<Experimental_AdditionalCreditItemConnection>;
  /**
   * @experimental experimental
   * Self verified additional resume sections for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_additionalResumeInfo?: Maybe<Experimental_AdditionalResumeInfoConnection>;
  /**
   * @experimental experimental
   * Self verified training history data for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_education?: Maybe<Experimental_SelfVerifiedEducationConnection>;
  /**
   * @experimental experimental
   * Self verified performer profile data for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_performerProfile?: Maybe<Array<Maybe<Experimental_ResumeDataItem>>>;
  /**
   * @experimental experimental
   * Self verified personal details data for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_personalDetails?: Maybe<Array<Maybe<Experimental_ResumeDataItem>>>;
  /**
   * @experimental experimental
   * Self verified profession background data for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_professionalBackground?: Maybe<Array<Maybe<Experimental_ResumeDataItem>>>;
  /**
   * @experimental experimental
   * Self verified references for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_references?: Maybe<Experimental_SelfVerifiedReferenceConnection>;
  /**
   * @experimental experimental
   * Self verified skills data for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_skills?: Maybe<Array<Maybe<Experimental_ResumeDataItem>>>;
  /**
   * @experimental experimental
   * Self verified training history data for this name.
   *
   * @entitlement(PRO_ANY_TIER)
   */
  experimental_training?: Maybe<Experimental_SelfVerifiedTrainingConnection>;
};


export type Experimental_ResumeExperimental_AdditionalAwardsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


export type Experimental_ResumeExperimental_AdditionalCreditCategoriesArgs = {
  input?: InputMaybe<Experimental_AdditionalCreditCategoriesInput>;
};


export type Experimental_ResumeExperimental_AdditionalCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  input?: InputMaybe<Experimental_AdditionalCreditsInput>;
};


export type Experimental_ResumeExperimental_AdditionalResumeInfoArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


export type Experimental_ResumeExperimental_EducationArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


export type Experimental_ResumeExperimental_PerformerProfileArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type Experimental_ResumeExperimental_PersonalDetailsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type Experimental_ResumeExperimental_ProfessionalBackgroundArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type Experimental_ResumeExperimental_ReferencesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


export type Experimental_ResumeExperimental_SkillsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type Experimental_ResumeExperimental_TrainingArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};

export type Experimental_ResumeAdditionalCreditsCategories = {
  __typename?: 'Experimental_ResumeAdditionalCreditsCategories';
  /** A list of categories for additional credits on a name page. */
  categories: Array<Maybe<Experimental_ResumeAdditionalCreditsCategory>>;
  /** The total number of categories returned. */
  total: Scalars['Int']['output'];
};

export type Experimental_ResumeAdditionalCreditsCategory = {
  __typename?: 'Experimental_ResumeAdditionalCreditsCategory';
  /**
   * A list of credits belonging to this category.
   *
   * Ordered by ascending contribution date.
   */
  credits: Array<Maybe<Experimental_AdditionalCreditItem>>;
  /** The unique identifier for the credit category. */
  id: Scalars['ID']['output'];
  /** The displayable title for the category. */
  title: LocalizedString;
  /** The total number of credits in this category. */
  total: Scalars['Int']['output'];
};


export type Experimental_ResumeAdditionalCreditsCategoryCreditsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type Experimental_ResumeDataItem = {
  __typename?: 'Experimental_ResumeDataItem';
  /** The label for the data item. */
  label: LocalizedString;
  /** The value for the data item. */
  values?: Maybe<Array<Maybe<LocalizedString>>>;
};

export type Experimental_SelfVerifiedAward = {
  __typename?: 'Experimental_SelfVerifiedAward';
  /** The title of the award. */
  awardTitle?: Maybe<LocalizedString>;
  /** Additional details about the award. */
  details?: Maybe<LocalizedString>;
  /** The name of the event for the award. */
  event?: Maybe<LocalizedString>;
  /** A unique identifier for a resume self-verified award. */
  id: Scalars['ID']['output'];
  /** The year in which the award was received. */
  year?: Maybe<Scalars['Int']['output']>;
};

export type Experimental_SelfVerifiedAwardConnection = {
  __typename?: 'Experimental_SelfVerifiedAwardConnection';
  edges: Array<Maybe<Experimental_SelfVerifiedAwardEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_SelfVerifiedAwardEdge = {
  __typename?: 'Experimental_SelfVerifiedAwardEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_SelfVerifiedAward;
  position: Scalars['Int']['output'];
};

export type Experimental_SelfVerifiedEducation = {
  __typename?: 'Experimental_SelfVerifiedEducation';
  /** The degree that the person received. */
  degree?: Maybe<LocalizedString>;
  /** Additional details about their education. */
  details?: Maybe<LocalizedString>;
  /** A unique identifier for the resume education item. */
  id: Scalars['ID']['output'];
  /** The location of the school */
  location?: Maybe<LocalizedString>;
  /** The name of the school. */
  school?: Maybe<LocalizedString>;
  /** The year in which they completed their education. */
  year?: Maybe<Scalars['Int']['output']>;
};

export type Experimental_SelfVerifiedEducationConnection = {
  __typename?: 'Experimental_SelfVerifiedEducationConnection';
  edges: Array<Maybe<Experimental_SelfVerifiedEducationEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_SelfVerifiedEducationEdge = {
  __typename?: 'Experimental_SelfVerifiedEducationEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_SelfVerifiedEducation;
  position: Scalars['Int']['output'];
};

export type Experimental_SelfVerifiedReference = {
  __typename?: 'Experimental_SelfVerifiedReference';
  /** A contact value for this reference, can be a phone number, email address, etc. */
  contact?: Maybe<Scalars['String']['output']>;
  /** A unique identifier for this reference item. */
  id: Scalars['ID']['output'];
  /** The name of their reference. */
  name?: Maybe<LocalizedString>;
  /** Their relationship to this reference. */
  relationship?: Maybe<LocalizedString>;
};

export type Experimental_SelfVerifiedReferenceConnection = {
  __typename?: 'Experimental_SelfVerifiedReferenceConnection';
  edges: Array<Maybe<Experimental_SelfVerifiedReferenceEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_SelfVerifiedReferenceEdge = {
  __typename?: 'Experimental_SelfVerifiedReferenceEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_SelfVerifiedReference;
  position: Scalars['Int']['output'];
};

export type Experimental_SelfVerifiedTraining = {
  __typename?: 'Experimental_SelfVerifiedTraining';
  /** Additional details about the training. */
  details?: Maybe<LocalizedString>;
  /** A unique identifier for this resume training item. */
  id: Scalars['ID']['output'];
  /** The name of the person who instructed them. */
  instructor?: Maybe<LocalizedString>;
  /** The location of the school. */
  location?: Maybe<LocalizedString>;
  /** The name of the school or place where they received training. */
  school?: Maybe<LocalizedString>;
  /** The type of training they received. */
  training?: Maybe<LocalizedString>;
  /** The year in which they completed the training. */
  year?: Maybe<Scalars['Int']['output']>;
};

export type Experimental_SelfVerifiedTrainingConnection = {
  __typename?: 'Experimental_SelfVerifiedTrainingConnection';
  edges: Array<Maybe<Experimental_SelfVerifiedTrainingEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type Experimental_SelfVerifiedTrainingEdge = {
  __typename?: 'Experimental_SelfVerifiedTrainingEdge';
  cursor: Scalars['ID']['output'];
  node: Experimental_SelfVerifiedTraining;
  position: Scalars['Int']['output'];
};

/** The IMDb site variant on which the ads are intended to be shown. */
export enum Experimental_Site {
  Consumer = 'CONSUMER',
  Mobile = 'MOBILE',
  Pro = 'PRO'
}

/** Entry in the slots size map. */
export type Experimental_SlotSize = {
  /** The height of the slot in pixels */
  height: Scalars['Int']['input'];
  /** The name of the slot. */
  name: Scalars['String']['input'];
  /** The width of the slot in pixels */
  width: Scalars['Int']['input'];
};

export type Experimental_TrackNotificationPreferences = {
  __typename?: 'Experimental_TrackNotificationPreferences';
  /** Indicates if current user is tracking given const */
  isTracking: Scalars['Boolean']['output'];
  /** The requesting user's notification preferences for this const. Empty if user not tracking. */
  notificationPreferences?: Maybe<Array<Maybe<Experimental_NotificationPreference>>>;
};

/** AdCreativeInfo with additional web/responsive fields. Can be merge into single definition when finalizing webAdsConfig */
export type Experimental_WebAdCreativeInfo = {
  __typename?: 'Experimental_WebAdCreativeInfo';
  /** Type of ad product from AAX */
  aaxAdType?: Maybe<Scalars['String']['output']>;
  /** Ad product type information */
  adProductType?: Maybe<Experimental_AdProductType>;
  /** ID of the creative (for debugging) */
  creativeId?: Maybe<Scalars['String']['output']>;
  /** Flag that determines if the app slot is eligible to render 3p ad. */
  isEligibleFor3pAd: Scalars['Boolean']['output'];
  /** Flag that determines if the slot is eligible for automatic ad refresh. */
  isEligibleForRefresh: Scalars['Boolean']['output'];
  /** Flag used to communicate if the ad returned is premium. */
  isPremium: Scalars['Boolean']['output'];
  /** Height and width of the returned creative */
  size: CreativeSize;
  /** HTML markup for the slot containing the ad creative */
  slotMarkup: Scalars['String']['output'];
};

/** AdSlot with additional web fields. Can be merged back into single AdSlot definition when finalizing webAdsConfig */
export type Experimental_WebAdSlot = {
  __typename?: 'Experimental_WebAdSlot';
  /** Ad feedback URL to be linked in the sponsored label of the ad */
  adFeedbackUrl?: Maybe<Scalars['URL']['output']>;
  /** The creative metadata and slotsMarkup returned for the given ad slot */
  creativeInfo: Experimental_WebAdCreativeInfo;
  /** The name of the ad slot */
  name: Scalars['String']['output'];
};

/** Parameters specific to web ad targeting. */
export type Experimental_WebAdTargetingParameters = {
  /**
   * True if the client is requesting content that meets the AdBlockPlus Acceptable Ads program;
   * false if the request is for standard ad content.
   */
  abpAcceptable: Scalars['Boolean']['input'];
  /** The IMDb site variant on which the ads are intended to be shown. */
  site: Experimental_Site;
  /**
   * Mappings of requested ad slot names to requested ad slot sizes.
   * Required for non-mobile sites, but is optional in the schema.
   * The resolver is responsible for safely handling empty input.
   */
  slotSizeMap?: InputMaybe<Array<InputMaybe<Experimental_SlotSize>>>;
  /** URL of the page being targeted. */
  url?: InputMaybe<Scalars['URL']['input']>;
};

/** Output from the webAdsConfig operation containing all information needed to request ads */
export type Experimental_WebAdsConfigOutput = {
  __typename?: 'Experimental_WebAdsConfigOutput';
  /** Flag indicating if ad refresh is enabled */
  adRefreshEnabled: Scalars['Boolean']['output'];
  /** APS slot information for Amazon Publisher Services integration */
  apsSlotInfoMap: Array<Maybe<Experimental_ApsSlotInfo>>;
  /** Flag indicating if the page has premium ads */
  hasPremiumAd: Scalars['Boolean']['output'];
  /** HTML markup to be included in the head of the document */
  headerMarkup: Scalars['String']['output'];
  /** Plaid overrides for the page */
  plaidOverrides: Array<Maybe<Experimental_PlaidOverride>>;
  /** Breakpoint to ad size mappings for responsive AdSlot */
  responsiveSlotSizes: Array<Maybe<Experimental_WebResponsiveSlotSize>>;
  /** List of ad slots available on the page */
  slots: Array<Maybe<Experimental_WebAdSlot>>;
  /** Flag indicating if ad slots are enabled */
  slotsEnabled: Scalars['Boolean']['output'];
};

/** Parameters used to make an ad request for web pages. */
export type Experimental_WebAdsInput = {
  /**
   * A set of parameters needed from web clients to target ads.
   * These parameters include page type, subpage type, and other targeting information.
   */
  adParameters: AdParametersWeb;
  /** A set of parameters specific to web ad targeting. */
  adTargetingParameters: Experimental_WebAdTargetingParameters;
  /** A set of parameters used to target display ads across all site variants. */
  displayAdTargetingParameters: DisplayAdTargetingParameters;
};

/** Output for the webAds query. */
export type Experimental_WebAdsOutput = {
  __typename?: 'Experimental_WebAdsOutput';
  /** Flag indicating if any premium ads are present. */
  hasPremiumAd: Scalars['Boolean']['output'];
  /** Flag indicating if request was for automatic ad refresh. */
  isRefreshRequest: Scalars['Boolean']['output'];
  /** Mapping of slots with resizing re-fetch disabled to their blocked breakpoints. */
  responsiveResizingDisabledSlots?: Maybe<Array<Maybe<Experimental_WebResponsiveResizingDisabledSlot>>>;
  /** A list of ad slots and their creative info. */
  slots: Array<Maybe<Experimental_WebAdSlot>>;
};

/** Viewport breakpoint with disabled flag. */
export type Experimental_WebResponsiveResizingDisabledBreakpoint = {
  __typename?: 'Experimental_WebResponsiveResizingDisabledBreakpoint';
  /** The width in pixels of the breakpoint. */
  breakpoint: Scalars['Int']['output'];
  /** Whether responsive resizing is disabled for this breakpoint. */
  disabled: Scalars['Boolean']['output'];
};

/** Slot with responsive resizing disabled. */
export type Experimental_WebResponsiveResizingDisabledSlot = {
  __typename?: 'Experimental_WebResponsiveResizingDisabledSlot';
  /** The breakpoints for which responsive resizing is disabled. */
  breakpoints: Array<Maybe<Experimental_WebResponsiveResizingDisabledBreakpoint>>;
  /** The name of the slot. */
  name: Scalars['String']['output'];
};

/** Mapping between slot names and their size configurations for different viewport breakpoints */
export type Experimental_WebResponsiveSlotSize = {
  __typename?: 'Experimental_WebResponsiveSlotSize';
  /** List of viewport breakpoints and corresponding ad sizes */
  breakpoints: Array<Maybe<Experimental_WebViewportBreakpointSlotSize>>;
  /** The name of the ad slot */
  slotName: Scalars['String']['output'];
};

/** Viewport breakpoint configuration for responsive ad sizing */
export type Experimental_WebViewportBreakpointSlotSize = {
  __typename?: 'Experimental_WebViewportBreakpointSlotSize';
  /** The name of the breakpoint (e.g., desktop, tablet, mobile) */
  breakpoint: Scalars['String']['output'];
  /** The ad size for this breakpoint (e.g., 728x90) */
  slotSize: CreativeSize;
};

export enum ExplicitContentFilter {
  /** Remove names that are flagged as adult from the results, this is the default */
  ExcludeAdult = 'EXCLUDE_ADULT',
  /** Allow names that are flagged as adult to be included in results */
  IncludeAdult = 'INCLUDE_ADULT',
  /** Only allow names that are flagged as adult */
  OnlyAdult = 'ONLY_ADULT'
}

export type ExplicitContentSearchConstraint = {
  /**
   * Allow titles that are flagged as adult to be included in results
   * By default, no titles flagged as adult will be matched
   */
  explicitContentFilter?: InputMaybe<ExplicitContentFilter>;
};

export type ExportDetail = {
  /**
   * The date when the export becomes unavailable.
   * After this date, the export will no longer be returned by the backend.
   */
  expiresOn?: Maybe<Scalars['DateTime']['output']>;
  exportType: ExportType;
  resultUrl?: Maybe<Scalars['URL']['output']>;
  startedOn: Scalars['DateTime']['output'];
  status: ExportStatus;
  /** number of objects in the export */
  totalExportedObjects?: Maybe<Scalars['Int']['output']>;
};

export type ExportDetailConnection = {
  __typename?: 'ExportDetailConnection';
  edges: Array<Maybe<ExportDetailEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type ExportDetailEdge = {
  __typename?: 'ExportDetailEdge';
  cursor: Scalars['ID']['output'];
  node: ExportDetail;
};

export type ExportFilterByInput = {
  status?: InputMaybe<Array<InputMaybe<ExportStatusId>>>;
};

export enum ExportSortByField {
  StartedOn = 'STARTED_ON'
}

export type ExportSortByInput = {
  by: ExportSortByField;
  order: SortOrder;
};

export type ExportStatus = {
  __typename?: 'ExportStatus';
  id?: Maybe<ExportStatusId>;
  name?: Maybe<ExportStatusName>;
};

export enum ExportStatusId {
  /** Indicates there's an existing export for the request and it has failed. */
  Failed = 'FAILED',
  /** Indicates there's an existing export for the request and it's in progress. */
  Processing = 'PROCESSING',
  /** Indicates there's an existing export for the request and it has finished successfully. */
  Ready = 'READY',
  /**
   * Indicates there's an existing export for the request and it has failed due to
   * the requester not having access to the requested resource.
   *
   * This state is typically unexpected since users are generally expected to have
   * the necessary access to the list/ratings before requesting an export. However,
   * it can occur in unusual cases, such as when there is a change in list
   * permissions immediately before the export starts or if a user issues GraphQL
   * queries directly without proper access to the resource.
   */
  Unauthorized = 'UNAUTHORIZED'
}

export type ExportStatusName = {
  __typename?: 'ExportStatusName';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export enum ExportType {
  List = 'LIST',
  Ratings = 'RATINGS'
}

/** External link details */
export type ExternalLink = {
  __typename?: 'ExternalLink';
  /**
   * The external link as a displayable property
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  displayableProperty: DisplayableExternalLinkProperty;
  /**
   * The type of link
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  externalLinkCategory: ExternalLinkCategory;
  /**
   * The languages supported by the site
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  externalLinkLanguages?: Maybe<Array<Maybe<DisplayableLanguage>>>;
  /**
   * The user-supplied region of the site.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  externalLinkRegion?: Maybe<DisplayableCountry>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * The link's label
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  label?: Maybe<Scalars['String']['output']>;
  /**
   * The language of the link's label
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  labelLanguage?: Maybe<DisplayableLanguage>;
  /**
   * The URL of the site
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  url: Scalars['String']['output'];
};

/** External link type */
export type ExternalLinkCategory = {
  __typename?: 'ExternalLinkCategory';
  /** A token representing the link type. */
  id: Scalars['ID']['output'];
  /** Display text for the link type (e.g. 'Official Sites'). */
  text: Scalars['String']['output'];
};

export type ExternalLinkCategoryWithExternalLinks = {
  __typename?: 'ExternalLinkCategoryWithExternalLinks';
  category?: Maybe<ExternalLinkCategory>;
  externalLinks?: Maybe<ExternalLinkConnection>;
  restriction?: Maybe<ExternalLinkRestriction>;
};


export type ExternalLinkCategoryWithExternalLinksExternalLinksArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Group of external links from a single featured category */
export type ExternalLinkCategoryWithFeaturedExternalLinks = {
  __typename?: 'ExternalLinkCategoryWithFeaturedExternalLinks';
  /** Links in the featured category */
  externalLinks: Array<Maybe<ExternalLink>>;
  /** Featured category of external link */
  featuredCategory: ExternalLinkCategory;
};

/** Pagination for external link types which always has a known total number of edges. */
export type ExternalLinkConnection = {
  __typename?: 'ExternalLinkConnection';
  /** Pages of external links */
  edges: Array<Maybe<ExternalLinkEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  restriction?: Maybe<ExternalLinkRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of external links */
export type ExternalLinkEdge = {
  __typename?: 'ExternalLinkEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An External link node */
  node: ExternalLink;
  /** Position of the node in this context, eg: external link 4 out of 31 */
  position: Scalars['Int']['output'];
};

/** Information about restrictions applied to external links */
export type ExternalLinkRestriction = {
  __typename?: 'ExternalLinkRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

export type ExternalLinksFilter = {
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type FanPicksConnection = {
  __typename?: 'FanPicksConnection';
  edges: Array<Maybe<FanPicksEdge>>;
  pageInfo: PageInfo;
  refTag?: Maybe<RefTag>;
};

export type FanPicksEdge = {
  __typename?: 'FanPicksEdge';
  cursor: Scalars['ID']['output'];
  node: Title;
  position: Scalars['Int']['output'];
};

export type FanPicksFilter = {
  /**
   * Includes fan picks titles for below title type category values. At time of writing, fanPicksTitles() only
   * supports movie and tv title type categories, and can only support filtering for a single title type.
   */
  includeTitleTypes?: InputMaybe<Array<InputMaybe<TitleTypeCategoryValue>>>;
};

/** Faq details */
export type Faq = {
  __typename?: 'Faq';
  /** The answer text. Note that [not all questions have answers](https://www.imdb.com/title/tt10547784/quotes/qt4903101). */
  answer?: Maybe<Markdown>;
  /** FAQ ID */
  id: Scalars['ID']['output'];
  /** Is this faq item a spoiler */
  isSpoiler: Scalars['Boolean']['output'];
  /** The language in which the FAQ was written. Note that each question-answer pair has the same language. */
  language: DisplayableLanguage;
  /** The question text */
  question: Markdown;
};

/** Pagination for FAQ types which always has a known total number of edges. */
export type FaqConnection = {
  __typename?: 'FaqConnection';
  /** Pages of FAQs */
  edges: Array<Maybe<FaqEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Faqs */
export type FaqEdge = {
  __typename?: 'FaqEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A FAQ node */
  node: Faq;
  /** Position of the node in this context, eg: FAQ 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type FaqsFilter = {
  hasAnswer?: InputMaybe<Scalars['Boolean']['input']>;
  spoilers?: InputMaybe<FilterSpoilers>;
};

/**
 * Enum that includes values for filtering cinemas based on whether a user has marked a cinemas as a favorite.
 * Specifying this filter option will make the query personalized, so it will result in the query not being cached.
 */
export enum FavoriteFilterOption {
  /** Don't include cinemas that a user has marked as a favorite. */
  ExcludeFavorites = 'EXCLUDE_FAVORITES',
  /** Only include cinemas that a user has marked as a favorite. */
  OnlyFavorites = 'ONLY_FAVORITES'
}

export type FeatureAccess = {
  __typename?: 'FeatureAccess';
  /**
   * Signal that a customer can use the IMDb Pro App.
   * Pro app access does not correspond 1-1 to any specific entitled API, which is why this field is needed.
   *
   * Returns true if the customer can access the app, false if not.
   * Returns false if customer is logged out.
   *
   * Zuko does not support cache TTLs on customer-specific requests.
   * When true, it is acceptable to cache this field during a user's session.
   * When false, it is not acceptable to cache this field, so we do not withhold app access immediately after signup.
   *
   * @entitlement(PRO_PREMIUM)
   */
  proAppFunctionality: Scalars['Boolean']['output'];
  /**
   * Signal that a customer can use the IMDb Pro Basic functionality.
   * Pro basic functionality does not correspond 1-1 to any specific entitled API, which is why this field is needed.
   *
   * Returns true if the customer can access basic Pro features, false if not.
   * Returns false if customer is logged out.
   *
   * Zuko does not support cache TTLs on customer-specific requests.
   * When true, it is acceptable to cache this field during a user's session.
   * When false, it is not acceptable to cache this field, so we do not withhold access immediately after signup.
   *
   * @entitlement(PRO_BASIC)
   */
  proBasicFunctionality: Scalars['Boolean']['output'];
  /**
   * Signal that a customer can use the IMDb Pro Premium functionality.
   * Pro premium functionality does not correspond 1-1 to any specific entitled API, which is why this field is needed.
   *
   * Returns true if the customer can access premium Pro features, false if not.
   * Returns false if customer is logged out.
   *
   * Zuko does not support cache TTLs on customer-specific requests.
   * When true, it is acceptable to cache this field during a user's session.
   * When false, it is not acceptable to cache this field, so we do not withhold access immediately after signup.
   *
   * @entitlement(PRO_PREMIUM)
   */
  proPremiumFunctionality: Scalars['Boolean']['output'];
  /**
   * Signal that a customer should see Pro Premium upsells.
   * Returns true for users who should see premium upsells (those without PRO_PREMIUM entitlement).
   * Returns false for PRO_PREMIUM users who should not see upsells.
   * Returns true if customer is logged out.
   *
   * Zuko does not support cache TTLs on customer-specific requests.
   * When true, it is not acceptable to cache this field, so we do want to keep showing upsells immediately after signup.
   * When false, it is acceptable to cache this field during a user's session.
   *
   * @entitlement(PRO_PREMIUM)
   */
  showProPremiumUpsells: Scalars['Boolean']['output'];
};

export enum FeaturedImagesOption {
  /** Return everything except featured images for this name. */
  ExcludeFeatured = 'EXCLUDE_FEATURED',
  /** Only return featured images for this name. There can be a maximum of 6. */
  FeaturedOnly = 'FEATURED_ONLY'
}

export type FeedbackGiven = {
  __typename?: 'FeedbackGiven';
  /** Whether or not the user has given feedback for that feature */
  hasGivenFeedback: Scalars['Boolean']['output'];
};

export enum FeedbackGivenFeatureType {
  /** Consumer Advanced Search Results Page */
  ConsumerAdvancedSearchResults = 'CONSUMER_ADVANCED_SEARCH_RESULTS',
  /** Consumer Main Search Results Page */
  ConsumerMainSearchResults = 'CONSUMER_MAIN_SEARCH_RESULTS'
}

export type FeedbackGivenInput = {
  /** Feature type for whether or not feedback has been given for */
  featureType: FeedbackGivenFeatureType;
};

export type FileMetadata = {
  __typename?: 'FileMetadata';
  /** Presigned URL containing file for account data */
  accountDataURL: Scalars['URL']['output'];
  /** Date and time file was created */
  creationDate: Scalars['DateTime']['output'];
  /** Date and time file will expire */
  expirationDate: Scalars['DateTime']['output'];
  /** Name of file returned from data access process */
  name: Scalars['String']['output'];
  /** Formatted size of file */
  sizeLabel: LocalizedString;
};

/**
 * A film length or number of reels, or both, along with some flags and any attributes. For example, we could have a film
 * that used 3447 meters of film using 8.5 reels in the US and Canada.
 */
export type FilmLength = {
  __typename?: 'FilmLength';
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** The countries where this film length applies */
  countries?: Maybe<Array<Maybe<DisplayableCountry>>>;
  /** Film length as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationLocalizedProperty;
  /** The film length in meters */
  filmLength?: Maybe<Scalars['Float']['output']>;
  /** Indicates if a split reel is used */
  isSplitReel: Scalars['Boolean']['output'];
  /** The number of reels */
  numReels?: Maybe<Scalars['Float']['output']>;
};

/** Film lengths for this title. */
export type FilmLengths = {
  __typename?: 'FilmLengths';
  /** The list of film length items */
  items: Array<Maybe<FilmLength>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of film length items */
  total: Scalars['Int']['output'];
};

export type FilmingDates = {
  __typename?: 'FilmingDates';
  /** Displayable filming dates range from start to end date */
  dateRange?: Maybe<DisplayableDateRange>;
};

/** Pagination for FilmingDates types which always has a known total number of edges. */
export type FilmingDatesConnection = {
  __typename?: 'FilmingDatesConnection';
  /** Pages of FilmingDates */
  edges: Array<Maybe<FilmingDatesEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of FilmingDates */
export type FilmingDatesEdge = {
  __typename?: 'FilmingDatesEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A FilmingDates node */
  node: FilmingDates;
  /** Position of the node in this context, eg: FilmingDates 4 out of 31 */
  position: Scalars['Int']['output'];
};

/** Filming location details */
export type FilmingLocation = {
  __typename?: 'FilmingLocation';
  /**
   * Optional. A list of filming location attributes, can contain:
   * - Free text attributes e.g. { text: 'Butch in his car encounters Marsellus Wallace' }
   *
   * - Location properties e.g. { id: 'exterior', text: 'Exterior' }
   */
  attributes?: Maybe<Array<Maybe<DisplayableAttribute>>>;
  /** Filming location as displayable property */
  displayableProperty: DisplayableTitleFilmingLocationProperty;
  /** Filming location ID */
  id: Scalars['ID']['output'];
  /** Votes from users about whether this filming location is interesting. */
  interestScore: InterestScore;
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** The non-localized location, e.g. 'Los Alamos, New Mexico, USA' */
  location: Scalars['String']['output'];
  /** The filming location localized text */
  text: Scalars['String']['output'];
};


/** Filming location details */
export type FilmingLocationAttributesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for filming locations which always has a known total number of edges */
export type FilmingLocationConnection = {
  __typename?: 'FilmingLocationConnection';
  /** Pages of locations */
  edges: Array<Maybe<FilmingLocationEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<FilmingLocationRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of filming locations */
export type FilmingLocationEdge = {
  __typename?: 'FilmingLocationEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A filming location node */
  node: FilmingLocation;
  /** Position of the node in this context, eg: Location 3 out of 28 */
  position: Scalars['Int']['output'];
};

/** Information about restrictions applied to filming locations */
export type FilmingLocationRestriction = {
  __typename?: 'FilmingLocationRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

/**
 * Example: if you want to match titles of locations 'Los Angeles' OR 'Paris', PLUS
 * the title must contain 'Austin', specify anyKeywords: ['Los Angeles', 'Paris'] plus
 * allKeywords: ['Austin']
 */
export type FilmingLocationSearchConstraint = {
  /** A title match must contain ALL of these locations */
  allLocations?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these locations */
  anyLocations?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/**
 * The constraints here are combined (AND).
 *
 * example:
 *
 * filmographyConstraint: {
 *     allTitleIds: ["tt0133093", "tt0209144"],
 *     anyTitleIds: ["tt0457572", "tt2357547"]
 *     excludeTitleIds: ["tt0468569"]
 * }
 *
 * will match names that are credited in ("tt0133093" AND "tt0209144") AND ("tt0457572" OR "tt2357547") AND NOT "tt0468569"
 */
export type FilmographySearchConstraint = {
  /** A name match must be credited in ALL of these titles */
  allTitleIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** A name match must be credited in AT LEAST ONE of these titles */
  anyTitleIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * A name match must be credited in NONE of these titles
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeTitleIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Common enum for filtering options include/exclude/no filter(omitted) */
export enum FilterInclusion {
  Exclude = 'EXCLUDE',
  Include = 'INCLUDE'
}

export type FilterPlots = {
  spoilers?: InputMaybe<FilterSpoilers>;
  type?: InputMaybe<Array<InputMaybe<PlotType>>>;
};

export enum FilterSpoilers {
  ExcludeSpoilers = 'EXCLUDE_SPOILERS',
  SpoilersOnly = 'SPOILERS_ONLY'
}

export enum FilterVersions {
  AllVersions = 'ALL_VERSIONS',
  OriginalOnly = 'ORIGINAL_ONLY'
}

export type FloatRangeInput = {
  max?: InputMaybe<Scalars['Float']['input']>;
  min?: InputMaybe<Scalars['Float']['input']>;
};

/** Follow filter options. */
export type FollowFilter = {
  /**
   * Return followed entities meeting the specified type constraints.  If no
   * followTypeConstraints are specified, all FollowEntityTypes are returned.
   */
  followTypeConstraints?: InputMaybe<FollowTypeFilterConstraints>;
  /**
   * Return followed entities meeting the specified interest constraints. If no
   * interestConstraints are specified, all followed Interests are returned.
   */
  interestConstraints?: InputMaybe<FollowInterestFilterConstraints>;
};

export type FollowInterestFilterConstraints = {
  /** Match followed Interests matching any of the requested Interest IDs */
  anyInterestIds: Array<InputMaybe<Scalars['ID']['input']>>;
};

export type FollowSort = {
  by: FollowSortBy;
  order: SortOrder;
};

export enum FollowSortBy {
  /**
   * Sort entities based on their last updated time
   * DESC: Latest dates to earliest dates
   */
  LastUpdated = 'LAST_UPDATED'
}

export type FollowTypeFilterConstraints = {
  /** Match followed entities matching any of the requested types */
  anyFollowTypes: Array<InputMaybe<FollowedEntityType>>;
};

/** Pagination for followed entities, which always has a known total number of edges. */
export type FollowedEntitiesConnection = {
  __typename?: 'FollowedEntitiesConnection';
  /** A page of followed entities. */
  edges: Array<Maybe<FollowedEntitiesEdge>>;
  /** Details of the page. */
  pageInfo: PageInfo;
  /** Total number of followed entities in the entire set. */
  total: Scalars['Int']['output'];
};

/** Item in a page of followed entities. */
export type FollowedEntitiesEdge = {
  __typename?: 'FollowedEntitiesEdge';
  /** Cursor ID. */
  cursor: Scalars['ID']['output'];
  /** A followed entity node. */
  node: FollowedEntity;
  /** Position of this item in this context. */
  position: Scalars['Int']['output'];
};

/** Follow entity type union. */
export type FollowedEntity = Interest;

export enum FollowedEntityType {
  Interest = 'INTEREST'
}

export type FollowerStatistics = {
  __typename?: 'FollowerStatistics';
  /** Displayable Count of total number of users who have followed a followable entity */
  displayableCount: LocalizedDisplayableCount;
  /** The total number of users who have followed a followable entity */
  totalCount: Scalars['Int']['output'];
};

export type ForgotPasswordRedirectUrlInput = {
  /** Association handle of the login context i.e. imdb_us */
  associationHandle: Scalars['String']['input'];
};

export type ForgotPasswordRedirectUrlOutput = {
  __typename?: 'ForgotPasswordRedirectURLOutput';
  /** Redirect URL for user forgot password flow */
  redirectURL: Scalars['URL']['output'];
};

export enum Gender {
  Female = 'FEMALE',
  Male = 'MALE'
}

export type GenderIdentity = {
  __typename?: 'GenderIdentity';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type GenderIdentitySearchConstraint = {
  /** returns names that identify as ANY of the gender identities in the list */
  anyGender?: InputMaybe<Array<InputMaybe<NameGenderIdentity>>>;
  /**
   * returns names that identify as NONE of the gender identities in the list
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeGender?: InputMaybe<Array<InputMaybe<NameGenderIdentity>>>;
};

export type GenreItem = {
  __typename?: 'GenreItem';
  /** Genre as displayable property */
  displayableProperty: DisplayableTitleGenreProperty;
  /** A non-localized token representing the genre (e.g. 'Action'). */
  genreId: Scalars['String']['output'];
  /** An opaque unique identifier for the genre. */
  id: Scalars['ID']['output'];
  /** The language the text is written in */
  language: DisplayableLanguage;
  /** Display text for the genre (e.g. 'Action'). */
  text: Scalars['String']['output'];
};

/** Available genres https://tiny.amazon.com/1ch8tksjf/codeamazpackIMDbblobmainsrc */
export type GenreSearchConstraint = {
  /**
   * A title match must contain ALL of the specified genres.
   *
   * Number of genres specified should not exceed the optional `maxRelevantGenres` parameter.
   */
  allGenreIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain at least one of the specified genres */
  anyGenreIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Titles that include the specified genres will not be matched.
   *
   * Not affected by `maxRelevantGenres`.
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeGenreIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Specify a number as the n most relevant genres associated with a title to match against when also specifying
   * `allGenreIds` and/or `anyGenreIds`. For example, if you provide a maxRelevantGenres of 2, only the two most relevant
   * genres associated with a title will be considered for your search, and all others are ignored.
   *
   * Must be a postive non-zero number. Has no effect on `excludeGenreIds`. Has no effect if no genres are specified.
   * Throws GRAPHQL_VALIDATION_FAILED if `maxRelevantGenres` is lower than the number of genres specified under
   * `allGenreIds`
   */
  maxRelevantGenres?: InputMaybe<Scalars['Int']['input']>;
};

export type GenreSort = {
  by?: InputMaybe<GenreSortBy>;
  order?: InputMaybe<SortOrder>;
};

/** Default Sorting is currently alphabetical by English value */
export enum GenreSortBy {
  Default = 'DEFAULT',
  Relevance = 'RELEVANCE'
}

export type GenreSummary = {
  __typename?: 'GenreSummary';
  /** The genre */
  genre: GenreItem;
  /** The total number of credits for the genre */
  total: Scalars['Int']['output'];
};

export type GetExportsInput = {
  exportTypes: Array<InputMaybe<ExportType>>;
};

export type GetLatestUiWorkflowInput = {
  /** The unique identifier for a UIWorkflow execution */
  executionId: Scalars['ID']['input'];
};

/** Defines the output response type for the getLatestUIWorkflow query. */
export type GetLatestUiWorkflowOutput = {
  __typename?: 'GetLatestUIWorkflowOutput';
  /**
   * The latest server-driven UI workflow model stored by the service for the requested input.
   * In the future there may be other types of workflow such as a full-page workflow so for extensibility it is
   * optional.
   */
  workflow?: Maybe<UiWorkflow>;
};

export type GetNameWeightInput = {
  unit?: InputMaybe<WeightUnit>;
};

export type GetPlacementsInput = {
  /**
   * An optional set of page targeting criteria
   *
   * Symphony allows you to specify page targeting criteria in addition to container type, ID, and slot
   * Documentation: https://w.amazon.com/bin/view/ContentSymphony/UserGuide#HSchedulingplacements
   */
  additionalPageTargetingCriteria?: InputMaybe<Array<InputMaybe<SymphonyMultiValueMapEntry>>>;
  /**
   * The id of the Symphony container.
   * eg. tconst, nconst, home, india
   */
  containerId: Scalars['String']['input'];
  /**
   * The type of symphony container.
   * eg. imdb-app-title
   */
  containerType: Scalars['String']['input'];
  /**
   * An optional set of query params
   *
   * Symphony allows you to override content in the form of query params. This is useful for content creators
   * to preview new content, content in different languages, etc.
   * Documentation: https://w.amazon.com/bin/view/ContentSymphony/UserGuide#HPreviewingyourcontent
   */
  queryParams?: InputMaybe<Array<InputMaybe<SymphonyMultiValueMapEntry>>>;
  /**
   * An array of the slots to retrieve placements for.
   * eg. ["center-1", "center-2"]
   */
  slotNames: Array<InputMaybe<Scalars['String']['input']>>;
};

/** Details of a single goof */
export type Goof = {
  __typename?: 'Goof';
  category: GoofCategory;
  /** Goof as a displayable article */
  displayableArticle: DisplayableArticle;
  /** Goof ID */
  id: Scalars['ID']['output'];
  /** Votes from users about whether this goof item is interesting. */
  interestScore: InterestScore;
  /** Is this goof a spoiler */
  isSpoiler: Scalars['Boolean']['output'];
  /** The goof text */
  text: Markdown;
};

/** A category of goofs describing the nature of a subset of goofs, e.g. 'Continuity' */
export type GoofCategory = {
  __typename?: 'GoofCategory';
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

export type GoofCategoryWithGoofs = {
  __typename?: 'GoofCategoryWithGoofs';
  category: GoofCategory;
  goofs?: Maybe<GoofConnection>;
};


export type GoofCategoryWithGoofsGoofsArgs = {
  filter?: InputMaybe<GoofCategoryWithGoofsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type GoofCategoryWithGoofsFilter = {
  spoilers?: InputMaybe<FilterSpoilers>;
};

/** Pagination for Goof types which always has a known total number of edges. */
export type GoofConnection = {
  __typename?: 'GoofConnection';
  /** Pages of goofs */
  edges: Array<Maybe<GoofEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of goofs */
export type GoofEdge = {
  __typename?: 'GoofEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Goof node */
  node: Goof;
  /** Position of the node in this context, eg: Goof 4 out of 312 */
  position: Scalars['Int']['output'];
};

/**
 * Example: if you want to match titles of goof 'no handcuffs visible' OR 're-appear', PLUS
 * the title must contain 'military building', specify anyGoofTextTerms: ['no handuffs visible',
 *  're-appear'] plus allGoofsTextTerms: ['military building']. Note that this is term match rather than
 * phrase match, e.g., 'no handcuffs visible' would match titles that contain 'no handcuffs are visible'
 */
export type GoofMatchingSearchConstraint = {
  /** A title match must contain ALL of these search terms in at least one of its goofs. */
  allGoofTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these search terms in at least one of its goofs */
  anyGoofTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type GoofsFilter = {
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  spoilers?: InputMaybe<FilterSpoilers>;
};

export type GranularConsentRecord = {
  __typename?: 'GranularConsentRecord';
  /** User consent decision for this entity */
  consentOperation: ConsentOperation;
  /** Identifier for the entity (currently purpose or vendor) */
  id: Scalars['ID']['output'];
};

export type GranularDirective = {
  __typename?: 'GranularDirective';
  /** Whether or not to allow a given action for this entity */
  allow: Scalars['Boolean']['output'];
  /** Identifier for the entity (currently purpose or vendor) */
  id: Scalars['ID']['output'];
};

/** Input object for specifying how the grouping name should be displayed. */
export type GroupingTextInput = {
  /**
   * Specifies the text format to return.
   * Supported values:
   * - 'DEFAULT' (example: "Director")
   * - 'SHORT' (example: "Dir.")
   *
   * If omitted, defaults to 'DEFAULT'.
   */
  format: Scalars['String']['input'];
};

/** Page of guild affilation */
export type GuildAffiliationEdge = {
  __typename?: 'GuildAffiliationEdge';
  cursor: Scalars['ID']['output'];
  node: GuildAffiliationVerificationStatus;
  /** Position of this item in this context. */
  position: Scalars['Int']['output'];
};

/** The guild affiliation that includes the Company and verification status */
export type GuildAffiliationVerificationStatus = {
  __typename?: 'GuildAffiliationVerificationStatus';
  /** The company that represents the guild */
  company: Company;
  /** Whether this affiliation has been verified by the guild */
  isVerifiedByGuild: Scalars['Boolean']['output'];
};

/** Pagination for the list of visibility settings for guilds a name is affiliated with */
export type GuildAffiliationVisibilitiesConnection = {
  __typename?: 'GuildAffiliationVisibilitiesConnection';
  edges: Array<Maybe<GuildAffiliationVisibilitiesEdge>>;
  pageInfo: PageInfo;
  /** Total number of guilds affiliated with this name */
  total: Scalars['Int']['output'];
};

/** Page of guild affiliation visibilities */
export type GuildAffiliationVisibilitiesEdge = {
  __typename?: 'GuildAffiliationVisibilitiesEdge';
  cursor: Scalars['ID']['output'];
  node: GuildAffiliationVisibilityStatus;
  /** Position of this item in this context */
  position: Scalars['Int']['output'];
};

/** The visibility setting for guild affiliations */
export enum GuildAffiliationVisibilityLevel {
  /** Visible on IMDbPro only */
  ImdbProOnly = 'IMDB_PRO_ONLY',
  /** Publicly visible */
  Public = 'PUBLIC'
}

/** The visibility configured for a specific guild affiliation company for a name */
export type GuildAffiliationVisibilityStatus = {
  __typename?: 'GuildAffiliationVisibilityStatus';
  /** The company that represents the guild */
  company: Company;
  /** The visibility level configured for the guild */
  visibility: GuildAffiliationVisibilityLevel;
};

/** Pagination for the list of affiliated guilds */
export type GuildAffiliationsConnection = {
  __typename?: 'GuildAffiliationsConnection';
  edges: Array<Maybe<GuildAffiliationEdge>>;
  pageInfo: PageInfo;
  /** Total number of affiliated guilds */
  total: Scalars['Int']['output'];
};

/** Filter to specify the data verification type to include */
export type GuildAffiliationsFilter = {
  includeDataVerificationTypes?: InputMaybe<Array<InputMaybe<GuildDataVerificationType>>>;
};

/** The different verification types for guild data */
export enum GuildDataVerificationType {
  /** The data has been verified by the customer */
  SelfVerified = 'SELF_VERIFIED',
  /** The data has been verified by a third party */
  ThirdPartyVerified = 'THIRD_PARTY_VERIFIED'
}

export type GuildMembershipDetail = {
  __typename?: 'GuildMembershipDetail';
  /** The company that represents the guild */
  company: Company;
  /** The membershipId of the customer associated with the guild */
  membershipId: Scalars['String']['output'];
};

/** Additional metadata describing guild status */
export type GuildStatus = {
  __typename?: 'GuildStatus';
  /** Whether or not the name is Actra Apprentice */
  isActraApprentice?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not the name is non-union */
  isNonUnion?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not the name is SAG eligible */
  isSagEligible?: Maybe<Scalars['Boolean']['output']>;
};

/**
 * Defines a link to a help article.
 * Clients can show a relevant help icon such as a question mark, based on its type.
 */
export type HelpLink = {
  __typename?: 'HelpLink';
  /** The localized label for the link, for example 'See help guide' */
  label: LocalizedString;
  /**
   * The URL target for the link.
   * E.g. https://help.imdb.com/article/contribution/contribution-information/user-review-guidelines/GABTWSNLDNFLPRRH
   */
  url: Scalars['URL']['output'];
};

export type Histogram = {
  __typename?: 'Histogram';
  demographic: Demographic;
  histogramValues: Array<Maybe<HistogramValues>>;
};

export type HistogramValues = {
  __typename?: 'HistogramValues';
  rating: Scalars['Int']['output'];
  voteCount: Scalars['Int']['output'];
};

/**
 * Image type
 * Extends external type.
 */
export type Image = {
  __typename?: 'Image';
  /**
   * Image caption text
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  caption?: Maybe<Markdown>;
  /**
   * Image copyright text
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  copyright?: Maybe<Scalars['String']['output']>;
  /**
   * Returns the 'correct this image' Link.
   * Will be null if there is no correction Link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  correctionLink?: Maybe<ContributionLink>;
  /**
   * Countries associated with the image
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  countries?: Maybe<Array<Maybe<DisplayableCountry>>>;
  /**
   * The creator of the image
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  createdBy?: Maybe<Scalars['String']['output']>;
  /**
   * Date the photo was created
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  createdOn?: Maybe<DisplayableDate>;
  /**
   * Original height of the image resource, in pixels
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  height?: Maybe<Scalars['Int']['output']>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  id: Scalars['ID']['output'];
  /**
   * Languages of text in the image
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  languages?: Maybe<Array<Maybe<DisplayableLanguage>>>;
  /**
   * Name IDs for people in the image
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  names?: Maybe<Array<Maybe<Name>>>;
  /**
   * Returns the 'report this image' Link.
   * Will be null if there is no report Link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  reportingLink?: Maybe<ContributionLink>;
  /**
   * Image source and attribution data
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  source?: Maybe<Source>;
  /**
   * Title IDs for titles related to the image
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  titles?: Maybe<Array<Maybe<Title>>>;
  /**
   * Image type token
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  type?: Maybe<Scalars['String']['output']>;
  /**
   * URL for the image resource
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  url?: Maybe<Scalars['String']['output']>;
  /**
   * Original width of the image resource, in pixels
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  width?: Maybe<Scalars['Int']['output']>;
};


/**
 * Image type
 * Extends external type.
 */
export type ImageCorrectionLinkArgs = {
  contributionContext: ContributionContext;
  relatedId?: InputMaybe<Scalars['ID']['input']>;
};


/**
 * Image type
 * Extends external type.
 */
export type ImageCountriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Image type
 * Extends external type.
 */
export type ImageLanguagesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Image type
 * Extends external type.
 */
export type ImageNamesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Image type
 * Extends external type.
 */
export type ImageReportingLinkArgs = {
  contributionContext: ContributionContext;
  relatedId?: InputMaybe<Scalars['ID']['input']>;
};


/**
 * Image type
 * Extends external type.
 */
export type ImageTitlesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type ImageAndLinkCallToAction = {
  __typename?: 'ImageAndLinkCallToAction';
  /** Contains the action link data */
  action: ActionLink;
  /** Provides data for background image resource. */
  backgroundImage?: Maybe<CallToActionImage>;
  /**
   * An identifier for the returned result of a CTA.
   * A CTA will have multiple potential results, with each result having its own identifier.
   * This value is only unique within the CTA. It is not globally unique.
   * The resultId can be used as resultOverride input argument to specify a specific result
   * should be returned for the requested CTA.
   */
  resultId: Scalars['ResultID']['output'];
};

/** Pagination for Image types which always has a known total number of edges. */
export type ImageConnection = {
  __typename?: 'ImageConnection';
  edges: Array<Maybe<ImageEdge>>;
  /** Indicates the possible image facets available for filtering on */
  facets?: Maybe<ImageFacets>;
  /** Indicates that image collection was changed, pagination result might be outdated if true */
  isPaginationDirty?: Maybe<Scalars['Boolean']['output']>;
  pageInfo: PageInfo;
  restriction?: Maybe<ImageRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type ImageEdge = {
  __typename?: 'ImageEdge';
  cursor: Scalars['ID']['output'];
  node: Image;
  /** Position of the node in this context. eg: Image 4 out of 312 */
  position: Scalars['Int']['output'];
};

export type ImageEditParameters = {
  __typename?: 'ImageEditParameters';
  /** The cropping parameters to be applied to this name page's primary image */
  cropBox?: Maybe<CroppingParameters>;
  /** The degree (0-360) by which the image should be rotated for display */
  rotation?: Maybe<Scalars['Float']['output']>;
};

export type ImageFacets = {
  __typename?: 'ImageFacets';
  /** Paginatable list of galleries related to this const's images, with associated count of how many images match */
  galleries?: Maybe<ImageGalleryFacetConnection>;
  /** Paginatable list of names related to this const's images, with associated count of how many images match */
  names?: Maybe<NameFacetConnection>;
  /** Paginatable list of titles related to this const's images, with associated count of how many images match */
  titles?: Maybe<TitleFacetConnection>;
  /** Image types with counts of how many images are of that type, sorted by their counts in descending order */
  types?: Maybe<Array<Maybe<ImageTypeFacet>>>;
};


export type ImageFacetsGalleriesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ImageFacetsNamesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ImageFacetsTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ImageFacetsTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** File type of the image asset */
export enum ImageFileType {
  Jpg = 'JPG',
  Png = 'PNG',
  Svg = 'SVG'
}

export type ImageGallery = {
  __typename?: 'ImageGallery';
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  galleryText?: Maybe<Scalars['String']['output']>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  images?: Maybe<ImageConnection>;
};


export type ImageGalleryImagesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  bust?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ImagesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for Image gallery facets */
export type ImageGalleryFacetConnection = {
  __typename?: 'ImageGalleryFacetConnection';
  edges: Array<Maybe<ImageGalleryFacetEdge>>;
  pageInfo: PageInfo;
  /** Provides information on the total number of galleries you could filter on */
  total: Scalars['Int']['output'];
};

export type ImageGalleryFacetEdge = {
  __typename?: 'ImageGalleryFacetEdge';
  cursor: Scalars['ID']['output'];
  node: ImageGallery;
  position: Scalars['Int']['output'];
  /** How many items are associated with this image gallery node */
  total: Scalars['Int']['output'];
};

export type ImageGalleryFilterConstraints = {
  /** Match images appearing in all of the requested galleries */
  allGalleryIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Match images appearing in any of the requested galleries */
  anyGalleryIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type ImageNameFilterConstraints = {
  /** Match images featuring all of the requested names */
  allNameIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Match images featuring any of the requested names */
  anyNameIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Information about restrictions applied to images */
export type ImageRestriction = {
  __typename?: 'ImageRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

export type ImageTitleFilterConstraints = {
  /** Match images related to all of the requested titles */
  allTitleIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Match images related to any of the requested titles */
  anyTitleIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/**
 * An ImageType provides meta information describing the type of a given image,
 * such as whether it is a Poster or a photo from an Event.
 * It includes a localized display label as well as a canonical non-localized imageTypeID,
 * that can be used as input to image filter APIs.
 */
export type ImageType = {
  __typename?: 'ImageType';
  /** An opaque ID for this localized concept */
  id: Scalars['ID']['output'];
  /** The canonical ID for this image type, for use as inputs to other fields, e.g. still_frame */
  imageTypeId: Scalars['String']['output'];
  /** The language of the display label returned in the text field */
  language: DisplayableLanguage;
  /** The display label for the image type, such as Still Frame */
  text: Scalars['String']['output'];
};

/** Provides information on how many images in a gallery match the specified image type */
export type ImageTypeFacet = {
  __typename?: 'ImageTypeFacet';
  /** Number of images of this type */
  total: Scalars['Int']['output'];
  /** Image Type information including display label */
  type: ImageType;
};

export type ImageTypeWithImages = {
  __typename?: 'ImageTypeWithImages';
  /** The image type common for all of the associated images */
  imageType: ImageType;
  /** The first page of images in each category */
  images?: Maybe<ImageTypesConnection>;
};


export type ImageTypeWithImagesImagesArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for images by type, page info is intended for use with the related images field. */
export type ImageTypesConnection = {
  __typename?: 'ImageTypesConnection';
  edges: Array<Maybe<ImageEdge>>;
  pageInfo: PageInfo;
  restriction?: Maybe<ImageRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type ImagesFilter = {
  /** Return images meeting the specified gallery constraints */
  galleryConstraints?: InputMaybe<ImageGalleryFilterConstraints>;
  /** Return images meeting the specified name constraints */
  nameConstraints?: InputMaybe<ImageNameFilterConstraints>;
  /** Return only images tagged with at least a minimum and/or at most a maximum number of names */
  namesCount?: InputMaybe<CountInterval>;
  /** Return images meeting the specified title constraints */
  titleConstraints?: InputMaybe<ImageTitleFilterConstraints>;
  /** Return only images which are one of these types */
  types?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type InTheatersSearchConstraint = {
  /**
   * A title must have a showtime in a theater that has all the specified attributes.
   * When using this field, it is REQUIRED to use the Location field, or GRAPHQL_VALIDATION_FAILED will be thrown.
   */
  allTheaterAttributes?: InputMaybe<Array<InputMaybe<SearchTheaterAttribute>>>;
  /**
   * A title match must be showing in at least one of the specified theaters (e.g., `ci1234567`).
   * Throws GRAPHQL_VALIDATION_FAILED if more than 400 Cinema IDs are provided.
   * Throws GRAPHQL_VALIDATION_FAILED if both anyCinemaIds and location are provided.
   */
  anyCinemaIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * A title must have a showtime in a theater within the specified date/time range.
   * `start` and `end` must be provided in ISO-8601 format (e.g. `2025-06-19T17:35:25Z`).
   * If `dateTimeRange.end` is not provided, the `end` DateTime will default to `3000-01-01T00:00:00Z`.
   * When using this field, it is REQUIRED to use either the location field or the
   * anyCinemaIds field, otherwise GRAPHQL_VALIDATION_FAILED will be thrown.
   */
  dateTimeRange?: InputMaybe<ShowtimesTitlesDateTimeRangeFilter>;
  /**
   * A title match must have a showtime in a theater within the specified ShowtimesLocation.
   * Throws GRAPHQL_VALIDATION_FAILED if both anyCinemaIds and location are provided.
   */
  location?: InputMaybe<ShowtimesLocation>;
  /**
   * A title match must have a showtime in one of the theaters in the requesting user's favorite theaters list.
   * CustomerId is required and is determined by x-imdb-customer-id header (gateway determines from request).
   * Throws UNAUTHENTICATED if no CustomerId is provided.
   */
  myFavoriteTheaters?: InputMaybe<MyFavoriteTheaterSearchFilter>;
};

export type IntRangeInput = {
  max?: InputMaybe<Scalars['Int']['input']>;
  min?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * Represents an integer threshold constraint with an associated error feedback that can be evaluated client-side.
 * Clients should always treat the threshold as inclusive (ie minimum 5 would mean 5 is valid).
 * Used to express a numeric limit such as maximum words or minimum characters etc.
 */
export type IntThresholdValidationConstraint = {
  __typename?: 'IntThresholdValidationConstraint';
  /** The feedback to display to the customer related to the constraint. */
  feedback: ValidationFeedbackContent;
  /** The threshold value for validation (inclusive) */
  value: Scalars['Int']['output'];
};

/**
 * Interest type
 * Extends external type.
 */
export type Interest = {
  __typename?: 'Interest';
  /**
   * The Category for this specific interest.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  category?: Maybe<InterestCategory>;
  /**
   * The displayable description of this interest, e.g. 'Psycological horror is a subgenre of horror and psychological
   * fiction...'.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  description?: Maybe<LocalizedMarkdown>;
  /**
   * Return Engagement Statistics for an interest
   *
   * ---------------------
   * Graphlet Details:
   * - Name: engagementData
   * - CTI: IMDb/GraphQL/Engagement Data
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-core-tech
   */
  engagementStatistics?: Maybe<EngagementStatistics>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: engagementData
   * - CTI: IMDb/GraphQL/Engagement Data
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-core-tech
   */
  id: Scalars['ID']['output'];
  /**
   * The primary image for this interest.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  primaryImage?: Maybe<Image>;
  /**
   * The displayable primary descriptor of this interest, e.g. 'Psychological Horror'.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  primaryText?: Maybe<InterestText>;
  /**
   * The current score for this interest. A higher value is better.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  score?: Maybe<InterestImportanceScore>;
  /**
   * The displayable secondary descriptor of this interest, e.g. 'subgenre'.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  secondaryText?: Maybe<InterestText>;
  /**
   * Paginated list of similar interests. Sorted by the number of users following
   * the interest (most to least). Supports page size of at most 250.
   * Requesting a page size larger than the maximum supported will result in the maximum size being returned.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  similarInterests?: Maybe<InterestConnection>;
  /**
   * Visibility status of the interest
   *
   * Only when the below header values are satisfied
   *   x-imdb-internal-client == true and
   *   x-imdb-non-1p-client == false and
   *   x-imdb-client-name == 'imdb-search-indexer'
   * will we return both PUBLIC and HIDDEN interests
   * Otherwise, we will only return PUBLIC interests
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  visibilityLevel?: Maybe<InterestVisibilityLevel>;
};


/**
 * Interest type
 * Extends external type.
 */
export type InterestSimilarInterestsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};

/** Filter options for interest categories. */
export type InterestCategoriesFilter = {
  /** Filter for specific interest categories. Category IDs are ephemeral and invalid IDs will be ignored. */
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type InterestCategory = {
  __typename?: 'InterestCategory';
  /**
   * An opaque unique identifier for this InterestCategory.
   * This can be used in InterestCategoriesFilter.categories to refine an interestCategories query, but should be assumed
   * to be ephemeral like a pagination cursor.
   */
  id: Scalars['ID']['output'];
  /**
   * A paginated list of all interests in this category, sorted alphabetically. Supports page size of at most 250.
   * Requesting a page size larger than the maximum supported will result in the maximum size being returned.
   */
  interests?: Maybe<InterestConnection>;
  /** The language of the display text. */
  language: DisplayableLanguage;
  /** The displayable description of this category, e.g. 'Horror'. */
  text: Scalars['String']['output'];
};


export type InterestCategoryInterestsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};

/** Pagination for InterestCategory types which always has a known total number of edges. */
export type InterestCategoryConnection = {
  __typename?: 'InterestCategoryConnection';
  /** A page of InterestCategories. */
  edges: Array<Maybe<InterestCategoryEdge>>;
  /** Details of the page. */
  pageInfo: PageInfo;
  /** Total number of categories in the entire set. */
  total: Scalars['Int']['output'];
};

/** Item in a page of InterestCategories. */
export type InterestCategoryEdge = {
  __typename?: 'InterestCategoryEdge';
  /** Cursor ID. */
  cursor: Scalars['ID']['output'];
  /** An InterestCategory node. */
  node: InterestCategory;
};

/** Pagination for Interest types which always has a known total number of edges. */
export type InterestConnection = {
  __typename?: 'InterestConnection';
  /** A page of Interests. */
  edges: Array<Maybe<InterestEdge>>;
  /** Details of the page. */
  pageInfo: PageInfo;
  /** Total number of interests in the entire set. */
  total: Scalars['Int']['output'];
};

/** Item in a page of Interests. */
export type InterestEdge = {
  __typename?: 'InterestEdge';
  /** Cursor for this interest */
  cursor: Scalars['ID']['output'];
  /** The node for this interest. */
  node: Interest;
};

export type InterestImportanceScore = {
  __typename?: 'InterestImportanceScore';
  currentScore: Scalars['Int']['output'];
};

/** Votes from users about whether an item is interesting. */
export type InterestScore = {
  __typename?: 'InterestScore';
  /** The number of users who found this interesting. */
  usersInterested: Scalars['Int']['output'];
  /** The total number of users who have voted on this item being interesting or not. */
  usersVoted: Scalars['Int']['output'];
};

/** Pagination for interest search results. */
export type InterestSearchConnection = {
  __typename?: 'InterestSearchConnection';
  edges: Array<Maybe<InterestSearchEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

/**
 * Match titles based on their tagged interests.
 * Any combination of `all`, `any`, and `exclude` inputs can be specified.
 * Note that a title tagged with both an included and excluded interest would
 * still be excluded.
 */
export type InterestSearchConstraint = {
  /** A title match must contain ALL of the specified interests */
  allInterestIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** A title match must contain at least one of the specified interests */
  anyInterestIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Titles that include any of the specified interests will never be matched */
  excludeInterestIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Item in a page of interest search results. */
export type InterestSearchEdge = {
  __typename?: 'InterestSearchEdge';
  cursor: Scalars['ID']['output'];
  node: Interest;
};

export type InterestText = {
  __typename?: 'InterestText';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

/**
 * Visibility status of an interest
 *
 * PUBLIC means callers may expose the interest to the end user
 * HIDDEN means callers may get the data but may not expose the interest to the end user
 */
export enum InterestVisibilityLevel {
  Hidden = 'HIDDEN',
  Public = 'PUBLIC'
}

export type Interstitial = {
  __typename?: 'Interstitial';
  /**
   * Buttons to be rendered in the list order
   * Client should always render them at the bottom of the page/view
   */
  buttons: Array<Maybe<InterstitialButtonComponent>>;
  /**
   * UI components to be rendered in the list order
   * Currently, InterstitialButtonComponent are only returned in buttons field
   */
  components: Array<Maybe<InterstitialComponent>>;
};

export enum InterstitialButtonAction {
  /**
   * Convert an IMDb account that has existing LWA linkage to the authenticated Amazon account.
   * Client should call conversion mutation with just the Amazon token.
   */
  ConvertLwaToAap = 'CONVERT_LWA_TO_AAP',
  /**
   * Convert the authenticated IMDb account to the authenticated Amazon account.
   * Client should call conversion mutation with both tokens.
   */
  ConvertToAap = 'CONVERT_TO_AAP',
  /**
   * Create new IMDb account using authenticated Amazon account.
   * Client should proceed with new account creation.
   */
  CreateNewAccount = 'CREATE_NEW_ACCOUNT',
  /**
   * Start IMDb account linking process.
   * Client should initiate the IMDb authentication flow for linking.
   */
  LinkImdbAccount = 'LINK_IMDB_ACCOUNT',
  /**
   * Start IMDb account linking process.
   * Client should initiate the IMDb authentication flow for linking with a prefilled email.
   */
  LinkImdbAccountEmailPrefilled = 'LINK_IMDB_ACCOUNT_EMAIL_PREFILLED',
  /**
   * Return user to sign-in options.
   * Client should navigate to the main sign-in options page/screen.
   */
  ShowSignInOptions = 'SHOW_SIGN_IN_OPTIONS',
  /**
   * Redirect user to Amazon (AAP) sign-in flow.
   * Client should navigate to the Sign in with Amazon page/screen.
   * Used for standard Amazon account authentication.
   */
  SignInWithAmazon = 'SIGN_IN_WITH_AMAZON',
  /**
   * Redirect user to IMDb sign-in flow.
   * Client should navigate to the Sign in with IMDb page/screen.
   */
  SignInWithImdb = 'SIGN_IN_WITH_IMDB',
  /**
   * Redirect user to IMDb sign-in flow with a prefilled email.
   * Client should navigate to the Sign in with IMDb page/screen.
   */
  SignInWithImdbEmailPrefilled = 'SIGN_IN_WITH_IMDB_EMAIL_PREFILLED',
  /**
   * Redirect user to LWA sign-in flow.
   * Client should navigate to the Sign in with Amazon page/screen.
   * Used for third-party applications (e.g., IMDb) requiring Amazon authentication.
   */
  SignInWithLwa = 'SIGN_IN_WITH_LWA',
  /**
   * Sign out the current user.
   * Client should clear authentication state and return to unauthenticated state.
   */
  SignOut = 'SIGN_OUT'
}

/** Component representing an interactive button */
export type InterstitialButtonComponent = {
  __typename?: 'InterstitialButtonComponent';
  /** Action identifier for client handling when URL is not provided */
  action: InterstitialButtonAction;
  /** Button text */
  label: LocalizedString;
  /** Visual style of the button */
  style: InterstitialButtonStyle;
};

export enum InterstitialButtonStyle {
  /** Primary button - filled, emphasized style for main actions */
  Primary = 'PRIMARY',
  /** Secondary button - outlined style for alternative actions */
  Secondary = 'SECONDARY',
  /** Text button - transparent style for alternative actions */
  Text = 'TEXT'
}

/** Union of possible interstitial components */
export type InterstitialComponent = InterstitialButtonComponent | InterstitialConsumerAccountInfoComponent | InterstitialDialogComponent | InterstitialProAccountInfoComponent;

/** Component displaying account information being converted in Consumer flow */
export type InterstitialConsumerAccountInfoComponent = {
  __typename?: 'InterstitialConsumerAccountInfoComponent';
  /** User's first name, or nickname if no first name was provided */
  displayName: Scalars['String']['output'];
  /**
   * Email address associated with the IMDb account
   * Null if account conversion has partial failure (email was removed but conversion is not finished)
   * Client should render view without email when null
   */
  email?: Maybe<Scalars['String']['output']>;
  /**
   * Public profile information
   * Client should render user's profile image if available
   */
  profile: UserProfile;
};

/** Component displaying dialog content */
export type InterstitialDialogComponent = {
  __typename?: 'InterstitialDialogComponent';
  /** Visual style of the dialog */
  style?: Maybe<InterstitialDialogStyle>;
  /** Text content */
  text: LocalizedMarkdown;
};

export enum InterstitialDialogStyle {
  /**
   * Contained text - display text within a box
   * Used for highlighting important messages (e.g., highlighting account conversion text)
   */
  Box = 'BOX',
  /** Primary text - used for key information */
  Primary = 'PRIMARY',
  /** Secondary text - used for additional information (e.g., company trivia) */
  Secondary = 'SECONDARY',
  /** Title text - used for dialog titles */
  Title = 'TITLE'
}

/** Component displaying account information being converted in Pro flow */
export type InterstitialProAccountInfoComponent = {
  __typename?: 'InterstitialProAccountInfoComponent';
  /** User's full name, or nickname if no full name was provided */
  displayName: Scalars['String']['output'];
  /**
   * IMDbPro membership tier
   * Null if user does not have active IMDbPro subscription
   * Client should render view without membership tier when null
   */
  imdbProMembershipTier?: Maybe<LocalizedString>;
};

export type InvalidAuthProviderInterstitialInput = {
  /** Allows input of Google or Apple to activate the missing account page */
  type: AuthProviderType;
};

export type InvalidAuthProviderInterstitialOutput = {
  __typename?: 'InvalidAuthProviderInterstitialOutput';
  interstitial: Interstitial;
};

export type IsElementInList = {
  __typename?: 'IsElementInList';
  /** Returns true or false with respect to the presence of const in the list */
  isElementInList: Scalars['Boolean']['output'];
  /** Returns const id */
  itemElementId: Scalars['ID']['output'];
  /** The list items that contain the const id */
  itemIds: Array<Maybe<Scalars['ID']['output']>>;
};

export type JobCreditAttribute = CreditAttribute & {
  __typename?: 'JobCreditAttribute';
  id: Scalars['ID']['output'];
  job: Scalars['String']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

/** Filter options for company key staff */
export type KeyStaffFilter = {
  /** Filter by occupation IDs. Returns staff who have ANY of the specified occupations (OR logic) */
  occupations?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Input for sorting key staff */
export type KeyStaffSort = {
  /** Field to sort by */
  by: KeyStaffSortBy;
  /** Sort order */
  order: SortOrder;
};

/** Available fields for sorting key staff */
export enum KeyStaffSortBy {
  /** Sort by branch name alphabetically */
  Branch = 'BRANCH',
  /** Sort by job title/occupation alphabetically */
  JobTitle = 'JOB_TITLE',
  /** Sort by person's name alphabetically */
  Name = 'NAME',
  /** Sort by StarMeter ranking (lower rank number = better rank) */
  Starmeter = 'STARMETER'
}

export type Keyword = {
  __typename?: 'Keyword';
  /**
   * A category describing the nature of the keyword, e.g. 'plot related' or 'potentially offensive'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  category?: Maybe<KeywordCategory>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * The display data for a keyword
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  text?: Maybe<KeywordText>;
  /**
   * The associated titles for a keyword
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  titles?: Maybe<KeywordTitleConnection>;
};


export type KeywordTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Keyword Category details */
export type KeywordCategory = {
  __typename?: 'KeywordCategory';
  /** Category ID */
  id: Scalars['ID']['output'];
};

export type KeywordMetadata = {
  __typename?: 'KeywordMetadata';
  /** All the valid keyword categories */
  keywordCategories: Array<Maybe<KeywordCategory>>;
};


export type KeywordMetadataKeywordCategoriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * Example: if you want to match titles of sub-genre 'martial-arts' OR 'cyberpunk', AND
 * the title must contain 'cat' AND the title must NOT contain 'dog', specify anyKeywords: ['martial-arts', 'cyberpunk'],
 * allKeywords: ['cat'], and excludeKeywords: ['dog']
 */
export type KeywordSearchConstraint = {
  /** A title match must contain ALL of these keywords */
  allKeywords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these keywords */
  anyKeywords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * A title match must contain NONE of these keywords
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeKeywords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** The keyword itself. Can contain lower case characters and punctuation, but no uppercase characters or spaces. */
export type KeywordText = {
  __typename?: 'KeywordText';
  /** Keyword ID */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** Displayed keyword text */
  text: Scalars['String']['output'];
};

/** Pagination for Title types which always has a known total number of edges. */
export type KeywordTitleConnection = {
  __typename?: 'KeywordTitleConnection';
  /** Pages of titles */
  edges: Array<Maybe<KeywordTitleEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of titles */
export type KeywordTitleEdge = {
  __typename?: 'KeywordTitleEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Title node */
  node: Title;
  /** Position of the node in this context, eg: Title 4 out of 312 */
  position: Scalars['Int']['output'];
};

/** The known for source preference for a particular known for category for a company */
export enum KnownForPreference {
  /** Known for calculated using an algorithm */
  Automatic = 'AUTOMATIC',
  /** Custom overridden known for */
  Custom = 'CUSTOM'
}

export type KnownForV2 = {
  __typename?: 'KnownForV2';
  credits: Array<Maybe<CreditV2>>;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<NameKnownForRestriction>;
};

/** Laboratories for this title. */
export type Laboratories = {
  __typename?: 'Laboratories';
  /** The list of laboratory items */
  items: Array<Maybe<Laboratory>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of laboratory items */
  total: Scalars['Int']['output'];
};

/**
 * A lab used for a film, along with some flags and any attributes. For example, we could have a lab named ILM, which was
 * credited as Industrial Light & Magic, and used for developing specific sequences.
 */
export type Laboratory = {
  __typename?: 'Laboratory';
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** The name of the laboratory as credited */
  creditedAs?: Maybe<Scalars['String']['output']>;
  /** Laboratory as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationProperty;
  /** Indicates if the laboratory is uncredited */
  isUncredited: Scalars['Boolean']['output'];
  /** The laboratory */
  laboratory: Scalars['String']['output'];
};

/**
 * Language contribution guidelines:
 * https://help.imdb.com/article/contribution/titles/languages/GSCRBZYEH5NX5SXL
 */
export type LanguageSearchConstraint = {
  /**
   * Match titles that are spoken in ALL of these languages.
   * Language in ISO 639 codes (IMDbLocaleConfig:language_codes.json)
   * Example: To match titles that are spoken in Serbo-Croation AND Kriolu: ['qbo', 'qaq']
   */
  allLanguages?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Match titles that are spoken in AT LEAST ONE of these languages at all.
   * Language in ISO 639 codes (IMDbLocaleConfig:language_codes.json)
   * Example: To match titles that are spoken in Serbo-Croation or Kriolu: ['qbo', 'qaq']
   */
  anyLanguages?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Match titles that are primarily spoken in ONE of these languages.
   * Language in ISO 639 codes (IMDbLocaleConfig:language_codes.json)
   * Example: To match titles that are primarily spoken in Australian Sign Language or Brazilian Sign Language: ['asf', 'bfi']
   */
  anyPrimaryLanguages?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Exclude titles that are spoken in AT LEAST ONE of these languages.
   * Language in ISO 639 codes (IMDbLocaleConfig:language_codes.json)
   * Example: To match titles that are not spoken in Serbo-Croation or Kriolu: ['qbo', 'qaq']
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeLanguages?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Exclude titles that are primarily spoken in ONE of these languages.
   * Language in ISO 639 codes (IMDbLocaleConfig:language_codes.json)
   * Example: To match titles that are not primarily spoken in Australian Sign
   * Language or Brazilian Sign Language: ['asf', 'bfi']
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludePrimaryLanguages?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Match titles that are silent, or not silent. */
  isSilent?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Represents a location in the latitude/longitude format.
 * Values should not be more precise than one hundredth of a degree. More precise inputs will be
 * treated as invalid inputs.
 */
export type LatLong = {
  lat: Scalars['LocationDecimal']['input'];
  long: Scalars['LocationDecimal']['input'];
};

export type LatestTrailerFilter = {
  /**
   * The country field is an ISO 3166-1 alpha-2 country code (ex. US or GB).
   * Determine video eligibility based on the country.
   * If it is not set, it will default to US.
   */
  country?: InputMaybe<Scalars['String']['input']>;
  /**
   * Match trailers based on their maturity classification.
   * If it is not set, it will default to exclude all the mature videos.
   */
  maturityLevel?: InputMaybe<MaturityLevel>;
  /**
   * Prefer trailers whose audioLanguages include the preferredAudioLanguage.
   * If it is not set, it will default to en-US.
   */
  preferredAudioLanguage?: InputMaybe<Scalars['Language']['input']>;
};

export type LengthMeasurement = {
  __typename?: 'LengthMeasurement';
  /** Unit this measurement value is recorded in */
  unit?: Maybe<LengthUnit>;
  /** Numeric value for this measurement */
  value?: Maybe<Scalars['Float']['output']>;
};

export enum LengthUnit {
  Centimeter = 'CENTIMETER',
  Meter = 'METER'
}

export type LinkCallToAction = {
  __typename?: 'LinkCallToAction';
  /** Contains the action link data */
  action: ActionLink;
  /**
   * An identifier for the returned result of a CTA.
   * A CTA will have multiple potential results, with each result having its own identifier.
   * This value is only unique within the CTA. It is not globally unique.
   * The resultId can be used as resultOverride input argument to specify a specific result
   * should be returned for the requested CTA.
   */
  resultId: Scalars['ResultID']['output'];
};

export type LinkedAuthProvider = {
  __typename?: 'LinkedAuthProvider';
  /**
   * Returns a help message with an obfuscated email in regards to resetting a user's password for a certain deprecated linked auth provider.
   * A message is only returned if the auth provider link exists and the user has last logged in with that auth provider.
   * An empty response means no message needs to be shown.
   */
  deprecationMessage?: Maybe<AuthProviderDeprecationMessage>;
  /** Returns the type of 3rd party linked auth provider. */
  type: AuthProviderType;
};

/**
 * List Type
 * Entity for federation. Other implementing services can extend using field 'id'.
 * Non key fields are all marked as optional since this is a federation entity.
 */
export type List = {
  __typename?: 'List';
  /**
   * Are elements with id (e.g. tt1000, tt2000,  etc.,) present in this list
   * Multiple ids can be passed at a time. There's a limit of 10000 ids
   * If one of the id cant be checked then it throws an exception
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  areElementsInList?: Maybe<Array<Maybe<IsElementInList>>>;
  /**
   * Author of list.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  author?: Maybe<UserProfile>;
  /**
   * Created time
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  createdDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * List description
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  description?: Maybe<ListDescription>;
  /**
   * Unique id of list.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  id: Scalars['ID']['output'];
  /**
   * Is element with id (e.g. tt00000001, nm00000002) part of the list
   * Only supported for authenticated users at this time.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  isElementInList?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Gets whether the list is a predefined list.
   * Predefined User Lists have a ListClass of CHECK_INS, FAVORITE_ACTORS,
   * FAVORITE_THEATRES, NOT_INTERESTED, RESEARCH_NOTES, SEEN, or WATCH_LIST.
   * They are automatically created for a user, and cannot be deleted or renamed.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  isPredefined?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Returns list items by increasing position order.
   *
   * jumpTo: option for token-based pagination following IMDbCommonGraphletSchema standards. Jumps to a specific list item
   * ID and will return the "first" items starting with the provided item ID. If the provided item ID is not found, this
   * option will be ignored and will have the returned ListConnection's jumpToFound be false.
   * Will throw a BAD_USER_INPUT if used with after, last, before, or jumpToPosition.
   *
   * jumpToPosition: option for index-based pagination. Jumps to a particular numerical, positive contextual position in
   * the list (the position after taking ListItemFilter and ListItemSort into account), and will return the "first" items
   * starting at the provided position value. Item positions are one-based.
   * If the provided jumpToPosition is 1 and the list is empty, this option will be ignored and will have the returned
   * ListConnection's jumpToFound be false while returning the empty list of items.
   * Will throw a BAD_USER_INPUT if used with after, last, before, or jumpTo, or if there are no items at the provided
   * position.
   *
   * jumpToPosition should only be used when displaying only a single page at a time, and the entire list is not being
   * loaded into memory. We recommend clients to use the standard token-based pagination mechanism whenever possible.
   * This option is available to enable the following list features -
   * 1. The ability to have bookmarks / links to specific points in a list for editing
   * 2. The ability to grab list chunks in parallel
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  items?: Maybe<ListConnection>;
  /**
   * Last modified time
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  lastModifiedDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * List Class
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  listClass?: Maybe<ListClass>;
  /**
   * Get list interaction counts (views, shares) for a list, for each time range (ex: one week ago, all time).
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  listInteractionCounts?: Maybe<Array<Maybe<ListInteractionCounts>>>;
  /**
   * List Type
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  listType?: Maybe<ListType>;
  /**
   * List Name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  name?: Maybe<ListName>;
  /**
   * InvalidParameterErrors would be thrown for non-name lists.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  nameListItemSearch?: Maybe<NameListItemSearchConnection>;
  /**
   * Primary Image image for List
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  primaryImage?: Maybe<ListPrimaryImage>;
  /**
   * InvalidParameterErrors would be thrown for non-title lists.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  titleListItemSearch?: Maybe<TitleListItemSearchConnection>;
  /**
   * List Visibility
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  visibility?: Maybe<ListVisibility>;
};


/**
 * List Type
 * Entity for federation. Other implementing services can extend using field 'id'.
 * Non key fields are all marked as optional since this is a federation entity.
 */
export type ListAreElementsInListArgs = {
  itemElementIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


/**
 * List Type
 * Entity for federation. Other implementing services can extend using field 'id'.
 * Non key fields are all marked as optional since this is a federation entity.
 */
export type ListIsElementInListArgs = {
  itemElementId: Scalars['ID']['input'];
};


/**
 * List Type
 * Entity for federation. Other implementing services can extend using field 'id'.
 * Non key fields are all marked as optional since this is a federation entity.
 */
export type ListItemsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ListItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  jumpToPosition?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<ListItemSort>;
};


/**
 * List Type
 * Entity for federation. Other implementing services can extend using field 'id'.
 * Non key fields are all marked as optional since this is a federation entity.
 */
export type ListListInteractionCountsArgs = {
  timeRanges: Array<InputMaybe<ListInteractionCountTimeRange>>;
};


/**
 * List Type
 * Entity for federation. Other implementing services can extend using field 'id'.
 * Non key fields are all marked as optional since this is a federation entity.
 */
export type ListNameListItemSearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AdvancedNameSearchConstraints>;
  first: Scalars['Int']['input'];
  jumpToPosition?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<NameListSearchSort>;
};


/**
 * List Type
 * Entity for federation. Other implementing services can extend using field 'id'.
 * Non key fields are all marked as optional since this is a federation entity.
 */
export type ListTitleListItemSearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AdvancedTitleSearchConstraints>;
  first: Scalars['Int']['input'];
  jumpToPosition?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<TitleListSearchSort>;
};

export type ListClass = {
  __typename?: 'ListClass';
  id: ListClassId;
  name?: Maybe<ListClassName>;
};

/**
 * List classes.
 * Predefined Lists have a ListClassId of CHECK_INS, FAVORITE_ACTORS,
 * FAVORITE_THEATRES, NOT_INTERESTED, RESEARCH_NOTES, SEEN, or WATCH_LIST.
 */
export enum ListClassId {
  CheckIns = 'CHECK_INS',
  FavoriteActors = 'FAVORITE_ACTORS',
  FavoriteTheatres = 'FAVORITE_THEATRES',
  Internal = 'INTERNAL',
  List = 'LIST',
  ProList = 'PRO_LIST',
  ResearchNotes = 'RESEARCH_NOTES',
  WatchList = 'WATCH_LIST'
}

/**
 * The type of list
 * Ex: Watchlist, check ins list
 */
export type ListClassName = {
  __typename?: 'ListClassName';
  id: Scalars['ID']['output'];
  /** The language of the predefined list class name */
  language: DisplayableLanguage;
  /** The displayed predefined list class name */
  text: Scalars['String']['output'];
};

export type ListCollectionConnection = {
  __typename?: 'ListCollectionConnection';
  edges: Array<Maybe<ListCollectionEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type ListCollectionEdge = {
  __typename?: 'ListCollectionEdge';
  cursor: Scalars['ID']['output'];
  node: List;
  position: Scalars['Int']['output'];
};

/** A Connection which always has a known total number of edges. */
export type ListConnection = {
  __typename?: 'ListConnection';
  edges: Array<Maybe<ListItemEdge>>;
  /** Denotes whether the data in connection has been updated after the passed pagination token */
  isPaginationDirty?: Maybe<Scalars['Boolean']['output']>;
  /** Optional field returned if jumpTo param passed */
  jumpToFound?: Maybe<Scalars['Boolean']['output']>;
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type ListDescription = {
  __typename?: 'ListDescription';
  /**
   * Markdown text for list item description.
   * This field is editable by the list owner and is displayed under the item's image for each item on the list page.
   */
  originalText: Markdown;
};

export type ListExportDetail = ExportDetail & {
  __typename?: 'ListExportDetail';
  /**
   * The date when the export becomes unavailable.
   * After this date, the export will no longer be returned by the backend.
   */
  expiresOn?: Maybe<Scalars['DateTime']['output']>;
  exportType: ExportType;
  /** The metadata of the list being exported at the time of export request */
  listExportMetadata?: Maybe<ListExportMetadata>;
  resultUrl?: Maybe<Scalars['URL']['output']>;
  startedOn: Scalars['DateTime']['output'];
  status: ExportStatus;
  /** number of objects in the export */
  totalExportedObjects?: Maybe<Scalars['Int']['output']>;
};

export type ListExportMetadata = {
  __typename?: 'ListExportMetadata';
  /** Nickname of the user who created the list being exported */
  authorNickname: Scalars['String']['output'];
  /** The list ID */
  id: Scalars['ID']['output'];
  /** Class of the list */
  listClassId: ListClassId;
  /** Type of the list */
  listType: ListTypeId;
  /** Name of the list at the time of export request */
  name: Scalars['String']['output'];
  /** Primary image of the list at the time of export request */
  primaryImage?: Maybe<Image>;
};

/** Attribute Metadata for List Fields */
export type ListFieldAttributeMetadata = {
  __typename?: 'ListFieldAttributeMetadata';
  listDescription: ListTextFieldMetadata;
  listItemDescription: ListTextFieldMetadata;
  listName: ListTextFieldMetadata;
};

export type ListFilter = {
  /** Collection of listClass filters, e.g. WATCH_LIST */
  classTypes?: InputMaybe<Array<InputMaybe<ListClassId>>>;
  /** ListType filter, e.g. TITLES */
  listElementType?: InputMaybe<ListTypeId>;
};

/** Enum used for list interaction count ranges */
export enum ListInteractionCountTimeRange {
  AllTime = 'ALL_TIME',
  OneWeek = 'ONE_WEEK'
}

export type ListInteractionCounts = {
  __typename?: 'ListInteractionCounts';
  /** Number of clicks this list has, or 0 if none. */
  clicks: Scalars['Int']['output'];
  listId: Scalars['ID']['output'];
  /** List interactions for the specified time range. */
  timeRange: ListInteractionCountTimeRange;
  /** Number of views this list has, or 0 if none. */
  views: Scalars['Int']['output'];
};

/** List Item Union type */
export type ListItem = Cinema | Image | Name | Title | Video;

/** List Item Edge type */
export type ListItemEdge = {
  __typename?: 'ListItemEdge';
  /** Cursor for this item. */
  cursor: Scalars['ID']['output'];
  /** Item node. */
  node: ListItemNode;
  /** Item's contextual position in the list (i.e. after applying filtering and/or sorting). */
  position: Scalars['Int']['output'];
};

/** Filter options */
export type ListItemFilter = {
  /**
   * Filter Title items. Requires authentication.
   * INCLUDE restricts only to titles rated by authenticated user.
   * EXCLUDE filters out titles rated by authenticated user.
   */
  rated?: InputMaybe<FilterInclusion>;
  /**
   * Filter Title items.
   * INCLUDE restricts only to titles that have been released by current date.
   * EXCLUDE filters out titles released.
   */
  released?: InputMaybe<FilterInclusion>;
};

export type ListItemNode = {
  __typename?: 'ListItemNode';
  /**
   * Item's one-based position in the entire list before applying any sorting or filtering, i.e. its position in ascending LIST_ORDER ordering.
   * Will be present except for the ModifiedListOutput of removeElementFromList, removeElementFromPredefinedList, addItemToList, and addItemToPredefinedList.
   */
  absolutePosition?: Maybe<Scalars['Int']['output']>;
  /**
   * Created time
   * Will be present except for the ModifiedListOutput of removeElementFromList, removeElementFromPredefinedList, addItemToList, and addItemToPredefinedList
   */
  createdDate?: Maybe<Scalars['DateTime']['output']>;
  /** Description of the list */
  description?: Maybe<ListDescription>;
  /** Will be present except for the ModifiedListOutput of removeElementFromList and removeElementFromPredefinedList */
  itemId?: Maybe<Scalars['ID']['output']>;
  /**
   * Last modified time
   * Will be present except for the ModifiedListOutput of removeElementFromList, removeElementFromPredefinedList, addItemToList, and addItemToPredefinedList
   */
  lastModifiedDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The list item (title, name, video, image, cinema).
   * Videos can be nullable when returning geo-blocked videos (visible to users in one location but not another) or transient videos associated with marketing campaigns.
   * Cinemas can be nullable when the cinema has become inaccessible.
   */
  listItem?: Maybe<ListItem>;
};

export type ListItemSearchNode = {
  __typename?: 'ListItemSearchNode';
  /**
   * Item's one-based position in the entire list before applying any sorting or
   * filtering, i.e. its position in ascending LIST_ORDER ordering.
   * If this result set contains items from multiple lists, this will be each
   * item's position within its own list, so there could
   * be duplicate values in this field.
   */
  absolutePosition: Scalars['Int']['output'];
  createdDate?: Maybe<Scalars['DateTime']['output']>;
  description?: Maybe<ListDescription>;
  itemId: Scalars['ID']['output'];
  lastModifiedDate?: Maybe<Scalars['DateTime']['output']>;
};

/** Sort input for list items */
export type ListItemSort = {
  by?: InputMaybe<ListItemSortBy>;
  order?: InputMaybe<SortOrder>;
};

/** Enum for list item sort options */
export enum ListItemSortBy {
  CreatedDate = 'CREATED_DATE',
  ListOrder = 'LIST_ORDER',
  ModifiedDate = 'MODIFIED_DATE',
  Popularity = 'POPULARITY'
}

/** String Text */
export type ListName = {
  __typename?: 'ListName';
  /** Original text */
  originalText: Scalars['String']['output'];
};

export type ListPrimaryImage = {
  __typename?: 'ListPrimaryImage';
  image: Image;
};

/**
 * List filtering restriction. Matched entities must be in at least one of the
 * `inAnyList` lists and not in any of the `notInAnyList` lists.
 * Matched entities must also be in all of `inAllLists` lists. If multiple filters are provided entities returned
 * must satisfy all of the filters.
 *
 * Note the total count of the lsconsts, included in `inAnyList`, `notInAnyList`,
 * and `inAllLists`, must not exceed 10,000 (limit of OpenSearch).
 * If the total count exceeds 10,000 then `GRAPHQL_VALIDATION_FAILED` will be thrown.
 *
 * Note that IMDb supports lists of multiple list types: Titles, Names, etc -- if
 * a list specified here is of a type incompatible with the expected context
 * then `GRAPHQL_VALIDATION_FAILED` will be thrown.
 *
 * If the requesting user does not have permission to access any
 * list identified here then `FORBIDDEN` will be thrown.
 */
export type ListSearchConstraint = {
  /** Match entities that are in all of these lists, identified by ListIds. */
  inAllLists?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Match entities that are in all of these predefined lists.
   * Currently only allows for filtering by the predefined lists of the requesting user.
   */
  inAllPredefinedLists?: InputMaybe<Array<InputMaybe<PredefinedListInput>>>;
  /** Match entities that are in any of these lists, identified by ListIds. */
  inAnyList?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Match entities that are in any of these predefined lists.
   * Currently only allows for filtering by the predefined lists of the requesting user.
   */
  inAnyPredefinedList?: InputMaybe<Array<InputMaybe<PredefinedListInput>>>;
  /** Exclude entities that are in any of these lists, identified by ListIds. */
  notInAnyList?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Exclude entities that are in any of these predefined lists.
   * Currently only allows for filtering by the predefined lists of the requesting user.
   */
  notInAnyPredefinedList?: InputMaybe<Array<InputMaybe<PredefinedListInput>>>;
};

export type ListSearchFilter = {
  /** Collection of listClass filters, e.g. WATCH_LIST */
  anyClassTypes?: InputMaybe<Array<InputMaybe<ListClassId>>>;
  /** Collection of ListType filter, e.g. TITLES. */
  anyListTypes?: InputMaybe<Array<InputMaybe<ListTypeId>>>;
  /** Privacy status of List. */
  anyVisibilities?: InputMaybe<Array<InputMaybe<ListVisibilityId>>>;
};

export type ListSearchSort = {
  by: ListSearchSortBy;
  order: SortSearchOrder;
};

export enum ListSearchSortBy {
  /**
   * Date when the list was created
   * ASC: Earlier date will be first.
   */
  DateCreated = 'DATE_CREATED',
  /**
   * Date when the list was last modified
   * ASC: Earlier date will be first.
   */
  DateModified = 'DATE_MODIFIED',
  /**
   * List name, sort alphabetically
   * ASC: Aa-Zz
   */
  Name = 'NAME'
}

/** Sort input for lists */
export type ListSort = {
  by?: InputMaybe<ListSortBy>;
  order?: InputMaybe<SortOrder>;
};

/** Enum for list sort options */
export enum ListSortBy {
  ModifiedDate = 'MODIFIED_DATE',
  Name = 'NAME'
}

/** Attribute Metadata for a List Text Field */
export type ListTextFieldMetadata = {
  __typename?: 'ListTextFieldMetadata';
  maxCharacters: Scalars['Int']['output'];
};

export type ListType = {
  __typename?: 'ListType';
  id: ListTypeId;
};

export enum ListTypeId {
  Galleries = 'GALLERIES',
  Images = 'IMAGES',
  Lists = 'LISTS',
  People = 'PEOPLE',
  Theatres = 'THEATRES',
  Titles = 'TITLES',
  Videos = 'VIDEOS'
}

export type ListVisibility = {
  __typename?: 'ListVisibility';
  id?: Maybe<ListVisibilityId>;
  name?: Maybe<ListVisibilityName>;
};

export enum ListVisibilityId {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

export type ListVisibilityName = {
  __typename?: 'ListVisibilityName';
  id: Scalars['ID']['output'];
  /** The language of the list visibility name */
  language: DisplayableLanguage;
  /** The displayed list visibility name */
  text: Scalars['String']['output'];
};

export type LocalizedDisplayableCount = {
  __typename?: 'LocalizedDisplayableCount';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

/**
 * Generic type for a localized country, which has an ID or token, associated
 * display text, and the language of the display text
 */
export type LocalizedDisplayableCountry = {
  __typename?: 'LocalizedDisplayableCountry';
  /** The country code - either an ISO 3166 code or an internally defined code if no ISO code exists for that country. */
  id: Scalars['ID']['output'];
  /** The language of the display country */
  language: DisplayableLanguage;
  /** Display text for the country (e.g. 'United States'). */
  text: Scalars['String']['output'];
};

export type LocalizedDisplayableEpisodeNumber = {
  __typename?: 'LocalizedDisplayableEpisodeNumber';
  /** Episode number as a standardized displayableProperty */
  displayableProperty: EpisodeNumberDisplayableProperty;
  /**
   * Non localized episode number, can be used for sorting or filtering
   * Returns 'unknown' if episode number is unknown
   */
  episodeNumber: Scalars['String']['output'];
  /** An opaque unique identifier for the displayable episode. */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** The display text */
  text: Scalars['String']['output'];
};

export type LocalizedDisplayableEpisodeYear = {
  __typename?: 'LocalizedDisplayableEpisodeYear';
  /** Year as a standardized displayableProperty */
  displayableProperty: YearDisplayableProperty;
  /** An opaque unique identifier for the displayable year. */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** The display text */
  text: Scalars['String']['output'];
  /**
   * Non localized year, can be used for sorting or filtering
   * Returns 'unknown' if release year is unknown
   */
  year: Scalars['String']['output'];
};

export type LocalizedDisplayableSeason = {
  __typename?: 'LocalizedDisplayableSeason';
  /** Season number/text as a standardized displayableProperty */
  displayableProperty: SeasonValueDisplayableProperty;
  /** An opaque unique identifier for the displayable season. */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /**
   * Non localized Season, can be used for sorting or filtering
   * Returns 'unknown' if season is unknown
   */
  season: Scalars['String']['output'];
  /** The display text */
  text: Scalars['String']['output'];
};

/**
 * An object composed of a displayable localized markdown along with the language it is in.
 *
 * The language is determined by localization headers sent by the client, if the chosen language is available.
 * Otherwise an `en-US` string will likely be returned by default.
 *
 * More information on the x-imdb-user-country and x-imdb-user-language headers at
 * https://w.amazon.com/bin/view/IMDb/Zuko/Headers/
 */
export type LocalizedMarkdown = {
  __typename?: 'LocalizedMarkdown';
  /** The language of the returned markdown */
  language: Scalars['Language']['output'];
  /** The displayable localized markdown */
  value: Markdown;
};

/**
 * An object composed of a displayable localized string along with the language it is in.
 *
 * The language is determined by localization headers sent by the client, if the chosen language is available.
 * Otherwise an `en-US` string will likely be returned by default.
 *
 * More information on the x-imdb-user-country and x-imdb-user-language headers at
 * https://w.amazon.com/bin/view/IMDb/Zuko/Headers/
 */
export type LocalizedString = {
  __typename?: 'LocalizedString';
  /** The language of the returned string */
  language: Scalars['Language']['output'];
  /** The displayable localized string */
  value: Scalars['String']['output'];
};

export type Location = {
  __typename?: 'Location';
  /** The location/address string */
  id: Scalars['ID']['output'];
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** The localized text */
  text: Scalars['String']['output'];
};

export type LogoutRedirectUrlInput = {
  /** Association handle of the login context i.e. imdb_us */
  associationHandle: Scalars['String']['input'];
  /** Optional URL to return to post logout, defaults to home page */
  returnURL?: InputMaybe<Scalars['URL']['input']>;
};

export type LogoutRedirectUrlOutput = {
  __typename?: 'LogoutRedirectURLOutput';
  /** Redirect URL for user logout flow */
  redirectURL: Scalars['URL']['output'];
};

export type MainSearchConnection = {
  __typename?: 'MainSearchConnection';
  edges: Array<Maybe<MainSearchEdge>>;
  pageInfo: PageInfo;
};

export type MainSearchEdge = {
  __typename?: 'MainSearchEdge';
  cursor: Scalars['ID']['output'];
  node: MainSearchNode;
  position: Scalars['Int']['output'];
};

export type MainSearchEntity = Company | Interest | Keyword | Name | NameProfession | ProfessionCategory | Title;

export type MainSearchNode = {
  __typename?: 'MainSearchNode';
  entity: MainSearchEntity;
  id: Scalars['ID']['output'];
};

export type MainSearchOptions = {
  /**
   * Include titles and names in results that have been flagged as explicit.
   * By default explicit titles and names are omitted from results.
   */
  includeAdult?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Only return results that exactly match the search term.
   * By default an exact match is not required.
   */
  isExactMatch?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional filters to apply to searches including professions. */
  professionSearchOptions?: InputMaybe<ProfessionSearchOptions>;
  /** Term used to match against the names and akas of titles, names, keywords, and companies. */
  searchTerm: Scalars['String']['input'];
  /** Additional filters to apply to searches including titles. */
  titleSearchOptions?: InputMaybe<TitleSearchOptions>;
  /**
   * The types of IMDb entities to include in the search.
   * By default search results will only contain titles and names.
   */
  type?: InputMaybe<Array<InputMaybe<MainSearchType>>>;
};

export enum MainSearchTitleType {
  Movie = 'MOVIE',
  MusicVideo = 'MUSIC_VIDEO',
  PodcastEpisode = 'PODCAST_EPISODE',
  PodcastSeries = 'PODCAST_SERIES',
  Tv = 'TV',
  TvEpisode = 'TV_EPISODE',
  VideoGame = 'VIDEO_GAME'
}

export enum MainSearchType {
  Company = 'COMPANY',
  Interest = 'INTEREST',
  Keyword = 'KEYWORD',
  Name = 'NAME',
  Profession = 'PROFESSION',
  ProfessionCategory = 'PROFESSION_CATEGORY',
  Title = 'TITLE'
}

/** Client managed by a customer */
export type ManagedClient = {
  __typename?: 'ManagedClient';
  client: Name;
  status: ManagedClientStatus;
};

export enum ManagedClientStatus {
  /** Client is not being managed by this manager but can request to be */
  CanRequest = 'CAN_REQUEST',
  /** Client is being managed by this manager */
  Enabled = 'ENABLED',
  /** Client requested being managed by this manager */
  Requested = 'REQUESTED'
}

/** Data that company managers control, defined here since it is shared with multple files */
export type ManagedCompanyData = {
  __typename?: 'ManagedCompanyData';
  /** Company known for conrolled by managers of this company */
  knownFor?: Maybe<ManagedCompanyKnownForGroup>;
};

/** Company key staff that includes meta data needed to support managers. Intended for consumption by managers. */
export type ManagedCompanyKeyStaffCategory = {
  __typename?: 'ManagedCompanyKeyStaffCategory';
  /** Key staff of this company */
  staff: CompanyKeyStaffConnection;
  /** The status of the key staff for this company, e.g. active vs blocked. Defaults to active. */
  status: CompanyKnownForStatus;
};


/** Company key staff that includes meta data needed to support managers. Intended for consumption by managers. */
export type ManagedCompanyKeyStaffCategoryStaffArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Company key staff that company managers control */
export type ManagedCompanyKeyStaffGroup = {
  __typename?: 'ManagedCompanyKeyStaffGroup';
  /** Algorithmically calculated key staff for this company for consumption by company managers */
  automatic: ManagedCompanyKeyStaffCategory;
  /** History of changes to algorithmically calculated key staff for this company for consumption by IMDb admins */
  automaticHistory: ManagedCompanyKeyStaffHistory;
  /** Custom key staff controlled by managers of this company for consumption by those managers */
  custom: ManagedCompanyKeyStaffCategory;
  /** History of changes to custom key staff for this company for consumption by IMDb admins */
  customHistory: ManagedCompanyKeyStaffHistory;
  /** Source preference for key staf for this company, e.g. custom vs automatic. Defaults to automatic. */
  sourcePreference: KnownForPreference;
};

/** Company key staff history */
export type ManagedCompanyKeyStaffHistory = {
  __typename?: 'ManagedCompanyKeyStaffHistory';
  /** History of changes to key staff for this company */
  keyStaffHistory: ManagedCompanyKeyStaffHistoryConnection;
};


/** Company key staff history */
export type ManagedCompanyKeyStaffHistoryKeyStaffHistoryArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for managed company key staff version which always has a known total number of edges */
export type ManagedCompanyKeyStaffHistoryConnection = {
  __typename?: 'ManagedCompanyKeyStaffHistoryConnection';
  /** Pages of company key staff versions */
  edges: Array<Maybe<CompanyKeyStaffVersionEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Company known for client that includes meta data needed to support managers. Intended for consumption by managers. */
export type ManagedCompanyKnownForClientCategory = {
  __typename?: 'ManagedCompanyKnownForClientCategory';
  /** Clients this company is known for */
  clients: CompanyKnownForClientConnection;
  /** The status of the known for clients for this company, e.g. active vs blocked. Defaults to active. */
  status: CompanyKnownForStatus;
};


/** Company known for client that includes meta data needed to support managers. Intended for consumption by managers. */
export type ManagedCompanyKnownForClientCategoryClientsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Company known for client that company managers control */
export type ManagedCompanyKnownForClientGroup = {
  __typename?: 'ManagedCompanyKnownForClientGroup';
  /** Algorithmically calculated known for client for this company for consumption by company managers */
  automatic: ManagedCompanyKnownForClientCategory;
  /** History of changes to algorithmically calculated known for client for this company for consumption by IMDb admins */
  automaticHistory: ManagedCompanyKnownForClientHistory;
  /** Custom known for client controlled by managers of this company for consumption by those managers */
  custom: ManagedCompanyKnownForClientCategory;
  /** History of changes to custom known for client for this company for consumption by IMDb admins */
  customHistory: ManagedCompanyKnownForClientHistory;
  /** Source preference for known for client for this company, e.g. custom vs automatic. Defaults to automatic. */
  sourcePreference: KnownForPreference;
};

/** Company known for client history */
export type ManagedCompanyKnownForClientHistory = {
  __typename?: 'ManagedCompanyKnownForClientHistory';
  /** History of changes to known for client for this company */
  clientHistory: ManagedCompanyKnownForClientHistoryConnection;
};


/** Company known for client history */
export type ManagedCompanyKnownForClientHistoryClientHistoryArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for managed company known for client version which always has a known total number of edges */
export type ManagedCompanyKnownForClientHistoryConnection = {
  __typename?: 'ManagedCompanyKnownForClientHistoryConnection';
  /** Pages of company known for client versions */
  edges: Array<Maybe<CompanyKnownForClientVersionEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** A version snapshot of company known for client for consumption by IMDb admins */
export type ManagedCompanyKnownForClientVersion = {
  __typename?: 'ManagedCompanyKnownForClientVersion';
  /** The list of known for clients for this version snapshot */
  clients: CompanyKnownForClientConnection;
  /** The time that the known for client version for this company was created */
  createdDate: Scalars['Date']['output'];
  /** The user and role that modified the known for client version for this company if available */
  modifiedBy?: Maybe<ModifiedBy>;
  /** The status of known for client version for this company, e.g. active vs blocked. Defaults to active. */
  status: CompanyKnownForStatus;
  /** The version number for the known for client version for this company */
  versionNumber: Scalars['Int']['output'];
};


/** A version snapshot of company known for client for consumption by IMDb admins */
export type ManagedCompanyKnownForClientVersionClientsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Company known for that company managers control */
export type ManagedCompanyKnownForGroup = {
  __typename?: 'ManagedCompanyKnownForGroup';
  /** Group of key staff for this company */
  keyStaff: ManagedCompanyKeyStaffGroup;
  /** Group of known for client for this company */
  knownForClient: ManagedCompanyKnownForClientGroup;
  /** Group of known for title for this company */
  knownForTitle: ManagedCompanyKnownForTitleGroup;
};

/** A version snapshot of company key staff for consumption by IMDb admins */
export type ManagedCompanyKnownForKeyStaffVersion = {
  __typename?: 'ManagedCompanyKnownForKeyStaffVersion';
  /** The time that the key staff version for this company was created */
  createdDate: Scalars['Date']['output'];
  /** The user and role that modified the key staff version for this company if available */
  modifiedBy?: Maybe<ModifiedBy>;
  /** The list of key staff for this version snapshot */
  staff: CompanyKeyStaffConnection;
  /** The status of key staff version for this company, e.g. active vs blocked. Defaults to active. */
  status: CompanyKnownForStatus;
  /** The version number for the key staff version entry for this company */
  versionNumber: Scalars['Int']['output'];
};


/** A version snapshot of company key staff for consumption by IMDb admins */
export type ManagedCompanyKnownForKeyStaffVersionStaffArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Company known for title that includes meta data needed to support managers. Intended for consumption by managers. */
export type ManagedCompanyKnownForTitleCategory = {
  __typename?: 'ManagedCompanyKnownForTitleCategory';
  /** The status of the known for titles for this company, e.g. active vs blocked. Defaults to active. */
  status: CompanyKnownForStatus;
  /** Titles this company is known for */
  titles: CompanyKnownForTitleConnection;
};


/** Company known for title that includes meta data needed to support managers. Intended for consumption by managers. */
export type ManagedCompanyKnownForTitleCategoryTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Company known for title that company managers control */
export type ManagedCompanyKnownForTitleGroup = {
  __typename?: 'ManagedCompanyKnownForTitleGroup';
  /** Algorithmically calculated known for title for this company for consumption by company managers */
  automatic: ManagedCompanyKnownForTitleCategory;
  /** History of changes to algorithmically calculated known for title for this company for consumption by IMDb admins */
  automaticHistory: ManagedCompanyKnownForTitleHistory;
  /** Custom known for title controlled by managers for this company for consumption by those managers */
  custom: ManagedCompanyKnownForTitleCategory;
  /** History of changes to custom known for title for this company for consumption by IMDb admins */
  customHistory: ManagedCompanyKnownForTitleHistory;
  /** Source preference for known for title for this company, e.g. custom vs automatic. Defaults to automatic. */
  sourcePreference: KnownForPreference;
};

/** Company known for title history */
export type ManagedCompanyKnownForTitleHistory = {
  __typename?: 'ManagedCompanyKnownForTitleHistory';
  /** History of changes to known for title for this company */
  titleHistory: ManagedCompanyKnownForTitleHistoryConnection;
};


/** Company known for title history */
export type ManagedCompanyKnownForTitleHistoryTitleHistoryArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for managed company known for title version which always has a known total number of edges */
export type ManagedCompanyKnownForTitleHistoryConnection = {
  __typename?: 'ManagedCompanyKnownForTitleHistoryConnection';
  /** Pages of company known for title versions */
  edges: Array<Maybe<CompanyKnownForTitleVersionEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** A version snapshot of company known for title for consumption by IMDb admins */
export type ManagedCompanyKnownForTitleVersion = {
  __typename?: 'ManagedCompanyKnownForTitleVersion';
  /** The time that the known for title version for this company was created */
  createdDate: Scalars['Date']['output'];
  /** The user and role that modified the known title for version for this company if available */
  modifiedBy?: Maybe<ModifiedBy>;
  /** The status of known for title version for this company, e.g. active vs blocked. Defaults to active. */
  status: CompanyKnownForStatus;
  /** The list of known for titles for this version snapshot */
  titles: CompanyKnownForTitleConnection;
  /** The version number for the known for title version for this company */
  versionNumber: Scalars['Int']['output'];
};


/** A version snapshot of company known for title for consumption by IMDb admins */
export type ManagedCompanyKnownForTitleVersionTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Representative that manages a customer */
export type ManagingRepresentative = {
  __typename?: 'ManagingRepresentative';
  manager: Name;
  status: ManagingRepresentativeStatus;
};

export enum ManagingRepresentativeStatus {
  /** Representative is not managing a client */
  Disabled = 'DISABLED',
  /** Representative is managing a client */
  Enabled = 'ENABLED'
}

/**
 * Markdown type
 * Extends external type.
 */
export type Markdown = {
  __typename?: 'Markdown';
  /**
   * Returns strings with markdown with [link=titleNumber]...[/link] embedded with rendered markdown so that links could be
   * be displayed on mobile clients.
   *
   * e.g. '[link=tt0112022]' returns '[link=tt0112022]JAG (1995)[/link]'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: markdown
   * - CTI: IMDb/GraphQL/Markdown
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  expandedMarkdown: Scalars['String']['output'];
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  markdown: Scalars['String']['output'];
  /**
   * HTML optimized for PLAID. Renders consts as links with the const display text. Titles are localized according to localization headers.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: markdown
   * - CTI: IMDb/GraphQL/Markdown
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  plaidHtml?: Maybe<Scalars['String']['output']>;
  /**
   * The text with most formatting removed and const links replaced with const text. Titles are localized according to localization headers.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: markdown
   * - CTI: IMDb/GraphQL/Markdown
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  plainText?: Maybe<Scalars['String']['output']>;
  /**
   * List related entities in the markdown string.
   *
   * Note: this is limited to the first 100 entities in the markdown string.
   *
   * Ex:
   * renderedMarkdown(markdownString: "Remember [link=nm0001094] in [link=tt0062512]?") {
   *     relatedEntities {
   *         ... on Name { nameText { text }
   *  }
   *
   *         ... on Title { titleText { text }
   *  }
   *
   *     }
   *
   * }
   *
   *
   * ---------------------
   * Graphlet Details:
   * - Name: markdown
   * - CTI: IMDb/GraphQL/Markdown
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  relatedEntities?: Maybe<Array<Maybe<MarkdownEntity>>>;
};


/**
 * Markdown type
 * Extends external type.
 */
export type MarkdownExpandedMarkdownArgs = {
  showOriginalTitleText?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Markdown type
 * Extends external type.
 */
export type MarkdownPlaidHtmlArgs = {
  queryParams?: InputMaybe<Scalars['String']['input']>;
  showLineBreak?: InputMaybe<Scalars['Boolean']['input']>;
  showOriginalTitleText?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Markdown type
 * Extends external type.
 */
export type MarkdownPlainTextArgs = {
  showOriginalTitleText?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Markdown type
 * Extends external type.
 */
export type MarkdownRelatedEntitiesArgs = {
  limit: Scalars['Int']['input'];
};

export type MarkdownEntity = Company | Name | Title;

export type MarkdownSlotCallToAction = {
  __typename?: 'MarkdownSlotCallToAction';
  /** Specifies the localized markdown content for this CTA */
  markdown?: Maybe<LocalizedMarkdown>;
  /**
   * An identifier for the returned result of a CTA.
   * A CTA will have multiple potential results, with each result having its own identifier.
   * This value is only unique within the CTA. It is not globally unique.
   * The resultId can be used as resultOverride input argument to specify a specific result
   * should be returned for the requested CTA.
   */
  resultId: Scalars['ResultID']['output'];
};

/**
 * Defines a standard shape for vending form constraints for a markdown-enabled text area input.
 * Currently the same as text area constraints but in future may include markdown-specific constraints such as
 * allowed/forbidden markdown tags.
 */
export type MarkdownTextAreaFieldConstraints = {
  __typename?: 'MarkdownTextAreaFieldConstraints';
  /** Specifies if the customer must provide a non-empty (ie not null or empty string) value */
  isRequired?: Maybe<BooleanValidationConstraint>;
  /** Specifies the maximum allowed number of characters for this markdown text area input */
  maximumCharacterLength?: Maybe<IntThresholdValidationConstraint>;
  /** Specifies the minimum allowed number of characters for this markdown text area input */
  minimumCharacterLength?: Maybe<IntThresholdValidationConstraint>;
};

export enum MaturityLevel {
  /** Include content flagged as mature. Such content is excluded by default. */
  IncludeMature = 'INCLUDE_MATURE'
}

/** A generic implementation of the ImageObject */
export type MediaServiceImage = {
  __typename?: 'MediaServiceImage';
  /** Text alternative description of the image for screen reader accessibility. */
  accessibilityText?: Maybe<CommonLocalizedDisplayableConcept>;
  /** Type delineation so that clients are able to determine how to handle the delivered asset. */
  fileType?: Maybe<ImageFileType>;
  /** Original height of the image resource, in pixels. */
  height?: Maybe<Scalars['Int']['output']>;
  /** URL for the image resource. */
  url?: Maybe<Scalars['String']['output']>;
  /** Original height of the image resource, in pixels. */
  width?: Maybe<Scalars['Int']['output']>;
};

export type Metacritic = {
  __typename?: 'Metacritic';
  metascore: Metascore;
  reviews?: Maybe<MetacriticReviewConnection>;
  url?: Maybe<Scalars['URL']['output']>;
};


export type MetacriticReviewsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type MetacriticReview = {
  __typename?: 'MetacriticReview';
  quote?: Maybe<LocalizedString>;
  reviewer?: Maybe<Scalars['String']['output']>;
  score: Scalars['Int']['output'];
  site?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['URL']['output']>;
};

export type MetacriticReviewConnection = {
  __typename?: 'MetacriticReviewConnection';
  edges: Array<Maybe<MetacriticReviewEdge>>;
  pageInfo: PageInfo;
};

export type MetacriticReviewEdge = {
  __typename?: 'MetacriticReviewEdge';
  cursor: Scalars['ID']['output'];
  node: MetacriticReview;
  position: Scalars['Int']['output'];
};

export type Metascore = {
  __typename?: 'Metascore';
  reviewCount: Scalars['Int']['output'];
  score: Scalars['Int']['output'];
};

/** Event that should be noted with meter */
export type MeterEvent = {
  __typename?: 'MeterEvent';
  /** Title of an event that should be noted with meter */
  title?: Maybe<Title>;
  /** Type of event that occurred on a certain date and should be noted with meter */
  type?: Maybe<LocalizedString>;
};

export type MeterRankChange = {
  __typename?: 'MeterRankChange';
  /**
   * Indicates whether the current rank is better (UP), worse (DOWN),
   * or unchanged (FLAT) from the previous rank
   */
  changeDirection: MeterRankChangeDirection;
  /**
   * An integer indicating the difference between the current
   * and previous rank
   */
  difference: Scalars['Int']['output'];
};

export enum MeterRankChangeDirection {
  Down = 'DOWN',
  Flat = 'FLAT',
  Up = 'UP'
}

export type MeterRankingHistoryEntry = {
  __typename?: 'MeterRankingHistoryEntry';
  /** Timestamp of a meter ranking in the form of YYYY-MM-DD */
  date?: Maybe<Scalars['Date']['output']>;
  /** Events on a certain date that should be noted with meter */
  events?: Maybe<Array<Maybe<MeterEvent>>>;
  /** IMDbPro meter ranking of item on a certain date */
  rank: Scalars['Int']['output'];
};

/**
 * Restriction information applied to Meter.
 * By default, restriction will be based on IMDbPro entitlements.
 */
export type MeterRestriction = {
  __typename?: 'MeterRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
};

/** A container for metric dimension data */
export type MetricDimension = {
  __typename?: 'MetricDimension';
  name?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type MiscellaneousCreditAttribute = CreditAttribute & {
  __typename?: 'MiscellaneousCreditAttribute';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

/** The customer that modified the known for category and their role for consumption by IMDb admins */
export type ModifiedBy = {
  __typename?: 'ModifiedBy';
  /** The role of the user modifying the known for of this company */
  role: UserRole;
};

export type Money = {
  __typename?: 'Money';
  /** Amount of money */
  amount: Scalars['Float']['output'];
  /** ISO-4217 alphabetic currency codes.  See: http://www.currency-iso.org/ */
  currency: Scalars['String']['output'];
};

export type MoreLikeThisConnection = {
  __typename?: 'MoreLikeThisConnection';
  edges: Array<Maybe<MoreLikeThisEdge>>;
  pageInfo: PageInfo;
};

export type MoreLikeThisEdge = {
  __typename?: 'MoreLikeThisEdge';
  /** This cursor doesn't work for pagination right now. Please use PageInfo.endCursor instead. */
  cursor: Scalars['ID']['output'];
  node: Title;
  position: Scalars['Int']['output'];
};

export type MoreLikeThisNameConnection = {
  __typename?: 'MoreLikeThisNameConnection';
  edges: Array<Maybe<MoreLikeThisNameEdge>>;
  pageInfo: PageInfo;
};

export type MoreLikeThisNameEdge = {
  __typename?: 'MoreLikeThisNameEdge';
  cursor: Scalars['ID']['output'];
  node: Name;
  position: Scalars['Int']['output'];
};

/**
 * This is a multi-link CallToAction that may contain two action lists: abbreviatedActions and standardActions.
 * The client will decide which action list to use when displaying the actions. For example, the client may choose
 * to display the abbreviatedActions on devices with small screens, while using standardActions on devices with
 * larger screens. A responsive solution may utilize both action lists.
 */
export type MultiLinkCallToAction = {
  __typename?: 'MultiLinkCallToAction';
  /**
   * Provides an abbreviated list of action links for this CallToAction.
   * This is not necessarily a subset of "standardActions", but typically will be.
   * The action links in this list may be less in number and/or contain shorter label text.
   * Each action link contains a name, URL, and an optional label (localized text) associated with the URL.
   * The name will uniquely identify each action link.
   */
  abbreviatedActions?: Maybe<Array<Maybe<NamedActionLink>>>;
  /**
   * An identifier for the returned result of a CTA.
   * A CTA will have multiple potential results, with each result having its own identifier.
   * This value is only unique within the CTA. It is not globally unique.
   * The resultId can be used as resultOverride input argument to specify a specific result
   * should be returned for the requested CTA.
   */
  resultId: Scalars['ResultID']['output'];
  /**
   * Provides the standard list of action links for this CallToAction.
   * Each action link contains a name, URL, and an optional label (localized text) associated with the URL.
   * The name will uniquely identify each action link.
   */
  standardActions?: Maybe<Array<Maybe<NamedActionLink>>>;
};

export enum MyFavoriteTheaterSearchFilter {
  OnlyMyFavorite = 'ONLY_MY_FAVORITE'
}

/**
 * Rating that the requesting user has given to the title.
 * Customer is determined by x-imdb-customer-id header  (gateway determines from request)
 */
export type MyRatingSearchConstraint = {
  /** Select whether constraint should restrict-to or exclude titles that the customer has rated. */
  filterType: MyRatingSearchFilterType;
  /**
   * Match titles based on rating given by the requesting user.
   * Infers "min: 1", or "max: 10" if one of those is not provided.
   * Example: To restrict to only titles the customer rated between 5-10, use {min: 5}
   *
   * Example: To restrict to only titles the customer has rated use {min: 1, max: 10}
   */
  ratingRange?: InputMaybe<IntRangeInput>;
};

export enum MyRatingSearchFilterType {
  Exclude = 'EXCLUDE',
  Include = 'INCLUDE'
}

/**
 * Name type
 * Extends external type.
 */
export type Name = {
  __typename?: 'Name';
  /**
   * Person's age
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  age?: Maybe<AgeDetails>;
  /**
   * A list of alternative names by which the person is also known
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  akas?: Maybe<NameAkaConnection>;
  /**
   * Alexa top questions.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ziggy
   * - CTI: IMDb/GraphQL/Ziggy
   * - Affected by headers: x-imdb-user-language
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-ziggy
   */
  alexaTopQuestions?: Maybe<AlexaQuestionConnection>;
  /**
   * This is Pro exclusive feature
   *
   * Returns the latest uncached auto selected user professions(default limit is 3).
   * Return null if no automatic profession details are available for this name.
   * Throws UNAUTHENTICATED if the requesting customer is not logged in.
   *
   * @entitlement(NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  autoSelectedProfessions?: Maybe<Array<Maybe<NameProfession>>>;
  /**
   * The awards that the person has won or been nominated for
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  awardNominations?: Maybe<AwardNominationConnection>;
  /**
   * Details of the person's bio
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  bio?: Maybe<NameBio>;
  /**
   * NameBio items for a name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  bios?: Maybe<NameBiosConnection>;
  /**
   * Details of the person's date of birth.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  birthDate?: Maybe<DisplayableDate>;
  /**
   * Details of the person's location of birth.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  birthLocation?: Maybe<DisplayableLocation>;
  /**
   * The person's birth name as it appears on IMDb.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  birthName?: Maybe<BirthName>;
  /**
   * A full URL to see the name on www.imdb.com
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  canonicalUrl?: Maybe<Scalars['String']['output']>;
  /**
   * The names represented by this person in some capacity, like the names this
   * person is the Talent Agent for or the Publicist for.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  clients?: Maybe<NameRepresentationConnection>;
  /**
   * This answers if the (name) is primarly considered as an adult actor by IMDb
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  contentWarnings?: Maybe<ContentWarnings>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  creditCategories?: Maybe<Array<Maybe<NameCreditCategoryWithCredits>>>;
  /**
   * Vends credits for this name on titles, grouped into groupings defined by input parameter.
   *
   * We group credits into "groupings" in a way that best highlights a person's work.
   * Appearances in a title where they were not directly involved, such as Archive Footage,
   * are removed from their appearance credits and moved into separate groupings.
   * Soundtrack credits are included within a name's credits as a separate category. This is different to a title-focused
   * view, where Soundtrack credits are modelled as a separate data type.
   * All other credit categories are presented 1-1 as groupings.
   *
   * When a name has credits on individual episodes in a series, these are rolled up and presented at the series level
   * as a single CreditV2 value, giving a summary of their contribution. Details of individual episodes are available
   * from "episodeCredits" on a CreditedRole within a CreditV2 value.
   *
   * When a credit has performed many roles on a title within a grouping, these are aggregated into a single CreditV2
   * value, with each individual role represented as a separate CreditedRole within the CreditV2.
   *
   * Credits on in-development titles are only available to clients providing a Pro tier entitlement.
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  creditGroupings?: Maybe<CreditGroupingConnection>;
  /**
   * Summary for the name credits
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  creditSummary?: Maybe<NameCreditSummary>;
  /**
   * The names that are credited on titles with the parent name derived from their filmography.
   * The results are in descending order by a relevance score calculated server side.
   *
   * Throws UNAUTHENTICATED if the requesting customer is not logged in.
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: networking
   * - CTI: IMDb/GraphQL/Networking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  creditedWithNames?: Maybe<CreditedWithNamesConnection>;
  /**
   * The entire list of credits for the name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  credits?: Maybe<NameCreditConnection>;
  /**
   * The entire list of credits for a name.
   *
   * When a name has credits on individual episodes in a series, these are rolled up and presented at the series level
   * as a single CreditV2 value, giving a summary of their contribution. Details of individual episodes are available
   * from "episodeCredits" on a CreditedRole within a CreditV2 value.
   *
   * When a credit has performed many roles on a title, these are aggregated into a single CreditV2 value, with each
   * individual role represented as a separate CreditedRole within the CreditV2.
   *
   * Credits on in-development titles are only available to clients providing a Pro tier entitlement.
   *
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  creditsV2?: Maybe<CreditV2Connection>;
  /**
   * This is Pro exclusive feature
   *
   * Returns a list of uncached professions for the name owner.
   * This list will return userSelectedProfessions when available or fallback on autoSelectedProfessions otherwise.
   * Returns null if no userSelectedProfessions/autoSelectedProfessions details are available for this name.
   * Throws UNAUTHENTICATED if the requesting customer is not logged in.
   *
   * @entitlement(NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  currentProfessions?: Maybe<Array<Maybe<NameProfession>>>;
  /**
   * Details of the person's cause of death.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  deathCause?: Maybe<DisplayableNameDeathCause>;
  /**
   * Details of the person's date of death.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  deathDate?: Maybe<DisplayableDate>;
  /**
   * Details of the person's location of death.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  deathLocation?: Maybe<DisplayableLocation>;
  /**
   * Details of the person's death
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  deathStatus?: Maybe<NameDeathStatus>;
  /**
   * The demographic data items for the given name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  demographicData?: Maybe<Array<Maybe<DemographicDataItem>>>;
  /**
   * Ways to contact this name directly
   *
   * Return null if no contact details are available for this name or
   * if the entitlement criteria is not met.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  directContact?: Maybe<DirectContactDetails>;
  /**
   * Roman numeral used to differentiate between 2 people of the same name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  disambiguator?: Maybe<Disambiguation>;
  /**
   * Employment information for this name.
   *
   * Return null if no employment information is available for this name or
   * if the entitlement criteria is not met.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  employment?: Maybe<EmploymentConnection>;
  /**
   * Return Engagement Statistics for a name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: engagementData
   * - CTI: IMDb/GraphQL/Engagement Data
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-core-tech
   */
  engagementStatistics?: Maybe<EngagementStatistics>;
  /**
   * Credits for this name on episodes within a particular series. For access to more broad credit data, see
   * name.creditsV2 and name.creditGroupings fields.
   *
   * Each episode title is represented by a single CreditV2 value. When a name has performed multiple roles on the title,
   * these are represented as separate CreditedRoles within one CreditV2 value.
   *
   * Credits on in-development titles are only available to clients providing a Pro tier entitlement.
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  episodeCredits?: Maybe<EpisodeCreditConnection>;
  /**
   *  @experimental Experimental: DO NOT USE
   *
   * The names represented by this person in some capacity, like the names this
   * person is the Talent Agent for or the Publicist for.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  experimental_clients?: Maybe<Experimental_NameRepresentationConnection>;
  /**
   * Experimental Field: DO NOT USE. The list of credits by category for the name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  experimental_creditCategories?: Maybe<Array<Maybe<ExperimentalNameCreditCategoryWithCredits>>>;
  /**
   * Experimental Field: DO NOT USE. The entire list of credits for the name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  experimental_credits?: Maybe<ExperimentalNameCreditConnection>;
  /**
   * @experimental Experimental: DO NOT USE
   *
   * Ways to contact this name directly
   *
   * Return null if no contact details are available for this name or
   * if the entitlement criteria is not met.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  experimental_directContact?: Maybe<Experimental_DirectContactDetails>;
  /**
   * @experimental Experimental: DO NOT USE
   *
   * Employment information for this name.
   *
   * Return null if no employment information is available for this name or
   * if the entitlement criteria is not met.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  experimental_employment?: Maybe<Experimental_EmploymentConnection>;
  /**
   * @experimental Experimental: DO NOT USE
   *
   * Information about what companies and people represent this name, operating
   * in capacities including legal, talent, management, and publicity
   *
   * There will be one representation instance per combination
   * of relationship type and agency/independent rep. For example,
   * if someone is an actor's manager and talent agent, there will
   * be one representation instance for each of those relationships.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  experimental_representation?: Maybe<Experimental_NameRepresentationConnection>;
  /**
   * @experimental experimental
   * Resume data for a name page.
   *
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  experimental_resume?: Maybe<Experimental_Resume>;
  /**
   * The requesting user's track state with notification preferences for this const.
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  experimental_trackNotificationPreferences?: Maybe<Experimental_TrackNotificationPreferences>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  externalLinkCategories?: Maybe<Array<Maybe<ExternalLinkCategoryWithExternalLinks>>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  externalLinks?: Maybe<ExternalLinkConnection>;
  /**
   * External links grouped by featured category
   * Throws UNAUTHENTICATED if not logged in
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  featuredExternalLinkCategories?: Maybe<Array<Maybe<ExternalLinkCategoryWithFeaturedExternalLinks>>>;
  /**
   * Featured polls for the name.
   * Capped at <LIMIT> polls. No pagination
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  featuredPolls?: Maybe<PollsConnection>;
  /**
   * Details of the person's height, default unit is centimeters
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  height?: Maybe<NameHeight>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  id: Scalars['ID']['output'];
  /**
   * Images related to the name, grouped by image types
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  imageTypes?: Maybe<Array<Maybe<ImageTypeWithImages>>>;
  /**
   * Returns the 'upload url' Link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  imageUploadLink?: Maybe<ContributionLink>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  images?: Maybe<ImageConnection>;
  /**
   * True if this name page is considered claimed.
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  isClaimed?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Titles this name is known for.
   * This API is being superseded by Name.knownForV2 in 2025. Contact imdb-relevance-tech@ before using this API.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  knownFor?: Maybe<NameKnownForConnection>;
  /**
   * Titles this name is known for.
   * Returns an empty list if there are no known for titles.
   * Titles are returned in order from most known for to least.
   *
   * Each credit captures all of the roles performed by the name on a given title.
   * Quentin Tarantino (nm0000233) was actor, writer and director for Reservoir Dogs (tt0105236).
   * The Known For entry captures each of these as a separate creditedRole within the CreditV2 field.
   *
   * Within a credit, creditedRoles are ordered by the category of the role. We prioritise categories linked
   * to the person's professions, then follow a fixed ordering of categories as seen on Title Full Credits pages
   * on imdb.com.
   *
   * Within a category, creditedRoles are ordered by frequency of role (across episodes in a series), with alphabetical
   * used as a tie-breaker. The same is true for characters on appearance credits.
   * This behaviour differs from the ordering of creditedRoles and characters for other credits APIs (see CreditV2
   * documentation). The idea is to highlight the work most frequently performed by a person, therefore capturing the
   * work they are likely to be most recognised for on the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  knownForV2?: Maybe<KnownForV2>;
  /**
   * Name data customer can customize or receive automatically generated data for.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  managedData?: Maybe<NameManagedData>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  meta?: Maybe<NameMeta>;
  /**
   * StarMeter rank information
   * Ranking information beyond 5000 requires entitlement proving Pro subscription or Name ownership.
   * Use useEntitlement = false to access non entitled version.
   * @entitlement(PREMIUM_OR_NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ranking
   * - CTI: IMDb/GraphQL/ProRanking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  meterRank?: Maybe<NameMeterRanking>;
  /**
   * History of IMDbPro STARmeter rankings of a name.
   * Requires entitlement proving Pro subscription.
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ranking
   * - CTI: IMDb/GraphQL/ProRanking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  meterRankingHistory?: Maybe<NameMeterRankingHistory>;
  /**
   * Similar names to this name. The max similar names providable by the backend is 50.
   *
   * Pagination not supported:
   * Pagination may produce duplicate results as the ML model is not deterministic and ranking is affected
   * by customer behavioral data. Clients are advised to retrieve names using a single request for now.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  moreLikeThisNames?: Maybe<MoreLikeThisNameConnection>;
  /**
   * The person's name as it appears on IMDb.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nameText?: Maybe<NameText>;
  /**
   * News articles about a name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  news?: Maybe<NewsConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nickNames?: Maybe<Array<Maybe<NickName>>>;
  /**
   * The nominations that the person has won or been nominated for
   * Default sort is done by sorting nomination id in ascending order
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nominations?: Maybe<NominationConnection>;
  /**
   * Other works for a name.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  otherWorks?: Maybe<NameOtherWorkConnection>;
  /**
   * The most prestigious awards that the person has won or been nominated for
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  prestigiousAwardSummary?: Maybe<PrestigiousAwardSummary>;
  /**
   * The primary image for the name.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  primaryImage?: Maybe<Image>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  primaryProfessions?: Maybe<Array<Maybe<PrimaryProfession>>>;
  /**
   * An ordered list of the primary videos related to a name.
   * If the first argument exceeds 100, the results will be capped to 100.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  primaryVideos?: Maybe<VideoConnection>;
  /**
   * Returns a list of profession for a name (default limit is 3).
   * This list will return customerProfessions when available otherwise fallback to automaticProfessions.
   * Returns null if no customerProfessions/automaticProfessions details are available for this name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  professions?: Maybe<Array<Maybe<NameProfession>>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  publicityCategories?: Maybe<Array<Maybe<PublicityCategoryWithListings>>>;
  /**
   * Publicity Listings for a name.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  publicityListings?: Maybe<PublicityListingConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  quotes?: Maybe<NameQuoteConnection>;
  /**
   * Returns page view statistics of this claimed Pro name page.
   * Returns null if less than 5 people have viewed the page.
   *
   * Throws UNAUTHENTICATED if not logged in.
   * @entitlement(PREMIUM_NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  recentlyViewedStatistics?: Maybe<RecentlyViewedStatistics>;
  /**
   * Get lists related to a name
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  relatedLists?: Maybe<ListCollectionConnection>;
  /**
   * Details of the person's relations
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  relations?: Maybe<NameRelationsConnection>;
  /**
   * Information about what companies and people represent this name, operating
   * in capacities including legal, talent, management, and publicity
   *
   * There will be one representation instance per combination
   * of relationship type and agency/independent rep. For example,
   * if someone is an actor's manager and talent agent, there will
   * be one representation instance for each of those relationships.
   *
   * @entitlement(PRO_PREMIUM, NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contactsGQL
   * - CTI: IMDb/GraphQL/ContactsGQL
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-name-redesign-2024
   */
  representation?: Maybe<NameRepresentationConnection>;
  /**
   * Resume data for a name page.
   *
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  resume?: Maybe<Resume>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  searchIndexing?: Maybe<NameSearchIndexing>;
  /**
   * Self-verified data for this person.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  selfVerifiedData?: Maybe<SelfVerifiedNameData>;
  /**
   * The shared names that the input and the parent names have worked with derived from their filmography credits
   *
   * ---------------------
   * Graphlet Details:
   * - Name: networking
   * - CTI: IMDb/GraphQL/Networking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  sharedNames?: Maybe<SharedNamesResult>;
  /**
   * Returns a summary object for the shared name connections between the currently logged in user and the name being queried.
   *
   * Also returns a formatted string for displaying the name connection summary to customers.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: networking
   * - CTI: IMDb/GraphQL/Networking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  sharedNamesSummary?: Maybe<SharedNamesSummary>;
  /**
   * The shared titles between the input and the parent name derived from their filmography credits
   *
   * ---------------------
   * Graphlet Details:
   * - Name: networking
   * - CTI: IMDb/GraphQL/Networking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  sharedTitles?: Maybe<SharedTitlesConnection>;
  /**
   * Details of the person's spouses
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  spouses?: Maybe<Array<Maybe<NameSpouse>>>;
  /**
   * Salary earned from a title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  titleSalaries?: Maybe<SalaryConnection>;
  /**
   * The requesting user's track state with notification preferences for this const.
   * Throws FORBIDDEN if customer does not hve a pro subscription
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  trackNotificationPreferences?: Maybe<TrackNotificationPreferences>;
  /**
   * Details of the person's trademarks
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  trademarks?: Maybe<TrademarkConnection>;
  /**
   * Trivia for a name.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  trivia?: Maybe<NameTriviaConnection>;
  /**
   * This is Pro exclusive feature
   *
   * Returns the latest uncached user selected profession overides only
   * Return null if no user selected profession details are available for this name.
   * Throws UNAUTHENTICATED if the requesting customer is not logged in.
   *
   * @entitlement(PREMIUM_NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  userSelectedProfessions?: Maybe<Array<Maybe<NameProfession>>>;
  /**
   * The person's vanity URL
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  vanityUrl?: Maybe<VanityUrl>;
  /**
   * Videos related to the name, grouped by video type
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  videoTypes?: Maybe<Array<Maybe<VideoTypeWithVideos>>>;
  /**
   * An ordered list of videos related to a name.
   * If the first argument exceeds 100, the results will be capped to 100.
   * When there is no sort passed in it, default to the current videos sort logic and behavior.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  videos?: Maybe<VideoConnection>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameAgeArgs = {
  currentDate?: InputMaybe<Scalars['Date']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameAkasArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameAlexaTopQuestionsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameAutoSelectedProfessionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameAwardNominationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<AwardNominationsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<AwardNominationsSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameBiosArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<NameBiosFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameClientsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<ClientSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameCreditCategoriesArgs = {
  filter?: InputMaybe<NameCreditCategoryFilter>;
  sort?: InputMaybe<NameCreditSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameCreditGroupingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  creditSort?: InputMaybe<NameCreditV2Sort>;
  creditedRoleSort?: InputMaybe<CreditedRoleSort>;
  filter?: InputMaybe<NameCreditsV2Filter>;
  first: Scalars['Int']['input'];
  groupingSort?: InputMaybe<CreditGroupingSort>;
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameCreditedWithNamesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<NameCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<NameCreditSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameCreditsV2Args = {
  after?: InputMaybe<Scalars['ID']['input']>;
  aggregateBy?: InputMaybe<NameCreditAggregation>;
  creditSort?: InputMaybe<NameCreditV2Sort>;
  creditedRoleSort?: InputMaybe<CreditedRoleSort>;
  filter?: InputMaybe<NameCreditsV2Filter>;
  first: Scalars['Int']['input'];
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameCurrentProfessionsArgs = {
  limit: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameDemographicDataArgs = {
  filter?: InputMaybe<DemographicDataFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameEmploymentArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameEpisodeCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<NameEpisodeCreditsFilter>;
  first: Scalars['Int']['input'];
  modePreset?: InputMaybe<CreditsModePreset>;
  seriesId: Scalars['ID']['input'];
  sort?: InputMaybe<EpisodeCreditsSort>;
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameExperimental_ClientsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<ClientSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameExperimental_CreditCategoriesArgs = {
  filter?: InputMaybe<NameCreditCategoryFilter>;
  sort?: InputMaybe<NameCreditSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameExperimental_CreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<NameCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<NameCreditSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameExperimental_EmploymentArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameExperimental_RepresentationArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameExternalLinkCategoriesArgs = {
  filter?: InputMaybe<ExternalLinksFilter>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameExternalLinksArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ExternalLinksFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameFeaturedPollsArgs = {
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameHeightArgs = {
  unit?: InputMaybe<LengthUnit>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameImageTypesArgs = {
  filter?: InputMaybe<NameImagesFilter>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameImageUploadLinkArgs = {
  contributionContext: ContributionContext;
};


/**
 * Name type
 * Extends external type.
 */
export type NameImagesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  bust?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NameImagesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameKnownForArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameKnownForV2Args = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  modePreset?: InputMaybe<CreditsModePreset>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameMeterRankArgs = {
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameMeterRankingHistoryArgs = {
  input?: InputMaybe<NameMeterRankingHistoryInput>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameMoreLikeThisNamesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameNewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameNickNamesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameNominationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<NominationsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<NominationsSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameOtherWorksArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NamePrimaryProfessionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NamePrimaryVideosArgs = {
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameProfessionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NamePublicityListingsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<PublicityListingsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameQuotesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameRelatedListsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameRelationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<NameRelationsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameRepresentationArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Name type
 * Extends external type.
 */
export type NameSharedNamesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<SharedNamesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  input?: InputMaybe<SharedNamesInput>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameSharedTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  input?: InputMaybe<SharedTitlesInput>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameTitleSalariesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameTrademarksArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameTriviaArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameVideoTypesArgs = {
  filter?: InputMaybe<VideosQueryFilter>;
  sort?: InputMaybe<VideoSort>;
};


/**
 * Name type
 * Extends external type.
 */
export type NameVideosArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<VideosQueryFilter>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<VideoSort>;
};

/** Aka details */
export type NameAka = {
  __typename?: 'NameAka';
  /** The alternative name as a displayable property */
  displayableProperty: DisplayableNameAkaProperty;
  /** The alternative name */
  text: Scalars['String']['output'];
};

/** Pagination for NameAkas types which always has a known total number of edges */
export type NameAkaConnection = {
  __typename?: 'NameAkaConnection';
  /** Pages of NameAkas */
  edges: Array<Maybe<NameAkaEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of NameAkas */
export type NameAkaEdge = {
  __typename?: 'NameAkaEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the person's alternative names */
  node: NameAka;
  /** Position of the node in this context, eg: NameAka 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type NameBio = {
  __typename?: 'NameBio';
  /** The bio author. Optional as it will be null for auto generated bios */
  author?: Maybe<Markdown>;
  /** The category of bio */
  category?: Maybe<NameBioCategory>;
  /** The bio as displayable article */
  displayableArticle?: Maybe<DisplayableArticle>;
  /** Unique ID for this bio item */
  id: Scalars['ID']['output'];
  /** The language of the bio text */
  language: DisplayableLanguage;
  /** The bio text */
  text: Markdown;
};

/** A category of person's bio describing the type of bio, e.g. 'auto-generated', 'mini-bio' */
export type NameBioCategory = {
  __typename?: 'NameBioCategory';
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

/** Page of name bios */
export type NameBioEdge = {
  __typename?: 'NameBioEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A NameBio node */
  node: NameBio;
  /** Position of the node in this context, eg: NameBio 4 out of 312 */
  position: Scalars['Int']['output'];
};

/** Pagination for NameBio types which always has a known total number of edges. */
export type NameBiosConnection = {
  __typename?: 'NameBiosConnection';
  /** Pages of name bios */
  edges: Array<Maybe<NameBioEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type NameBiosFilter = {
  /** Return person's bios of specified categories */
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Return person's bios in all available locales when true, otherwise returns all available bios in the requested language */
  includeAllLocales?: InputMaybe<Scalars['Boolean']['input']>;
};

export type NameChartRankingsConnection = {
  __typename?: 'NameChartRankingsConnection';
  edges: Array<Maybe<NameChartRankingsEdge>>;
};

export type NameChartRankingsEdge = {
  __typename?: 'NameChartRankingsEdge';
  node: NameChartRankingsNode;
  position: Scalars['Int']['output'];
};

export type NameChartRankingsInput = {
  /**
   * It is made optional for adapting future use cases.
   * Not passing a valid value will result in client error.
   */
  rankingsChartType?: InputMaybe<NameChartRankingsType>;
};

export type NameChartRankingsNode = {
  __typename?: 'NameChartRankingsNode';
  item: Name;
  rank: Scalars['Int']['output'];
};

export enum NameChartRankingsType {
  /** STARmeter chart geared to India */
  IndiaStarMeter = 'INDIA_STAR_METER'
}

export type NameCreditAggregation = {
  /**
   * Defines how credits are aggregated together into a single CreditV2 result.
   *
   * Aggregation allows clients to choose the level of detail to show for credits, avoiding repetition of the same
   * title across many roles.
   *
   * Parameter is modelled as a string to allow for altering the list of allowed values over time. Supported values are:
   *
   * TITLE: All credits for a single name on a single title are aggregated together.
   * This supports experiences like Name Credits tab on pro.imdb.com, where all work by a name for a title is
   * shown together.
   * For example, see Pulp Fiction (1994) in https://pro.imdb.com/name/nm0000233/credits.
   *
   * TITLE_AND_GROUPING: Credits are broken down by title and grouping.
   * This reflects the same breakdown of credits seen on experiences like Name Main on imdb.com.
   * Note that the credits vended would not be grouped or ordered per-grouping in any way.
   * For example, for Quentin Tarantino (https://www.imdb.com/name/nm0000233/), we would return three credits for
   * Pulp Fiction (1994): Director, Writer (covering two different roles) and Actor.
   */
  aggregationType?: InputMaybe<Scalars['String']['input']>;
};

export type NameCreditCategory = {
  __typename?: 'NameCreditCategory';
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

export type NameCreditCategoryFilter = {
  /** Filter for archived / unarchived credits only */
  archived?: InputMaybe<ArchivedOrUnarchivedFilter>;
  /**
   * Filter for specific credit categories.
   * The list of category IDs are available to query from nameMetadata.nameCreditCategories.
   * Cannot be used in conjunction with "excludeCategories", as the behaviour for unspecified values is ambiguous.
   */
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter for credited or uncredited credits only */
  credited?: InputMaybe<CreditedOrUncreditedFilter>;
  /**
   * Filter out specific credit categories.
   * The list of category IDs are available to query from nameMetadata.nameCreditCategories.
   * Cannot be used in conjunction with "categories", as the behaviour for unspecified values is ambiguous.
   */
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter out credits on titles with specific genres.
   * The list of genres can be accessed from titleMetadata.titleGenres.
   * Cannot be used in conjunction with "genres", as the behaviour for unspecified values is ambiguous.
   */
  excludeGenres?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter out specific production stages.
   * Cannot be used in conjunction with "productionStage", as the behaviour for unspecified values is ambiguous.
   */
  excludeProductionStage?: InputMaybe<Array<InputMaybe<ProductionStageFilter>>>;
  /**
   * Filter out credits for titles with specific titleTypes.
   * The list of titleTypes can be accessed from titleMetadata.titleTypes.
   * Cannot be used in conjunction with "titleType", as the behaviour for unspecified values is ambiguous.
   */
  excludeTitleType?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter for credits on titles with specific genres.
   * The list of genres can be accessed from titleMetadata.titleGenres.
   * Cannot be used in conjunction with "excludeGenres", as the behaviour for unspecified values is ambiguous.
   */
  genres?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter for specific production stages.
   * Cannot be used in conjunction with "excludeProductionStage", as the behaviour for unspecified values is ambiguous.
   */
  productionStage?: InputMaybe<Array<InputMaybe<ProductionStageFilter>>>;
  /** Filter for whether the credits belong to the name's primary professions or not */
  professions?: InputMaybe<ProfessionsFilter>;
  /**
   * Filter for a project status of UPCOMING, PREVIOUS or PROJECT_IN_DEVELOPMENT.
   * On name.creditCategories, this field supports only one value, where more than
   * one value is supplied only first value is used.
   * On name.creditGroupings, multiple values are supported.
   */
  projectStatus?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter credits for titles with specific titleTypes.
   * The list of titleTypes can be accessed from titleMetadata.titleTypes.
   * Cannot be used in conjunction with "excludeTitleType", as the behaviour for unspecified values is ambiguous.
   */
  titleType?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter credits for titles with specific titleTypeCategory. */
  titleTypeCategory?: InputMaybe<Array<InputMaybe<TitleTypeCategoryValue>>>;
  /** Filter credits to only those for these specific titles */
  titles?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type NameCreditCategoryWithCredits = {
  __typename?: 'NameCreditCategoryWithCredits';
  category: CreditCategory;
  credits?: Maybe<NameCreditConnection>;
};


export type NameCreditCategoryWithCreditsCreditsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for Credit type on a Name. */
export type NameCreditConnection = {
  __typename?: 'NameCreditConnection';
  /** Pages of credits */
  edges: Array<Maybe<CreditEdge>>;
  /** How the credits are ordered */
  orderBy?: Maybe<CreditsOrderedBy>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<CreditRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type NameCreditSort = {
  by: NameCreditSortBy;
  order: SortOrder;
};

export enum NameCreditSortBy {
  ReleaseDate = 'RELEASE_DATE'
}

/** Summary of the name credits. */
export type NameCreditSummary = {
  __typename?: 'NameCreditSummary';
  /** List of categories the name has credits on */
  categories?: Maybe<Array<Maybe<CreditCategorySummary>>>;
  /** List of genres the name has credits on */
  genres?: Maybe<Array<Maybe<GenreSummary>>>;
  /** List of title type categories the name has credits on */
  titleTypeCategories?: Maybe<Array<Maybe<TitleTypeCategorySummary>>>;
  /** List of title types the name has credits on */
  titleTypes?: Maybe<Array<Maybe<TitleTypeSummary>>>;
  /** Total number of credits after restriction is applied and restriction info */
  totalCredits?: Maybe<TotalCredits>;
};

export type NameCreditV2Sort = {
  /**
   * Capture the order of CreditV2 items in a listing.
   *
   * This is modelled as a string to allow for altering the list of allowed values over time. Supported values are:
   *
   * RELEASE_DATE: Credit ordering follows this priority sequence:
   * 1. Release date - For singular titles, the primary release date (most recent first)
   * 2. Latest release date - For series, most recent episode release date that this credit applies to
   * 3. Title ID - A final tie-break by title ID to ensure consistent ordering (largest first).
   *
   * RELEASE_DATE is the default.
   */
  by?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<SortOrder>;
};

/** In name.credits API, filters only applied to top level credits. Episodes under series have their own filters */
export type NameCreditsFilter = {
  /**
   * Filter for archived / unarchived credits only.
   * By default, all credits are included, including those marked as "(archive footage)" or "(archive sound)".
   */
  archived?: InputMaybe<ArchivedOrUnarchivedFilter>;
  /**
   * Filter for specific credit categories.
   * The list of category IDs are available to query from nameMetadata.nameCreditCategories.
   * Cannot be used in conjunction with "excludeCategories", as the behaviour for unspecified values is ambiguous.
   * By default, all categories are included.
   */
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter for credited or uncredited credits only.
   * By default, all credits are included, including those marked as "(uncredited)".
   */
  credited?: InputMaybe<CreditedOrUncreditedFilter>;
  /**
   * Filter out specific credit categories.
   * The list of category IDs are available to query from nameMetadata.nameCreditCategories.
   * Cannot be used in conjunction with "categories", as the behaviour for unspecified values is ambiguous.
   * By default, all categories are included.
   */
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter out credits on titles with specific genres.
   * The list of genres can be accessed from titleMetadata.titleGenres.
   * Cannot be used in conjunction with "genres", as the behaviour for unspecified values is ambiguous.
   * By default, credits for all genres are included.
   */
  excludeGenres?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter out specific credit groupings. Individual grouping IDs are found in name.creditGroupings responses.
   * Clients would often make a call to name.creditGroupings, retrieve an initial page of credits per grouping, then
   * fetch additional pages using this API.
   * Cannot be used in conjunction with "groupings", as the behaviour for unspecified values is ambiguous.
   * By default, credits for all groupings are included.
   */
  excludeGroupings?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter out specific production stages.
   * Cannot be used in conjunction with "productionStage", as the behaviour for unspecified values is ambiguous.
   * By default, credits for all production stages are included.
   */
  excludeProductionStage?: InputMaybe<Array<InputMaybe<ProductionStageFilter>>>;
  /**
   * Filter out credits for titles with specific titleTypes.
   * The list of titleTypes can be accessed from titleMetadata.titleTypes.
   * Cannot be used in conjunction with "titleType", as the behaviour for unspecified values is ambiguous.
   * By default, credits for all title types are included.
   */
  excludeTitleType?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Drop credits that have at least one of the given traits on their credit category.
   * Supported values are: 'CAST_TRAIT', 'CREW_TRAIT', 'SELF_TRAIT',
   * 'THANKS_TRAIT', 'ADDITIONAL_APPEARANCES_TRAIT', 'MAJOR_CREATIVE_INPUT_TRAIT',
   * 'UNCATEGORIZED_TRAIT', 'UNDERGOING_TESTING_TRAIT'.
   * Cannot be used in conjunction with "includeTraits", as the behaviour for unspecified values is ambiguous.
   * By default, credits are not filtered by trait.
   * See CreditCategoryTrait for trait definitions.
   */
  excludeTraits?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Filter for credits on titles with specific genres.
   * The list of genres can be accessed from titleMetadata.titleGenres.
   * Cannot be used in conjunction with "excludeGenres", as the behaviour for unspecified values is ambiguous.
   * By default, credits for all genres are included.
   */
  genres?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter for specific credit groupings. Individual grouping IDs are found in name.creditGroupings responses.
   * Clients would often make a call to name.creditGroupings, retrieve an initial page of credits per grouping, then
   * fetch additional pages using this API.
   * Cannot be used in conjunction with "excludeGroupings", as the behaviour for unspecified values is ambiguous.
   * By default, credits for all groupings are included.
   */
  groupings?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Keep credits that have at least one of the given traits on their credit category.
   * Supported values are: 'CAST_TRAIT', 'CREW_TRAIT', 'SELF_TRAIT',
   * 'THANKS_TRAIT', 'ADDITIONAL_APPEARANCES_TRAIT', 'MAJOR_CREATIVE_INPUT_TRAIT',
   * 'UNCATEGORIZED_TRAIT', 'UNDERGOING_TESTING_TRAIT'.
   * Cannot be used in conjunction with "excludeTraits", as the behaviour for unspecified values is ambiguous.
   * By default, credits are not filtered by trait.
   * See CreditCategoryTrait for trait definitions.
   */
  includeTraits?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Filter for specific production stages.
   * Cannot be used in conjunction with "excludeProductionStage", as the behaviour for unspecified values is ambiguous.
   * By default, credits for all production stages are included.
   */
  productionStage?: InputMaybe<Array<InputMaybe<ProductionStageFilter>>>;
  /**
   * Filter for a project status of UPCOMING, PREVIOUS or PROJECT_IN_DEVELOPMENT.
   * On name.creditCategories, this field supports only one value, where more than
   * one value is supplied only first value is used.
   * On name.creditGroupings, multiple values are supported.
   * By default, credits for all project statuses are included. Note that PROJECT_IN_DEVELOPMENT titles are not included
   * when the request has no Pro tier entitlement.
   */
  projectStatus?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter credits for titles with specific titleTypes.
   * The list of titleTypes can be accessed from titleMetadata.titleTypes.
   * Cannot be used in conjunction with "excludeTitleType", as the behaviour for unspecified values is ambiguous.
   * By default, credits for all title types are included.
   */
  titleType?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter credits for titles with specific titleTypeCategory.
   * By default, credits for all title type categories are included.
   */
  titleTypeCategory?: InputMaybe<Array<InputMaybe<TitleTypeCategoryValue>>>;
  /**
   * Filter credits to only those for these specific titles.
   * By default, credits for all titles are included.
   */
  titles?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type NameCreditsV2Filter = {
  /** Filters that apply to credits at the contributed credit level. */
  creditLevelFilter?: InputMaybe<CreditLevelCreditsFilterSet>;
  /** Filters that apply to credits at the title level. In this context, they apply to the parent series title. */
  titleLevelFilter?: InputMaybe<TitleLevelCreditsFilterSet>;
};

export enum NameDataType {
  /** Matches names that have awards data */
  AwardNominations = 'AWARD_NOMINATIONS',
  /** Matches names that have biography data */
  Biography = 'BIOGRAPHY',
  /** Matches names that have a birth date */
  BirthDate = 'BIRTH_DATE',
  /** Matches names that have a birth place */
  BirthPlace = 'BIRTH_PLACE',
  /** Matches names that have a death date */
  DeathDate = 'DEATH_DATE',
  /** Matches names that have a death place */
  DeathPlace = 'DEATH_PLACE',
  /** Matches names that have height data */
  HeightInfo = 'HEIGHT_INFO',
  /** Matches names that have quotes data */
  Quotes = 'QUOTES',
  /** Matches names that have trivia data */
  Trivia = 'TRIVIA'
}

/** Name death status enum */
export enum NameDeathStatus {
  Alive = 'ALIVE',
  Dead = 'DEAD',
  PresumedDead = 'PRESUMED_DEAD'
}

/** Page display preferences (e.g. whether to hide awards, biography, etc.) */
export type NameDisplayPreferences = {
  __typename?: 'NameDisplayPreferences';
  /** Visibility setting for 'also known as' */
  akas: NameDisplayVisibilityLevel;
  /** Visibility setting for self-verified awards */
  awards: NameDisplayVisibilityLevel;
  /** Visibility setting for biography */
  biography: NameDisplayVisibilityLevel;
  /** Visibility setting for height */
  height: NameDisplayVisibilityLevel;
};

/** Page display visibility preference */
export enum NameDisplayVisibilityLevel {
  Hidden = 'HIDDEN',
  Public = 'PUBLIC'
}

export type NameEpisodeCreditsFilter = {
  /** Filters that apply to credits at the contributed credit level. */
  creditLevelFilter?: InputMaybe<CreditLevelCreditsFilterSet>;
  /** Filters that apply to credits at the episode level. */
  episodeLevelFilter?: InputMaybe<EpisodesFilter>;
  /** Filters that apply to credits at the title level. In this context, they apply to the parent series title. */
  titleLevelFilter?: InputMaybe<TitleLevelCreditsFilterSet>;
};

/** Pagination for name facets */
export type NameFacetConnection = {
  __typename?: 'NameFacetConnection';
  edges: Array<Maybe<NameFacetEdge>>;
  pageInfo: PageInfo;
  /** Provides information on the total number of names you could filter on */
  total: Scalars['Int']['output'];
};

export type NameFacetEdge = {
  __typename?: 'NameFacetEdge';
  cursor: Scalars['ID']['output'];
  node: Name;
  position: Scalars['Int']['output'];
  /** How many items are associated with this name node */
  total: Scalars['Int']['output'];
};

export enum NameFacetField {
  CreditCategories = 'CREDIT_CATEGORIES',
  GenderIdentity = 'GENDER_IDENTITY',
  JobCategories = 'JOB_CATEGORIES',
  Professions = 'PROFESSIONS',
  ProfessionCategories = 'PROFESSION_CATEGORIES'
}

export type NameFilmBiography = PublicityListingType & {
  __typename?: 'NameFilmBiography';
  category: PublicityListingCategory;
  /** The publicity listing as a displayable property */
  displayableProperty: DisplayableNameFilmBiographyProperty;
  /** A list of biographical titles about this person. */
  title: Title;
};

export enum NameGenderIdentity {
  /** Matches names whose gender is female */
  Female = 'FEMALE',
  /** Matches names whose gender is male */
  Male = 'MALE',
  /** Matches names whose gender is non_binary */
  NonBinary = 'NON_BINARY',
  /** Matches names whose gender is other */
  Other = 'OTHER'
}

export type NameHeight = {
  __typename?: 'NameHeight';
  /**
   * The name's height as a displayable property, e.g. '6 4 (1.93 m)', with imperial provided for customers in the
   * following countries: "US", "CA", "GB", "IN", "AU", "NZ", "IE", "HK", "MY
   */
  displayableProperty: DisplayableNameHeightProperty;
  /** The name's height measurement */
  measurement: LengthMeasurement;
};

export type NameImagesFilter = {
  /** Return only a name's featured images, no featured images, or if not specified, all images */
  featured?: InputMaybe<FeaturedImagesOption>;
  /** Return images meeting the specified gallery constraints */
  galleryConstraints?: InputMaybe<ImageGalleryFilterConstraints>;
  /** Return images meeting the specified name constraints */
  nameConstraints?: InputMaybe<ImageNameFilterConstraints>;
  /** Return only images tagged with at least a minimum and/or at most a maximum number of names */
  namesCount?: InputMaybe<CountInterval>;
  /** Return images meeting the specified title constraints */
  titleConstraints?: InputMaybe<ImageTitleFilterConstraints>;
  /** Return only images which are one of these types */
  types?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type NameKnownFor = {
  __typename?: 'NameKnownFor';
  /**
   * The credit this name is known for
   * The known for credit is selected based on the principal category
   */
  credit: Credit;
  /** The title this name is known for */
  title: Title;
};

/** Pagination for Known For titles which always has a known total number of edges. */
export type NameKnownForConnection = {
  __typename?: 'NameKnownForConnection';
  /** Pages of Known For Titles */
  edges: Array<Maybe<NameKnownForEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Restriction related information if exists for the connection */
  restriction?: Maybe<NameKnownForRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Known For Titles */
export type NameKnownForEdge = {
  __typename?: 'NameKnownForEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Known For node */
  node: NameKnownFor;
  /** Position of the node in this context, eg: KnownFor 4 out of 100 */
  position: Scalars['Int']['output'];
};

/** Restriction information applied to KnownFor */
export type NameKnownForRestriction = {
  __typename?: 'NameKnownForRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

/**
 * Filters that apply to credits at the name level.
 * Each specified filter is AND-ed together.
 * For filters that accept a list of values, the filter is an OR across that list, so any
 * credit matching one value meets the filter's criteria.
 */
export type NameLevelCreditsFilterSet = {
  /**
   * Filter credits to only those for these specific names.
   * By default, credits for all names are included.
   */
  nameId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type NameListItemSearchConnection = {
  __typename?: 'NameListItemSearchConnection';
  edges: Array<Maybe<NameListItemSearchEdge>>;
  facet?: Maybe<Array<Maybe<SearchFacet>>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};


export type NameListItemSearchConnectionFacetArgs = {
  facetField: NameFacetField;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type NameListItemSearchEdge = {
  __typename?: 'NameListItemSearchEdge';
  cursor: Scalars['ID']['output'];
  name: Name;
  node: ListItemSearchNode;
};

export type NameListSearchSort = {
  by: NameListSearchSortBy;
  order: SortOrder;
};

export enum NameListSearchSortBy {
  /**
   * Sort names based on their birth date
   * ASC: Earliest dates to Highest dates (Oldest - Youngest)
   */
  BirthDate = 'BIRTH_DATE',
  /**
   * Date when the list item was added to the list
   * ASC: Earlier date will be first.
   */
  DateAdded = 'DATE_ADDED',
  /**
   * Sort names based on their death date
   * ASC: Earliest dates to last dates (Died First - Died Last)
   */
  DeathDate = 'DEATH_DATE',
  /** List order determined by the customer */
  ListOrder = 'LIST_ORDER',
  /**
   * Sort names alphabetically
   * ASC: A-Z
   */
  Name = 'NAME',
  /**
   * Sort names based on their starMeterCurrentWeekRank
   * ASC: Lower popularity score means that the name is more popular, so the most popular names will be first
   */
  Popularity = 'POPULARITY'
}

/** Name data that provides additional context exclusively for name owner or authorized managers */
export type NameManagedData = {
  __typename?: 'NameManagedData';
  /**
   * Automatic featured images to use if customer does not manually select with max limit 6
   *
   * Throws UNAUTHENTICATED if not logged in
   * Throws FORBIDDEN if not entitled
   */
  automaticFeaturedImages?: Maybe<Array<Maybe<Image>>>;
  /**
   * Automatic known for titles to use if customer does not manually select with max limit 4
   *
   * Throws UNAUTHENTICATED if not logged in
   * Throws FORBIDDEN if not entitled
   */
  automaticKnownFor?: Maybe<Array<Maybe<Title>>>;
  /**
   * Featured images that customer selected manually last time
   *
   * Throws UNAUTHENTICATED if not logged in
   * Throws FORBIDDEN if not entitled
   */
  customFeaturedImages?: Maybe<CustomFeaturedImages>;
  /**
   * Known for titles that customer selected manually last time
   *
   * Throws UNAUTHENTICATED if not logged in
   * Returns null if not entitled
   *
   * @entitlement(PREMIUM_NAME_OWNER)
   */
  customKnownFor?: Maybe<CustomKnownFor>;
  /**
   * Primary image settings configured by the name owner
   *
   * Throws UNAUTHENTICATED if not logged in
   * Throws FORBIDDEN if not entitled
   */
  customPrimaryImage?: Maybe<CustomPrimaryImage>;
  /**
   * Page display preferences (e.g. whether to hide biography, akas, etc.)
   *
   * Throws UNAUTHENTICATED if not logged in
   * Throws FORBIDDEN if not entitled
   */
  displayPreferences?: Maybe<NameDisplayPreferences>;
  /** Up-to-date primary image for customer */
  latestPrimaryImage?: Maybe<Image>;
  /**
   * Managing permission statuses for the given clients
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PREMIUM_NAME_OWNER)
   */
  managedClients?: Maybe<Array<Maybe<ManagedClient>>>;
  /**
   * Managing permission statuses for the given representatives
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PREMIUM_NAME_OWNER)
   */
  managingRepresentatives?: Maybe<Array<Maybe<ManagingRepresentative>>>;
};


/** Name data that provides additional context exclusively for name owner or authorized managers */
export type NameManagedDataAutomaticFeaturedImagesArgs = {
  limit: Scalars['Int']['input'];
};


/** Name data that provides additional context exclusively for name owner or authorized managers */
export type NameManagedDataAutomaticKnownForArgs = {
  limit: Scalars['Int']['input'];
};


/** Name data that provides additional context exclusively for name owner or authorized managers */
export type NameManagedDataManagedClientsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Name data that provides additional context exclusively for name owner or authorized managers */
export type NameManagedDataManagingRepresentativesArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};

/**
 * A request sent from a rep to a client to ask for managing permission
 * Notes: it is the return type of a query field
 */
export type NameManagingPermissionRequestResponse = {
  __typename?: 'NameManagingPermissionRequestResponse';
  /** True if permission request is valid (not expired, not yet approved or denied by target, etc.) */
  isValid: Scalars['Boolean']['output'];
  requester: Name;
  target: Name;
};

export type NameMeta = {
  __typename?: 'NameMeta';
  canonicalId: Scalars['ID']['output'];
  publicationStatus: PublicationStatus;
};

export type NameMetadata = {
  __typename?: 'NameMetadata';
  /** All the name credit categories */
  nameCreditCategories: Array<Maybe<NameCreditCategory>>;
};

export type NameMeterRanking = {
  __typename?: 'NameMeterRanking';
  /**
   * The current IMDbPro StarMeter ranking of the name. A lower value is better.
   * Ranking information beyond 5000 requires entitlement proving Pro subscription.
   */
  currentRank: Scalars['Int']['output'];
  /**
   * If a previous rank exists, this is a set of fields comparing the current rank
   * to the previous rank
   */
  rankChange?: Maybe<MeterRankChange>;
};

export type NameMeterRankingHistory = {
  __typename?: 'NameMeterRankingHistory';
  /**
   * The best historical IMDbPro StarMeter ranking of a name.
   * A lower value is better. By default, returns the values over all time.
   * Requires entitlement proving Pro subscription.
   */
  bestRank?: Maybe<MeterRankingHistoryEntry>;
  /**
   * History of IMDbPro STARmeter rankings of a name.
   * Requires entitlement proving Pro subscription.
   */
  ranks?: Maybe<Array<Maybe<MeterRankingHistoryEntry>>>;
  restriction?: Maybe<MeterRestriction>;
};

export type NameMeterRankingHistoryInput = {
  /**
   * Last date to obtain STARmeter history for. If not provided, default is most recent ranking date.
   * If there is no ranking on end date, the date is the most recent date before this one.
   */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /**
   * First date to obtain STARmeter history for. If not provided, default is first ranking date.
   * If there is no ranking on start date, the date is the earliest date after this one.
   */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

export type NameOtherWork = {
  __typename?: 'NameOtherWork';
  /** Type of the Other Work item */
  category?: Maybe<NameOtherWorkCategory>;
  /** Other work as displayable property */
  displayableProperty: DisplayableNameOtherWorkProperty;
  /** Start date of the OtherWork item */
  fromDate?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  /** The details of the work this person was involved in */
  text: Markdown;
  /** End date of the OtherWork item */
  toDate?: Maybe<Scalars['Date']['output']>;
};

export type NameOtherWorkCategory = {
  __typename?: 'NameOtherWorkCategory';
  /** id will be the same as text */
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

/** Pagination for Other Works types which always has a known total number of edges. */
export type NameOtherWorkConnection = {
  __typename?: 'NameOtherWorkConnection';
  /** Pages of OtherWork */
  edges: Array<Maybe<NameOtherWorkEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of OtherWork */
export type NameOtherWorkEdge = {
  __typename?: 'NameOtherWorkEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A OtherWork node */
  node: NameOtherWork;
  /** Position of the node in this context, eg: OtherWork 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type NamePersonalLocation = {
  __typename?: 'NamePersonalLocation';
  /** ID of the location */
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  latitude: Scalars['String']['output'];
  longitude: Scalars['String']['output'];
  /** Display text of the location, e.g. 'Sydney, Australia' */
  text: Scalars['String']['output'];
};

export type NamePersonalLocationMetadata = {
  __typename?: 'NamePersonalLocationMetadata';
  /** The maximum number of values a customer can have for personal locations */
  limit: Scalars['Int']['output'];
  /** All valid values for personal locations */
  validValues: Array<Maybe<NamePersonalLocation>>;
};

export type NamePersonalLocations = {
  __typename?: 'NamePersonalLocations';
  locations: Array<Maybe<NamePersonalLocation>>;
  /** Total number of personal locations */
  total: Scalars['Int']['output'];
};

export type NamePortrayal = PublicityListingType & {
  __typename?: 'NamePortrayal';
  category: PublicityListingCategory;
  /** The publicity listing as a displayable property */
  displayableProperty: DisplayableNamePortrayalProperty;
  /** A list of titles in which this person was portrayed by an actor, not including biographical titles about this person. */
  title: Title;
};

export type NamePrintBiography = PublicityListingType & {
  __typename?: 'NamePrintBiography';
  /** Text describing the authors for this book */
  authors?: Maybe<Array<Maybe<Markdown>>>;
  category: PublicityListingCategory;
  /** The biographical book as a displayable property */
  displayableProperty: DisplayableNamePrintBiographyProperty;
  /** The ISBN number, without hyphens, corresponding to the biography book. Can be ISBN-10 or ISBN-13. */
  isbn?: Maybe<Scalars['String']['output']>;
  /** Information about the publisher. */
  publisher?: Maybe<Scalars['String']['output']>;
  /** The title of the biographical book. */
  title?: Maybe<PublicityListingTitleText>;
};

/**
 * A NameProfession is a type of work that someone wants to be known for doing on an ongoing basis.
 * For example a Makeup Artist.
 *
 * All fields are marked as nullable in case of invalid graphlet cross-link - in practice these should never be null.
 */
export type NameProfession = {
  __typename?: 'NameProfession';
  /**
   * The profession ID e.g. amzn1.imdb.profession.1.2.3
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * Flags whether this profession can be selected by customers in menus during contribution or search.
   * Staff-only professions like 'Monarch of the United Kingdom' are false.
   * Undefined values will be treated as false
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  isCustomerSelectable?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Details of the Profession
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  profession?: Maybe<DisplayableProfession>;
  /**
   * Details of the Profession Category
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  professionCategory?: Maybe<ProfessionCategory>;
  /**
   * short description of the Profession
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  shortDescription?: Maybe<DisplayableProfessionDescription>;
};

/**
 * The constraints here are combined (AND).
 *
 * example:
 *
 * professionCategoryConstraint: {
 *     allProfessionCategoryIds: ["amzn1.imdb.concept.profession_category.0001...",
 *     "amzn1.imdb.concept.profession_category.0002..."],
 *     anyProfessionCategoryIds: ["amzn1.imdb.concept.profession_category.0003...",
 *     "amzn1.imdb.concept.profession_category.0004..."]
 *     excludeProfessionCategoryIds: ["amzn1.imdb.concept.profession_category.0005..."]
 * }
 *
 * will match names that have the profession categories ("...0001..." AND
 * "...0002...") AND ("...0003..." OR "...0004...") AND NOT "...0005..."
 */
export type NameProfessionCategorySearchConstraint = {
  /** A name match must have all of these profession categories */
  allProfessionCategoryIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** A name match must have AT LEAST ONE of these profession categories */
  anyProfessionCategoryIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * A name match must not have any of these profession categories
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results will be empty.
   */
  excludeProfessionCategoryIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/**
 * The constraints here are combined (AND).
 *
 * example:
 *
 * professionConstraint: {
 *     allProfessionIds: ["amzn1.imdb.concept.profession.0001...", "amzn1.imdb.concept.profession.0002..."],
 *     anyProfessionIds: ["amzn1.imdb.concept.profession.0003...", "amzn1.imdb.concept.profession.0004..."]
 *     excludeProfessionIds: ["amzn1.imdb.concept.profession.0005..."]
 * }
 *
 * will match names that have the professions ("...0001..." AND "...0002...") AND
 * ("...0003..." OR "...0004...") AND NOT "...0005..."
 */
export type NameProfessionSearchConstraint = {
  /** A name match must have all of these professions */
  allProfessionIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** A name match must have AT LEAST ONE of these professions */
  anyProfessionIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * A name match must not have any of these professions
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results will be empty.
   */
  excludeProfessionIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type NameQuote = {
  __typename?: 'NameQuote';
  /** The quote as a displayable article */
  displayableArticle?: Maybe<DisplayableArticle>;
  id: Scalars['ID']['output'];
  language?: Maybe<DisplayableLanguage>;
  text: Markdown;
};

export type NameQuoteConnection = {
  __typename?: 'NameQuoteConnection';
  edges: Array<Maybe<NameQuoteEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type NameQuoteEdge = {
  __typename?: 'NameQuoteEdge';
  cursor: Scalars['ID']['output'];
  node: NameQuote;
  position: Scalars['Int']['output'];
};

export type NameQuoteMatchingSearchConstraint = {
  /** A name match must contain ALL of these search terms in at least one of its quotes. */
  allQuoteTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A name match must contain AT LEAST ONE of these search terms in at least one of its quotes. */
  anyQuoteTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type NameRecommendation = {
  __typename?: 'NameRecommendation';
  /** Explanation for why we recommend this name, to comply with privacy laws */
  explanation: LocalizedMarkdown;
  name: Name;
};

export type NameRecommendationConnection = {
  __typename?: 'NameRecommendationConnection';
  edges: Array<Maybe<NameRecommendationEdge>>;
  pageInfo: PageInfo;
};

export type NameRecommendationEdge = {
  __typename?: 'NameRecommendationEdge';
  cursor: Scalars['ID']['output'];
  node: NameRecommendation;
};

export type NameRecommendations = {
  __typename?: 'NameRecommendations';
  names?: Maybe<NameRecommendationConnection>;
  refTag: Scalars['String']['output'];
};


export type NameRecommendationsNamesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};

export type NameRelation = {
  __typename?: 'NameRelation';
  /** Date of Birth for the related person */
  birthDate?: Maybe<DisplayableDate>;
  /** Gender of the related person */
  genderIdentity?: Maybe<GenderIdentity>;
  /** Relation ID, e.g. rs0023922 */
  id: Scalars['ID']['output'];
  /** Details of the relative of this name. */
  relationName?: Maybe<RelationName>;
  /** Relationship type, e.g. parent */
  relationshipType: NameRelationType;
};

export type NameRelationType = {
  __typename?: 'NameRelationType';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type NameRelationsConnection = {
  __typename?: 'NameRelationsConnection';
  /** Pages of NameRelation */
  edges: Array<Maybe<NameRelationsEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of NameRelation */
export type NameRelationsEdge = {
  __typename?: 'NameRelationsEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the relationship */
  node: NameRelation;
  /** Position of the node in this context, eg: NameRelation 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type NameRelationsFilter = {
  /** Filter out specific relation categories */
  excludeRelationshipTypes?: InputMaybe<Array<InputMaybe<RelationshipTypeFilter>>>;
  /** Filter for specific relation categories */
  relationshipTypes?: InputMaybe<Array<InputMaybe<RelationshipTypeFilter>>>;
};

export type NameRepresentation = {
  __typename?: 'NameRepresentation';
  /**
   * The company representing this name, if there is one
   *
   * Either agency or independentRepresentative will have data but not both
   */
  agency?: Maybe<Agency>;
  /** The name being represented */
  client: Name;
  /** An obfuscated persistent id to uniquely identify this data */
  id: Scalars['ID']['output'];
  /**
   * Someone representing this name but not associated with a company.
   *
   * Either agency or independentRepresentative will have data but not both
   */
  independentRepresentative?: Maybe<Name>;
  /** The type of relationship this representation has with the name */
  relationshipType: RepresentationRelationshipType;
};

export type NameRepresentationConnection = {
  __typename?: 'NameRepresentationConnection';
  edges: Array<Maybe<NameRepresentationEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type NameRepresentationEdge = {
  __typename?: 'NameRepresentationEdge';
  cursor: Scalars['ID']['output'];
  node: NameRepresentation;
  position: Scalars['Int']['output'];
};

export type NameSearchConnection = {
  __typename?: 'NameSearchConnection';
  edges: Array<Maybe<NameSearchEdge>>;
  pageInfo: PageInfo;
};

export type NameSearchEdge = {
  __typename?: 'NameSearchEdge';
  cursor: Scalars['ID']['output'];
  node: Name;
};

export type NameSearchIndexing = {
  __typename?: 'NameSearchIndexing';
  /** A boolean flag that indicates whether IMDb should set the `noIndex` tag on pages for this name. */
  disableIndexing: Scalars['Boolean']['output'];
};

export type NameSpouse = {
  __typename?: 'NameSpouse';
  /** Attributes that describe the spouse relationship */
  attributes?: Maybe<Array<Maybe<SpouseAttributes>>>;
  /** Indicates if this is the current spouse */
  current: Scalars['Boolean']['output'];
  /** Spouse displayable property */
  displayableProperty: DisplayableNameSpouseProperty;
  /** Details of the spouse of this name. */
  spouse?: Maybe<SpouseName>;
  /** Spouse time range as a formatted string eg '12 January 2020 - present' */
  timeRange?: Maybe<DisplayableSpouseTimeRange>;
};

export type NameText = {
  __typename?: 'NameText';
  text: Scalars['String']['output'];
};

export type NameTextSearchConstraint = {
  /**
   * Matches names based on their name text.
   * There is no fuzzy matching.
   * For example: 'Audrey Hepburn' will be matched by 'Audrey' and 'Hepburn' but not 'Audrey Hep'
   */
  searchTerm: Scalars['String']['input'];
};

/** Details about an attachment event, i.e. when a name is attached to a title */
export type NameToTitleAttachment = {
  __typename?: 'NameToTitleAttachment';
  /**
   * The time (in ISO 8601 format) that the name-to-title attachment was published
   *
   * e.g. '2020-06-23T15:41:18.243Z'
   */
  attachmentTime: Scalars['DateTime']['output'];
  /**
   * If the attached name is in the cast of the title, this list contains the
   * names of the characters they are credited as
   */
  characterList: Array<Maybe<Scalars['String']['output']>>;
  /** The attached name's credited professions in the title */
  creditCategories: Array<Maybe<CreditCategory>>;
  /** Unique Id associated with this attachment event */
  id: Scalars['ID']['output'];
  /** The name in this name to title attachment */
  name: Name;
  /** The title in this name to title attachment */
  title: Title;
};

export type NameToTitleAttachmentConnection = {
  __typename?: 'NameToTitleAttachmentConnection';
  edges: Array<Maybe<NameToTitleAttachmentEdge>>;
  pageInfo: PageInfo;
  /** Total number of attachments that match the input query */
  total: Scalars['Int']['output'];
};

/** cursor matches the Id of the last attachment event returned */
export type NameToTitleAttachmentEdge = {
  __typename?: 'NameToTitleAttachmentEdge';
  cursor: Scalars['ID']['output'];
  node: NameToTitleAttachment;
};

export type NameTrackRecommendationEdge = {
  __typename?: 'NameTrackRecommendationEdge';
  /** Cursor ID of the name track recommendation */
  cursor: Scalars['ID']['output'];
  /** A name track recommendation node */
  node: Name;
  /** Position of the node in this context, e.g. NameTrackRecommendationEdge 2 out of 10 */
  position: Scalars['Int']['output'];
};

export type NameTrackRecommendationsConnection = {
  __typename?: 'NameTrackRecommendationsConnection';
  /** Page of name track recommendations */
  edges: Array<Maybe<NameTrackRecommendationEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of name track recommendations */
  total: Scalars['Int']['output'];
};

export type NameTrivia = {
  __typename?: 'NameTrivia';
  /** Date of the Trivia item */
  date?: Maybe<Scalars['Date']['output']>;
  /** The trivia as a displayable article */
  displayableArticle?: Maybe<DisplayableArticle>;
  id: Scalars['ID']['output'];
  /** trivia Voting summary */
  interestScore: InterestScore;
  /** The trivia text */
  text: Markdown;
};

/** Pagination for Trivia types which always has a known total number of edges. */
export type NameTriviaConnection = {
  __typename?: 'NameTriviaConnection';
  /** Pages of Trivia */
  edges: Array<Maybe<NameTriviaEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Trivia */
export type NameTriviaEdge = {
  __typename?: 'NameTriviaEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Trivia node */
  node: NameTrivia;
  /** Position of the node in this context, eg: Trivia 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type NameTriviaMatchingSearchConstraint = {
  /** A name match must contain ALL of these search terms in at least one of its trivia. */
  allTriviaTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A name match must contain AT LEAST ONE of these search terms in at least one of its trivia. */
  anyTriviaTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type NameWeight = {
  __typename?: 'NameWeight';
  unit: WeightUnit;
  value: Scalars['Float']['output'];
};

/** Generic type for an action link which has a unique name, url, and optionally associated label (localized text) */
export type NamedActionLink = {
  __typename?: 'NamedActionLink';
  /**
   * The name for this action link. Each action link in a list will have a unique name assigned.
   * This name will persist, allowing client to identify the action link by its name.
   */
  actionName: Scalars['ActionLinkName']['output'];
  /**
   * Optional label (localized text) to associate with URL.
   * The label could be used with a button, text link, or other UI component.
   */
  label?: Maybe<CallToActionText>;
  /** The URL for the action link */
  url: Scalars['String']['output'];
};

export type NearbyCinemasFilter = {
  /**
   * Filter cinemas based on favorite status.
   * If not provided, defaults to return all cinemas.
   * Specifying `favorites` will make the query personalized, so it will result in the query not being cached.
   */
  favorites?: InputMaybe<FavoriteFilterOption>;
  /** Filter cinemas based on location. */
  location: ShowtimesLocation;
};

/**
 * A negative format, along with any attributes. For example, we could have 70MM film that was used for the IMAX and IMAX3D
 * versions.
 */
export type NegativeFormat = {
  __typename?: 'NegativeFormat';
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** Negative format as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationProperty;
  /** The negative format */
  negativeFormat: Scalars['String']['output'];
};

/** Negative formats for this title. */
export type NegativeFormats = {
  __typename?: 'NegativeFormats';
  /** The list of negative format items */
  items: Array<Maybe<NegativeFormat>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of negative format items */
  total: Scalars['Int']['output'];
};

/** News details */
export type News = {
  __typename?: 'News';
  /** The title text of this news article */
  articleTitle: Markdown;
  /** The byline of this news article */
  byline?: Maybe<Scalars['String']['output']>;
  /** The date of this news article */
  date: Scalars['Date']['output'];
  /** A direct link to the article on an external news site (if available) */
  externalUrl?: Maybe<Scalars['String']['output']>;
  /** Unique persistent ID for this news article */
  id: Scalars['ID']['output'];
  /** An image associated with this news article */
  image?: Maybe<Image>;
  /** The language of this news article */
  language?: Maybe<DisplayableLanguage>;
  /** Duplicate or very similar news articles are aggregated here */
  similarNewsItems?: Maybe<Array<Maybe<News>>>;
  /** Name and link to homepage for the source website of this news article */
  source: NewsSource;
  /** The lead paragraph of this news article */
  text: Markdown;
};

/**
 * Categories of news articles.
 *
 * This contains both Consumer and Pro categories.
 *
 * The newsCategories() query can be used to fetch additional metadata
 * for each enum value and to fetch specifically Consumer or Pro sets of categories.
 */
export enum NewsCategory {
  AllIndustry = 'ALL_INDUSTRY',
  AwardsAndEvents = 'AWARDS_AND_EVENTS',
  Celebrity = 'CELEBRITY',
  DevelopmentAndProduction = 'DEVELOPMENT_AND_PRODUCTION',
  Indie = 'INDIE',
  InterviewsProfilesAndThinkPieces = 'INTERVIEWS_PROFILES_AND_THINK_PIECES',
  Movie = 'MOVIE',
  ReleasesAndPremieres = 'RELEASES_AND_PREMIERES',
  Results = 'RESULTS',
  ReviewsAndRecaps = 'REVIEWS_AND_RECAPS',
  TheBusiness = 'THE_BUSINESS',
  Top = 'TOP',
  TopIndustry = 'TOP_INDUSTRY',
  Tv = 'TV'
}

/**
 * Specifies which types of news categories we want to return.
 *
 * domain can be used to return only Consumer or only Pro categories.
 */
export type NewsCategoryConstraints = {
  /** Specifies which domain to fetch news categories for */
  domain?: InputMaybe<BusinessDomain>;
};

/** Additional metadata about NewsCategory enum values */
export type NewsCategoryMetadata = {
  __typename?: 'NewsCategoryMetadata';
  /** The NewsCategory enum value that corresponds to this metadata */
  category: NewsCategory;
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

/** Pagination for news articles which always has a known total number of edges. */
export type NewsConnection = {
  __typename?: 'NewsConnection';
  /** Pages of news */
  edges: Array<Maybe<NewsEdge>>;
  /** Details of the page */
  pageInfo: NewsPageInfo;
  restriction?: Maybe<NewsRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of news articles. */
export type NewsEdge = {
  __typename?: 'NewsEdge';
  /** A news node */
  node: News;
};

export type NewsEntity = Company | Name | Title;

export type NewsLink = {
  __typename?: 'NewsLink';
  label?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

/** Page info of news articles. */
export type NewsPageInfo = {
  __typename?: 'NewsPageInfo';
  /** When paginating forwards, the cursor to continue */
  endCursor?: Maybe<Scalars['ID']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
};

export type NewsRestriction = {
  __typename?: 'NewsRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

/** A news source */
export type NewsSource = {
  __typename?: 'NewsSource';
  /** Text description of the source, which is only populated if homepage is undefined */
  description?: Maybe<Scalars['String']['output']>;
  /** Link to the homepage of the site (if available) */
  homepage?: Maybe<NewsLink>;
  /** The icon associated with this news source */
  icon?: Maybe<NewsSourceIconImage>;
  /** Unique persistent ID for this news source */
  id: Scalars['ID']['output'];
  /** Field to indicate that this news source has been verified to be a trusted news source by IMDb */
  trustedSource: Scalars['Boolean']['output'];
};

export type NewsSourceIconImage = {
  __typename?: 'NewsSourceIconImage';
  /** Height of the icon image, in pixels */
  height?: Maybe<Scalars['Int']['output']>;
  /** URL of the NewsSource icon image */
  url?: Maybe<Scalars['String']['output']>;
  /** Width of the icon image, in pixels */
  width?: Maybe<Scalars['Int']['output']>;
};

export type NickName = {
  __typename?: 'NickName';
  /** The nickname as a displayable property */
  displayableProperty: DisplayableNickNameProperty;
  text: Scalars['String']['output'];
};

export type Nomination = {
  __typename?: 'Nomination';
  /**
   * The award this nomination is associated with
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  award?: Maybe<NominationAward>;
  /**
   * Company/Companies, Title(s) and/or name(s) the award is for
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  awardedEntities?: Maybe<NominationAwardedEntities>;
  /**
   * The category in which the award was given. Example: Best Motion Picture of the Year.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  category?: Maybe<AwardCategory>;
  /**
   * The event this nomination is associated with
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  event?: Maybe<NominationEvent>;
  /**
   * The event edition this nomination associated with
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  eventEdition?: Maybe<NominationEventEdition>;
  /**
   * Optional specific episode(s) for which the nomination is associated with
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  forEpisodes?: Maybe<Array<Maybe<Title>>>;
  /**
   * Optional song title(s) for which the nomination is associated with
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  forSongTitles?: Maybe<Array<Maybe<DisplayableSongTitle>>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * Did the awarded entities win this award
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  isWinner?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Additional notes associated with the award.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  notes?: Maybe<Markdown>;
  /**
   * Optional date and time when the award win was officially announced.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  winAnnouncementDate?: Maybe<DisplayableDate>;
  /**
   * The ranking of this nomination, when applicable.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  winningRank?: Maybe<Scalars['Int']['output']>;
};

export type NominationAward = {
  __typename?: 'NominationAward';
  /** Award Id */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** Nominations for an award grouped by its category */
  nominationCategories?: Maybe<NominationsWithCategoryConnection>;
  /** Award name */
  text: Scalars['String']['output'];
};


export type NominationAwardNominationCategoriesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<AwardNominationCategoriesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type NominationAwardedEntities = AwardedCompanies | AwardedNames | AwardedTitles;

export type NominationCategoriesFilter = {
  /** Filter out given nomination award categories */
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter for given nomination award categories */
  includeCategories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type NominationConnection = {
  __typename?: 'NominationConnection';
  /** Pages of award nominations */
  edges: Array<Maybe<NominationEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type NominationEdge = {
  __typename?: 'NominationEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An award nomination node */
  node: Nomination;
  /** Position of the node in this context, eg: Nomination 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type NominationEvent = {
  __typename?: 'NominationEvent';
  /** Other Event names by which this Event is known, default sort order is alphabetically */
  akas: Array<Maybe<NominationEventAka>>;
  /** A list of all distinct awards across event's editions sorted alphabetically */
  awards: Array<Maybe<NominationAward>>;
  /**
   * A list of all the event's editions sorted by year, followed by
   * instanceWithinYear, with the most recent first (e.g. 2023, 2022 edition 2,
   * 2022 edition 1, ...)
   */
  editions: Array<Maybe<NominationEventEdition>>;
  id: Scalars['ID']['output'];
  /** The location of the event */
  location?: Maybe<DisplayableLocation>;
  /** Event name */
  name: NominationEventName;
  /** List of trivia items related to the event with potential markdown links for movies/people */
  trivia: Array<Maybe<Markdown>>;
  /** The urls for the event */
  urls: Array<Maybe<EventUrl>>;
};


export type NominationEventAkasArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type NominationEventAwardsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type NominationEventEditionsArgs = {
  filter?: InputMaybe<NominationEventEditionFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type NominationEventTriviaArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type NominationEventUrlsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type NominationEventAka = {
  __typename?: 'NominationEventAka';
  /** End year associated with the event name */
  endYear?: Maybe<Scalars['Int']['output']>;
  /** Name of the event */
  name: NominationEventName;
  /** Start year associated with the event name */
  startYear?: Maybe<Scalars['Int']['output']>;
};

export type NominationEventEdition = {
  __typename?: 'NominationEventEdition';
  /** A list of awards announced in an event edition e.g. 'Oscar' */
  awards: Array<Maybe<NominationAward>>;
  /**
   * Dates over which this event edition occurred or will occur. Field is null means the date(s) of the event are not known.
   * If event was a 1 day event endDate will be null.
   */
  dateRange?: Maybe<DisplayableDateRange>;
  /** The event to which this edition is a part of, e.g. Academy Awards */
  event: NominationEvent;
  id: Scalars['ID']['output'];
  /** A number that defines the sequence of editions within a year, starting with 1 */
  instanceWithinYear: Scalars['Int']['output'];
  /** List of trivia items related to the event edition with potential markdown links for movies/people */
  trivia: Array<Maybe<Markdown>>;
  /** The year this edition of the event took place */
  year: Scalars['Int']['output'];
};


export type NominationEventEditionAwardsArgs = {
  filter?: InputMaybe<NominationEventEditionAwardsFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type NominationEventEditionTriviaArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type NominationEventEditionAwardsFilter = {
  /** Filter awards by award id */
  awards?: InputMaybe<AwardsFilter>;
};

export type NominationEventEditionFilter = {
  /** Filter out given instances order within the year. e.g [1, 2] */
  excludeInstancesWithinYear?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Filter out given EventEdition years */
  excludeYears?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Filter for given instances order within the year. e.g [1, 2] */
  includeInstancesWithinYear?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Filter for given EventEdition years */
  includeYears?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

export type NominationEventName = {
  __typename?: 'NominationEventName';
  /** Type token */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** The display text */
  text: Scalars['String']['output'];
};

export type NominationsFilter = {
  /** Filter awards by award id */
  awards?: InputMaybe<AwardsFilter>;
  /** Filter awards by event id */
  events?: InputMaybe<EventsFilter>;
  /** Filter nominations on win status */
  wins?: InputMaybe<WinsFilter>;
};

export type NominationsSort = {
  by: NominationsSortBy;
  order: SortOrder;
};

/** Default sort is done by sorting nomination id */
export enum NominationsSortBy {
  /** Sorts by prestigious awards first, then reverse chronological by year */
  Prestigious = 'PRESTIGIOUS',
  /** Sorts by wins first, then preserve default nomination order */
  Wins = 'WINS'
}

export type NominationsWithCategory = {
  __typename?: 'NominationsWithCategory';
  /** The category of the nomination e.g. 'Best Picture'. If no category exist for a nomination, category is returns null. */
  category?: Maybe<AwardCategory>;
  /** Nominations belong to the category */
  nominations?: Maybe<NominationConnection>;
};


export type NominationsWithCategoryNominationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<NominationsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<NominationsSort>;
};

/** Pagination for NominationsWithCategory types which always has a known total number of edges. */
export type NominationsWithCategoryConnection = {
  __typename?: 'NominationsWithCategoryConnection';
  /** Pages of nominations with category */
  edges: Array<Maybe<NominationsWithCategoryEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of nominations with category */
export type NominationsWithCategoryEdge = {
  __typename?: 'NominationsWithCategoryEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An NominationsWithCategory node */
  node: NominationsWithCategory;
  /** Position of the node in this context, eg: NominationsWithCategory 4 out of 312 */
  position: Scalars['Int']['output'];
};

export type OccupationValue = {
  __typename?: 'OccupationValue';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type OpeningWeekendBoxOfficeGrossConnection = {
  __typename?: 'OpeningWeekendBoxOfficeGrossConnection';
  /** Pages of opening weekend box office grosses */
  edges: Array<Maybe<OpeningWeekendBoxOfficeGrossEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type OpeningWeekendBoxOfficeGrossEdge = {
  __typename?: 'OpeningWeekendBoxOfficeGrossEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An opening weekend box office gross node */
  node: OpeningWeekendGross;
  /** Position of the node in this context, eg: opening weekend box office gross 4 out of 31 */
  position: Scalars['Int']['output'];
};

/**
 * Only opening weekend grosses for Box Office areas specified in the filter will be returned.
 * If the filter isn't provided, opening weekend grosses for all available Box Office areas will be returned.
 * If a specified Box Office area doesn't exist or no opening weekend grosses are available for it, nothing will be returned.
 */
export type OpeningWeekendBoxOfficeGrossFilter = {
  boxOfficeAreaCodes: Array<InputMaybe<Scalars['String']['input']>>;
};

export type OpeningWeekendGross = {
  __typename?: 'OpeningWeekendGross';
  /** The BoxOfficeAreaType the gross is related to. */
  boxOfficeAreaType: BoxOfficeAreaType;
  /** The opening weekend gross for the title within the area, between the start and end dates. */
  gross: BoxOfficeGross;
  /** The theater count for the title within the area, between the start and end dates. */
  theaterCount?: Maybe<Scalars['Int']['output']>;
  /** The last day of the opening weekend for the title within the area. */
  weekendEndDate: Scalars['Date']['output'];
  /** The first day of the opening weekend for the title within the area. */
  weekendStartDate?: Maybe<Scalars['Date']['output']>;
};

/**
 * Country contribution guidelines:
 * https://help.imdb.com/article/contribution/titles/countries/GTSW4DN8H8LKCXER
 */
export type OriginCountrySearchConstraint = {
  /**
   * Match titles that are at least partially from ALL of these countries
   * Country code in ISO 3166 (IMDbLocaleConfig:region_codes.json)
   * Example: To match titles that are at least partially from US and GB: ['US', 'GB']
   */
  allCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Match titles that are at least partially from AT LEAST ONE of these countries
   * Country code in ISO 3166 (IMDbLocaleConfig:region_codes.json)
   * Example: To match titles that are at least partially from US or GB: ['US', 'GB']
   */
  anyCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Match titles that are primarily from AT LEAST ONE of these countries
   * Country code in ISO 3166 (IMDbLocaleConfig:region_codes.json)
   * Example: To match titles that are from US or GB: ['US', 'GB']
   */
  anyPrimaryCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Exclude titles that are at least partially from AT LEAST ONE of these countries
   * Country code in ISO 3166 (IMDbLocaleConfig:region_codes.json)
   * Example: To match titles that are at least partially not from US or GB: ['US', 'GB']
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Exclude titles that are primarily from ONE of these countries
   * Country code in ISO 3166 (IMDbLocaleConfig:region_codes.json)
   * Example: To match titles that are not from US or GB: ['US', 'GB']
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludePrimaryCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Input for the outstreamVideoAdApp API used to provide context for and decorate the VAES request. */
export type OutstreamAdParametersApp = {
  /** Parameters representing contextual client data used to form the request URL returned by the outstreamVideoAdApp API. */
  adParametersApp: AdParametersApp;
  /**
   * The placement type used in the technical implementation of this video ad - i.e. preroll, postroll, outstream.
   * If this field is used, its value will replace the default value of 'outstream'
   * used in the VAES URL returned by the outstreamVideoAdApp API.
   * This field is intended to be used as an override when the client's ad
   * implementation differs from the default 'outstream' type.
   */
  overridePlacementType?: InputMaybe<VideoPlacementType>;
};

export type OverrideLiveEventInput = {
  /** Id for award associated with the specified event. Ex: aw0000016 for 'Oscar' */
  awardId: Scalars['ID']['input'];
  /** Event edition id. Ex: ee0131659 for Oscars 2022 */
  eventEditionId: Scalars['ID']['input'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue */
  endCursor?: Maybe<Scalars['ID']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue */
  startCursor?: Maybe<Scalars['ID']['output']>;
};

export type PaginatedTitles = {
  __typename?: 'PaginatedTitles';
  paginationToken?: Maybe<Scalars['String']['output']>;
  titles: Array<Maybe<Title>>;
};

export type PaginatedVideos = {
  __typename?: 'PaginatedVideos';
  /**
   * The pagination token. Use this value as the token parameter on the
   * next call to get the next page of results
   */
  paginationToken?: Maybe<Scalars['String']['output']>;
  /** List of Video Entities returned by a query */
  videos: Array<Maybe<Video>>;
};

/** Parents guides for a given title */
export type ParentsGuide = {
  __typename?: 'ParentsGuide';
  categories?: Maybe<Array<Maybe<ParentsGuideCategorySummary>>>;
  guideItems?: Maybe<ParentsGuideConnection>;
};


/** Parents guides for a given title */
export type ParentsGuideCategoriesArgs = {
  filter?: InputMaybe<ParentsGuideCategoryFilter>;
};


/** Parents guides for a given title */
export type ParentsGuideGuideItemsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ParentsGuideFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Parents guide category details */
export type ParentsGuideCategory = {
  __typename?: 'ParentsGuideCategory';
  /** Parents guide category ID */
  id: Scalars['ID']['output'];
  /** The language the text is written in */
  language: DisplayableLanguage;
  /** The displayable text type of the parents guide category, e.g. 'Violence & Gore' */
  text: Scalars['String']['output'];
};

export type ParentsGuideCategoryFilter = {
  spoilers?: InputMaybe<FilterSpoilers>;
};

/** Parents guide severity summary */
export type ParentsGuideCategorySummary = {
  __typename?: 'ParentsGuideCategorySummary';
  /** Category for the guide, e.g. 'Violence & Gore' */
  category: ParentsGuideCategory;
  /** Parents guides for a given category */
  guideItems?: Maybe<ParentsGuideConnection>;
  /** Displayable severity of this category */
  severity?: Maybe<SeverityLevel>;
  /** A breakdown of the severity levels for this category */
  severityBreakdown?: Maybe<Array<Maybe<SeverityLevel>>>;
  /** Total number of users who voted on the severity levels in this category */
  totalSeverityVotes: Scalars['Int']['output'];
};


/** Parents guide severity summary */
export type ParentsGuideCategorySummaryGuideItemsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Pagination for parents guide items */
export type ParentsGuideConnection = {
  __typename?: 'ParentsGuideConnection';
  /** Pages of parents guides */
  edges: Array<Maybe<ParentsGuideEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of parents guide items */
export type ParentsGuideEdge = {
  __typename?: 'ParentsGuideEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A parents guide item */
  node: ParentsGuideItem;
  /** Position of the node in this context, eg: Parents Guide 4 out of 312 */
  position: Scalars['Int']['output'];
};

export type ParentsGuideFilter = {
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  spoilers?: InputMaybe<FilterSpoilers>;
};

export type ParentsGuideItem = {
  __typename?: 'ParentsGuideItem';
  /**
   * The category of parents guide, e.g. 'violenceGuide'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  category: ParentsGuideCategory;
  /**
   * Returns the parental guide correction link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  correctionLink?: Maybe<ContributionLink>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * Is this guide a spoiler
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  isSpoiler: Scalars['Boolean']['output'];
  /**
   * Returns the parental guide reporting link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  reportingLink?: Maybe<ContributionLink>;
  /**
   * The parents guide text, including markdown if present
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  text: Markdown;
  /**
   * The title related to the parental guide
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  title?: Maybe<Title>;
};


export type ParentsGuideItemCorrectionLinkArgs = {
  contributionContext: ContributionContext;
};


export type ParentsGuideItemReportingLinkArgs = {
  contributionContext: ContributionContext;
};

export type PersonalDetailsOutput = {
  __typename?: 'PersonalDetailsOutput';
  /** Current country or region of user's residence. ID in ISO 3166 format. */
  countryOfResidence?: Maybe<Scalars['ID']['output']>;
  /** User's date of birth in ISO-8601 format (YYYY-MM-DD) */
  dateOfBirth?: Maybe<Scalars['Date']['output']>;
  /** Currently set gender of user. */
  gender?: Maybe<Scalars['String']['output']>;
};

export type PersonalEmployment = {
  __typename?: 'PersonalEmployment';
  branch?: Maybe<CompanyBranch>;
  company: Company;
  employeeContact?: Maybe<CompanyContactDetails>;
  id: Scalars['ID']['output'];
  jobTitle?: Maybe<LocalizedString>;
  name: Name;
  occupation?: Maybe<OccupationValue>;
};

export type PersonalizedSuggestedVideosConnection = {
  __typename?: 'PersonalizedSuggestedVideosConnection';
  edges: Array<Maybe<PersonalizedSuggestedVideosEdge>>;
  pageInfo: PageInfo;
};

export type PersonalizedSuggestedVideosEdge = {
  __typename?: 'PersonalizedSuggestedVideosEdge';
  cursor: Scalars['ID']['output'];
  node: Video;
  position: Scalars['Int']['output'];
};

/** Provides context for the location of the list widget on client */
export type PlacementContext = {
  /** The page type the query was made from e.g. home, title */
  pageType?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Key-value pair for PLAID overrides, formatted as a PLAID CSS property and its value
 * (e.g. { key: "baseAltShade1", value: "#0f0f0f" }
 * )
 */
export type PlaidOverride = {
  __typename?: 'PlaidOverride';
  /** The key for the PLAID override */
  key: Scalars['String']['output'];
  /** The value for the PLAID override */
  value: Scalars['String']['output'];
};

/** The client platforms that watch options are available on */
export enum PlatformId {
  Android = 'ANDROID',
  AndroidFire = 'ANDROID_FIRE',
  FireTvDetail = 'FIRE_TV_DETAIL',
  Ios = 'IOS',
  MobileWeb = 'MOBILE_WEB',
  Web = 'WEB'
}

/** Link format available for watch options */
export enum PlatformLinkFormatId {
  Android = 'ANDROID',
  AndroidFire = 'ANDROID_FIRE',
  FireTvDetail = 'FIRE_TV_DETAIL',
  Ios = 'IOS',
  Mdot = 'MDOT',
  Web = 'WEB'
}

/**
 * Represents a single URL that can be used for video playback. Contains the mime type and
 * definition of content behind the URL.
 */
export type PlaybackUrl = {
  __typename?: 'PlaybackURL';
  /**
   * A description of playback experience suitable for displaying to the customer to
   * set expectations or be leveraged in via in player URL selection.
   * Examples include short qualitative descriptions like 780p, SD, or Ultra HD
   */
  displayName: LocalizedString;
  /** Metric dimensions about the playback URL. Maximum of 5 metric dimensions. */
  metricDimensions?: Maybe<Array<Maybe<MetricDimension>>>;
  /**
   * The URL that can be given to the player to view this videos content. It may or may
   * not be valid for a limited time and thus is intended for immediate use by the caller.
   */
  url: Scalars['URL']['output'];
  /** Describes the resolution of the content behind the URL. */
  videoDefinition: VideoDefinition;
  /**
   * Mime type in the enum format that describes the content behind the URL. Suitable for
   * supplying to the browser or video player.
   */
  videoMimeType: VideoMimeType;
};

export type Plot = {
  __typename?: 'Plot';
  /**
   * The name of the plot's author. This field is not required as it can be null for an anonymous author.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  author?: Maybe<Scalars['String']['output']>;
  /**
   * Returns the plot correction link or null if a non-english plot or a plot synopsis.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  correctionLink?: Maybe<ContributionLink>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * Whether this plot contains spoilers
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  isSpoiler?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The language of the plot text
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  language?: Maybe<DisplayableLanguage>;
  /**
   * The plot text
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  plotText?: Maybe<Markdown>;
  /**
   * The type of the plot
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  plotType?: Maybe<PlotType>;
  /**
   * Returns the plot reporting link or null if a non-english plot or a plot synopsis.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  reportingLink?: Maybe<ContributionLink>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  restriction?: Maybe<PlotRestriction>;
  /**
   * Title related to the plot
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  title?: Maybe<Title>;
};


export type PlotCorrectionLinkArgs = {
  contributionContext: ContributionContext;
};


export type PlotReportingLinkArgs = {
  contributionContext: ContributionContext;
};

/** Pagination for plot types which always has a known total number of edges. */
export type PlotConnection = {
  __typename?: 'PlotConnection';
  /** Pages of plots */
  edges: Array<Maybe<PlotEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  restriction?: Maybe<PlotRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of plots */
export type PlotEdge = {
  __typename?: 'PlotEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A plot node */
  node: Plot;
  /** Position of the node in this context, eg: Plot 4 out of 31 */
  position: Scalars['Int']['output'];
};

/**
 * Example: if you want to match titles of plot summary/outline 'Mushroom-Kingdom' OR 'Mysterious', PLUS
 * the title must contain 'bloodthirsty', PLUS the title had the plot written by 'huggo' OR 'guy',
 * specify anyPlotTextTerms: ['mushroom-kingdom', 'mysterious'] plus
 * allPlotTextTerms: ['bloodthirsty'] plus plotAuthor: ['huggo', 'guy']
 */
export type PlotMatchingSearchConstraint = {
  /** A title match must contain ALL of these search terms */
  allPlotTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain a plot written by AT LEAST ONE of these authors */
  anyPlotAuthors?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these search terms */
  anyPlotTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Information about restrictions applied to plot */
export type PlotRestriction = {
  __typename?: 'PlotRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
};

/**
 * Our legacy plot types.
 * Here to support existing features that requires knowing this to power business logic.
 */
export enum PlotType {
  Outline = 'OUTLINE',
  Summary = 'SUMMARY',
  Synopsis = 'SYNOPSIS'
}

export type Poll = {
  __typename?: 'Poll';
  /**
   * Answers for the poll, by default it returns the list in a consistent order defined by the author.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  answers: PollAnswersConnection;
  /**
   * Author of this poll.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  author: UserProfile;
  /**
   * The date when the poll was created.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  createDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The id of the list that the poll is created from.
   * Required for legacy pollId to listId redirection.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  createdFromListId: Scalars['ID']['output'];
  /**
   * Vote from the current logged in customer (if x-imdb-customer-id header is present).
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  currentCustomerVote?: Maybe<PollVote>;
  /**
   * Description of the poll.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  description?: Maybe<Markdown>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  id: Scalars['ID']['output'];
  /**
   * Whether the poll is closed for voting.
   * Closed polls and its results can be viewed but not voted on.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  isClosed: Scalars['Boolean']['output'];
  /**
   * Primary image for poll, nullable response
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  primaryImage?: Maybe<PollPrimaryImage>;
  /**
   * Poll question, E.g., Favorite 'TITLE' Character.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  question: PollQuestion;
  /**
   * Returns most recent votes on this poll, from latest to earliest.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  recentVotes?: Maybe<PollVoteConnection>;
  /**
   * Returns the list of related polls to this poll in random order.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  relatedPolls?: Maybe<PollsConnection>;
  /**
   * Total vote count on the poll across all answers.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  totalVotes: Scalars['Int']['output'];
  /**
   * Entity Type of the poll answer item (Title/Name/Image).
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  type: PollAnswerItemType;
};


export type PollAnswersArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<PollAnswerSort>;
};


export type PollRecentVotesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


export type PollRelatedPollsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};

export enum PollAdminAction {
  /** Admin created a new poll from a list. */
  Create = 'CREATE',
  /** Admin synced an existing poll with the list. */
  Sync = 'SYNC'
}

/** Entity type to represent a poll admin activity on the poll. */
export type PollAdminActivity = {
  __typename?: 'PollAdminActivity';
  /** The actual action made on the poll (create/sync). */
  action: PollAdminAction;
  /** Time when the action was made on the poll. */
  actionTime: Scalars['DateTime']['output'];
  /** Admin User who made the action on the poll. */
  admin: UserProfile;
  /** The poll on which the action was made. */
  poll: Poll;
};

export type PollAdminActivityConnection = {
  __typename?: 'PollAdminActivityConnection';
  edges: Array<Maybe<PollAdminActivityEdge>>;
  pageInfo: PageInfo;
  total?: Maybe<Scalars['Int']['output']>;
};

export type PollAdminActivityEdge = {
  __typename?: 'PollAdminActivityEdge';
  cursor: Scalars['ID']['output'];
  node: PollAdminActivity;
};

export type PollAnswer = {
  __typename?: 'PollAnswer';
  /**
   * Integer index of this answer in the poll. Defined by the poll author.
   * Answer indices are not subject to ever change.
   */
  answerIndex: Scalars['Int']['output'];
  /** Optional description of the answer. */
  description?: Maybe<Markdown>;
  item: AnswerItem;
  /** Percentage of total votes on this answer. */
  votePercentage: Scalars['Float']['output'];
  /** Total number of votes for this answer. */
  votes: Scalars['Int']['output'];
};

export type PollAnswerEdge = {
  __typename?: 'PollAnswerEdge';
  cursor: Scalars['ID']['output'];
  node: PollAnswer;
};

export enum PollAnswerItemType {
  Image = 'IMAGE',
  Name = 'NAME',
  Title = 'TITLE'
}

/** Sort input for poll answers */
export type PollAnswerSort = {
  by?: InputMaybe<PollAnswerSortBy>;
  order?: InputMaybe<SortOrder>;
};

/** Enum for poll answer sort options */
export enum PollAnswerSortBy {
  /**
   * Sort answers by author defined index value.
   * ASC: From the least (1) to the greatest number.
   */
  AnswerIndex = 'ANSWER_INDEX',
  /**
   * Sort answers based on their vote count.
   * DESC: From greatest number to the least number. For same vote count, least ANSWER_INDEX first.
   */
  VoteCount = 'VOTE_COUNT'
}

export type PollAnswersConnection = {
  __typename?: 'PollAnswersConnection';
  edges: Array<Maybe<PollAnswerEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type PollEdge = {
  __typename?: 'PollEdge';
  cursor: Scalars['ID']['output'];
  node: Poll;
};

/** Poll filter options. */
export type PollFilter = {
  /** False by default, if true, closed polls will not be returned. */
  excludeClosed?: InputMaybe<Scalars['Boolean']['input']>;
  /** False by default, if true, polls voted by the logged in customer will not be returned. (Ignored if x-imdb-customer-id header is not present.) */
  excludeVoted?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PollPrimaryImage = {
  __typename?: 'PollPrimaryImage';
  image: Image;
};

export type PollQuestion = {
  __typename?: 'PollQuestion';
  originalText: Markdown;
};

/** Sort input for polls */
export type PollSort = {
  by?: InputMaybe<PollSortBy>;
  order?: InputMaybe<SortOrder>;
};

/** Enum for poll sort options */
export enum PollSortBy {
  /**
   * Sort polls based on their create time.
   * DESC: From latest to earliest.
   */
  CreateTime = 'CREATE_TIME'
}

/** Entity type to represent a vote on the poll. */
export type PollVote = {
  __typename?: 'PollVote';
  /** The answer item of vote. */
  answer: AnswerItem;
  /** Integer index of this answer in the poll. */
  answerIndex: Scalars['Int']['output'];
  /** The poll on which the vote was made. */
  poll: Poll;
  /** User who voted on the poll. */
  user: UserProfile;
  /** Time when the vote was made on the poll. */
  voteTime: Scalars['DateTime']['output'];
};

export type PollVoteConnection = {
  __typename?: 'PollVoteConnection';
  edges: Array<Maybe<PollVoteEdge>>;
  pageInfo: PageInfo;
  total?: Maybe<Scalars['Int']['output']>;
};

export type PollVoteEdge = {
  __typename?: 'PollVoteEdge';
  cursor: Scalars['ID']['output'];
  node: PollVote;
};

/**
 * Total will vend total polls returned instead of the absolute total number of polls.
 * PageInfo fields are accurate and will provide information on subsequent pagination requests.
 */
export type PollsConnection = {
  __typename?: 'PollsConnection';
  edges: Array<Maybe<PollEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type PopularTitlesQueryFilter = {
  /** Filter out current user's ratings */
  filterOutUserRatings?: InputMaybe<Scalars['Boolean']['input']>;
  /** Inclusive date range to filter on */
  releaseDateRange?: InputMaybe<DateRange>;
};

/**
 * The location of the client by postal code. The country field is an ISO 3166-1 alpha-2 country code (ex. US or GB).
 * The postalCode field is alpha numeric (ex. 98109 or D-11179).
 */
export type PostalCodeLocation = {
  country: Scalars['String']['input'];
  postalCode: Scalars['String']['input'];
};

export type PredefinedListInput = {
  /**
   * The Class Id associated with the predefined list.
   * For example: classId 'CHECK_INS', or classId 'WATCH_LIST'
   */
  classId: ListClassId;
};

export type PrestigiousAwardSummary = {
  __typename?: 'PrestigiousAwardSummary';
  awardNomination: AwardNomination;
  nominations: Scalars['Int']['output'];
  wins: Scalars['Int']['output'];
};

export type PrimaryProfession = {
  __typename?: 'PrimaryProfession';
  category: CreditCategory;
  profession?: Maybe<Profession>;
};

export type PrimaryWatchOption = {
  __typename?: 'PrimaryWatchOption';
  /** Number provided when there are multiple watch options */
  additionalWatchOptionsCount?: Maybe<Scalars['Int']['output']>;
  watchOption: WatchOption;
};

export type PrincipalCreditsFilter = {
  /** A list of job category ids. User can input 'cast' to filter for 'actor', 'actress' or 'self' */
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type PrincipalCreditsForCategory = {
  __typename?: 'PrincipalCreditsForCategory';
  /** Category (e.g. 'Producer' or 'Actor') */
  category: CreditCategory;
  credits: Array<Maybe<Credit>>;
  /** Restriction related information if exists for the category */
  restriction?: Maybe<CreditRestriction>;
  /** Total number of (principal and non-principal) credits in this category including uncredited credits */
  totalCredits: Scalars['Int']['output'];
};


export type PrincipalCreditsForCategoryCreditsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type PrincipalCreditsForGrouping = {
  __typename?: 'PrincipalCreditsForGrouping';
  /**
   * Returns credits within this grouping.
   *
   * The API is optimized for retrieving principal credits with max-limit 30 (default 10 credits per grouping).
   * For complete credit lists, please use the title.creditGroupings API.
   *
   * Handles both TV series and standard credits with specialized logic. For episode based titles like
   * TV series, podcast etc. episode credits are consolidated to series level while preserving episode counts
   * and consistent role details. Multiple character appearances are unified into single
   * credit entries, with characters ordered by frequency and first appearance. Includes
   * gap detection for optimal credit sequence display.
   *
   * See TitleCreditsV2Sort for how credits are ordered.
   */
  credits: Array<Maybe<CreditV2>>;
  /**
   * Credit Grouping details.
   * Credit groupings are ordered according to a predefined sequence.
   * Groupings not in the predefined list are sorted after all listed groupings.
   */
  grouping: CreditGrouping;
  /** Restriction related information if exists for the grouping */
  restriction?: Maybe<CreditRestriction>;
  /** Total number of (principal and non-principal) credits in this grouping */
  totalCredits: Scalars['Int']['output'];
};


export type PrincipalCreditsForGroupingCreditsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type PrincipalCreditsForGroupingGroupingArgs = {
  groupingTextInput?: InputMaybe<GroupingTextInput>;
};

export type PrincipalCreditsV2Filter = {
  /**
   * Whether to include all credits, only credited, or only uncredited.
   * Default is to include all.
   */
  credited?: InputMaybe<CreditedOrUncreditedFilter>;
  /** Should the response include Appearances (credits with CAST_TRAIT or SELF_TRAIT trait). Default is to include them (true). */
  includeAppearances?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Denotes what kind of principal credits to fetch. Supported modes are:
   *
   * TOP_CAST: Only returns on-screen appearances (credits with CAST_TRAIT trait or SELF_TRAIT trait in a single grouping).
   *
   * DEFAULT: Provide Directors, Writers (includes Head writers within writer
   * grouping) and Appearances for all title types, except TV where we provide
   * Creators and Appearances.
   *
   * EXTENDED: Provide an extended set of credit categories beyond the DEFAULT mode
   * like showrunner, cinematographer etc. Head writers are vended in their own
   * grouping seprate from writers, removing those credits from the writers grouping.
   *
   * NARROWED: Provide up to two categories from DEFAULT; suitable for smaller display surfaces.
   */
  mode?: InputMaybe<Scalars['String']['input']>;
};

/** A printed format, along with any attributes. For example, the BluRay version is 1080p. */
export type PrintedFormat = {
  __typename?: 'PrintedFormat';
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** Printed format as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationProperty;
  /** The printed format */
  printedFormat: Scalars['String']['output'];
};

/** Printed formats for this title. */
export type PrintedFormats = {
  __typename?: 'PrintedFormats';
  /** The list of printed format items */
  items: Array<Maybe<PrintedFormat>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of printed format items */
  total: Scalars['Int']['output'];
};

export type PrivacyDirectives = {
  __typename?: 'PrivacyDirectives';
  /** Encoded consent token using amazon vendor list. */
  avlTcfString?: Maybe<Scalars['String']['output']>;
  /** Encoded token for data sharing and cross-use. */
  crossUseString?: Maybe<Scalars['String']['output']>;
  /**
   * base64 encoded json representation of the privacy directives
   * e.g. eyJkZWNpc2lvbiI6ICJBQ0NFUFRfQUxMIiwicHVycG9zZXMiOiBbMSwgMiwgM10sInZlbmRvcnMiOiBbMywgNSwgN119
   *      Decoded: {"gvlTcfString":"ABCD","avlTcfString":"EFGH",etc}
   */
  directivesCookie: Scalars['String']['output'];
  /** The time after which the privacy directives need to be refreshed. */
  expirationDate: Scalars['DateTime']['output'];
  /** Encoded IAB TCFv2 (Transparency and Consent Framework) token. Uses IAB global vendor list. */
  gvlTcfString?: Maybe<Scalars['String']['output']>;
  /**
   * Granular purpose-level directives from customized privacy preferences
   * If null, do not suppress any purposes
   */
  purposes?: Maybe<Array<Maybe<GranularDirective>>>;
  /**
   * Granular vendor-level directives from customized privacy preferences
   * If null, do not suppress any vendors
   */
  vendors?: Maybe<Array<Maybe<GranularDirective>>>;
};

export type PrivacyDirectivesOutput = {
  __typename?: 'PrivacyDirectivesOutput';
  /**
   * Contains the privacy directives that must be enforced for the user
   * May be empty, in which case there are no privacy directives to enforce.
   * May also return null if privacy enforcement is not launched
   */
  directives?: Maybe<PrivacyDirectives>;
};

export type PrivacyPrompt = {
  __typename?: 'PrivacyPrompt';
  /** Localized text for the accept button. Button sets PrivacyPromptAction in `respondToPrivacyPrompt` mutation */
  acceptButtonLabel: PrivacyPromptText;
  /** Localized text for the customize button. If is null do not display button */
  customizeButtonLabel?: Maybe<PrivacyPromptText>;
  /** A url from which the user can customize their associated privacy preferences. */
  customizeUrl: Scalars['URL']['output'];
  /** Unique identifier for the privacy prompt and its associated terms */
  id: Scalars['ID']['output'];
  /** Gives the localized markdown for this privacy prompt. */
  promptMarkdown: LocalizedMarkdown;
  /** Localized text for the reject button. Button sets PrivacyPromptAction in `respondToPrivacyPrompt` mutation */
  rejectButtonLabel: PrivacyPromptText;
  /** Whether or not the prompt should be shown on page load. */
  showPromptOnPageLoad: Scalars['Boolean']['output'];
};

export type PrivacyPromptInput = {
  /** The type of prompt we want to display */
  type: PrivacyPromptType;
};

export type PrivacyPromptOutput = {
  __typename?: 'PrivacyPromptOutput';
  /**
   * This is the time at which we should
   * re-evaluate whether or not we should prompt the user
   * Clients should consider this response to be stale
   * after this time as an upper limit.
   */
  expirationDate: Scalars['DateTime']['output'];
  /**
   * The consent requirement or empty if the requested consent type is not required
   * for the given user
   */
  privacyPrompt?: Maybe<PrivacyPrompt>;
};

export type PrivacyPromptText = {
  __typename?: 'PrivacyPromptText';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export enum PrivacyPromptType {
  /** The primary consent prompt experience */
  ConsentPrimary = 'CONSENT_PRIMARY'
}

/**
 * ProStatus: contains related pro subscription information.
 *
 * Note: the Pro subscription status is published via Pro subscription service,
 * and may be out of sync with the customer's actual subscription
 */
export type ProStatus = {
  __typename?: 'ProStatus';
  hasSubscription?: Maybe<Scalars['Boolean']['output']>;
};

/**
 * A process used for the film, along with any attributes. For example, CinemaScope may have been used for the IMAX and
 * IMAX3D versions.
 */
export type Process = {
  __typename?: 'Process';
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** Process as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationProperty;
  /** The process */
  process: Scalars['String']['output'];
};

/** Processes for this title. */
export type Processes = {
  __typename?: 'Processes';
  /** The list of process items */
  items: Array<Maybe<Process>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of process items */
  total: Scalars['Int']['output'];
};

/** Official announcements related to a title */
export type ProductionAnnouncement = {
  __typename?: 'ProductionAnnouncement';
  comment?: Maybe<ProductionAnnouncementComment>;
  date: Scalars['Date']['output'];
};

/** Additional information relating to a title's announcement (e.g. a press release link) */
export type ProductionAnnouncementComment = {
  __typename?: 'ProductionAnnouncementComment';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type ProductionBudget = {
  __typename?: 'ProductionBudget';
  budget: Money;
};

export type ProductionDate = {
  __typename?: 'ProductionDate';
  /** Additional attributes (e.g. 'live broadcast') */
  attributes?: Maybe<Array<Maybe<DisplayableAttribute>>>;
  /** Production end date */
  endDate?: Maybe<DisplayableDate>;
  /** Production start date */
  startDate?: Maybe<DisplayableDate>;
};

/** Pagination for ProductionDates types which always has a known total number of edges. */
export type ProductionDatesConnection = {
  __typename?: 'ProductionDatesConnection';
  /** Pages of ProductionDates */
  edges: Array<Maybe<ProductionDatesEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type ProductionDatesEdge = {
  __typename?: 'ProductionDatesEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A ProductionDate node */
  node: ProductionDate;
  /** Position of the node in this context, eg: ProductionDates 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type ProductionStage = {
  __typename?: 'ProductionStage';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  /** Production stage text, e.g. 'In Development', 'Pre-Production', 'Released', etc. */
  text: Scalars['String']['output'];
};

export enum ProductionStageFilter {
  Abandoned = 'ABANDONED',
  Completed = 'COMPLETED',
  InDevelopment = 'IN_DEVELOPMENT',
  InProduction = 'IN_PRODUCTION',
  PostProduction = 'POST_PRODUCTION',
  PreProduction = 'PRE_PRODUCTION',
  Released = 'RELEASED'
}

export type ProductionStatus = {
  __typename?: 'ProductionStatus';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  /** Production status text, e.g. 'Filming', 'Development Unknown', 'Abandoned', etc. */
  text: Scalars['String']['output'];
};

export type ProductionStatusDetails = {
  __typename?: 'ProductionStatusDetails';
  announcements?: Maybe<Array<Maybe<ProductionAnnouncement>>>;
  currentProductionStage: ProductionStage;
  productionStatusHistory?: Maybe<Array<Maybe<ProductionStatusHistory>>>;
  restriction?: Maybe<ProductionStatusHistoryRestriction>;
};

export type ProductionStatusHistory = {
  __typename?: 'ProductionStatusHistory';
  /**
   * An optional user-displayable string providing additional information or
   * context about the status (e.g., 'According to a June casting call, filming
   * will commence in November 2006.')
   */
  comment?: Maybe<ProductionStatusHistoryComment>;
  /** The date when the production status was updated */
  date: Scalars['Date']['output'];
  /** Production stage corresponding to the status */
  stage: ProductionStage;
  /** Production status at a given point in time (excludes 'announced' statuses) */
  status: ProductionStatus;
};

export type ProductionStatusHistoryComment = {
  __typename?: 'ProductionStatusHistoryComment';
  /** An opaque unique identifier for the displayable comment */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** The comment display text */
  text: Scalars['String']['output'];
};

/** Information about restrictions applied to production status */
export type ProductionStatusHistoryRestriction = {
  __typename?: 'ProductionStatusHistoryRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

export type Profession = {
  __typename?: 'Profession';
  /** The primary profession */
  id: Scalars['ID']['output'];
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** The localized text */
  text: Scalars['String']['output'];
};

/**
 * Each NameProfession belongs to a ProfessionCategory.
 * For example, the Makeup Artist profession belongs to the Makeup Department ProfessionCategory.
 *
 * All fields are marked as nullable in case of invalid graphlet cross-link - in practice these should never be null.
 */
export type ProfessionCategory = {
  __typename?: 'ProfessionCategory';
  /**
   * The profession category ID e.g. amzn1.imdb.professionCategory.1.2.3
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * Details of the credit category mapped to profession category
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  linkedCreditCategory?: Maybe<CreditCategory>;
  /**
   * The order to display this profession category when displaying a list of profession categories
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  listOrder?: Maybe<Scalars['Int']['output']>;
  /**
   * Details of the Profession Category
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  text?: Maybe<DisplayableProfessionCategory>;
  /**
   * The unordered set of traits associated with this profession category.
   * Traits are intended to be used as functional categorization markers for applying business logic.
   *
   * Current possible values:
   * - `WORK_TYPE_CREDIT_TRAIT`. Profession categories that are typically credited on titles.
   * - `WORK_TYPE_EMPLOYMENT_TRAIT`. Profession categories that are linked to employment roles (e.g. Executives).
   * - `WORK_TYPE_REPRESENTATION_TRAIT`. Profession categories where the employed name represents clients (e.g. Talent Agents).
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  traits?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Maps a number to a profession */
export type ProfessionCount = {
  __typename?: 'ProfessionCount';
  profession: NameProfession;
  totalCount: Scalars['Int']['output'];
};

export type ProfessionCountsSummary = {
  __typename?: 'ProfessionCountsSummary';
  /**
   * Display text associated with the map of profession counts
   * e.g. "2 talent agents and 1 producer.
   */
  displayableCounts: LocalizedString;
  /**
   * A list of professions mapped to the number of people (of that profession)
   * that have viewed the  page
   */
  professionCounts: Array<Maybe<ProfessionCount>>;
};

export type ProfessionSearchOptions = {
  /**
   * Indicates whether this profession is user selectable.
   * By default, non-user selectable professions will be included in the results.
   */
  isCustomerSelectable?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ProfessionsFilter {
  ExcludePrimaryProfessions = 'EXCLUDE_PRIMARY_PROFESSIONS',
  PrimaryProfessionsOnly = 'PRIMARY_PROFESSIONS_ONLY'
}

export type PromotedVideoAd = {
  __typename?: 'PromotedVideoAd';
  /** Ad feedback URL to be linked in the sponsored label of the ad */
  adFeedbackUrl?: Maybe<Scalars['URL']['output']>;
  /** The video id (viconst) associated with the Promoted Video Ad */
  id: Scalars['ID']['output'];
  /** Third Party trackers as defined by the advertising customer */
  thirdPartyTrackers: ThirdPartyTrackers;
  /**
   * The video object associated with the Promoted Video Ad
   * Throws RESOURCE_NOT_FOUND if the associated video is not available
   */
  video: Video;
};

/** Required and optional parameters to request a Promoted Video Ad from AAX with context from the client */
export type PromotedVideoAdParameters = {
  /** Optional CreativeId if an ad is being forced by a Freedonia override */
  adOverrideCreativeId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Required and optional parameters used to form the Amazon Ad Exchange request from the context of the app client
   * Throws GRAPHQL_VALIDATION_FAILED if adParametersApp is not available for Mobile App requests
   */
  adParametersApp?: InputMaybe<AdParametersApp>;
};

/** Enum representing prompt types */
export enum PromptType {
  /** Ratings prompt on title main page */
  RatingsTitleMain = 'RATINGS_TITLE_MAIN',
  /** Ratings prompt on title trivia sub-page */
  RatingsTitleTrivia = 'RATINGS_TITLE_TRIVIA'
}

export enum PublicationStatus {
  NotPublished = 'NOT_PUBLISHED',
  Published = 'PUBLISHED',
  Redirected = 'REDIRECTED'
}

export type PublicityArticle = PublicityListingType & {
  __typename?: 'PublicityArticle';
  authors?: Maybe<Array<Maybe<Markdown>>>;
  category: PublicityListingCategory;
  date?: Maybe<Scalars['Date']['output']>;
  /** The publicity listing as a displayable property */
  displayableProperty: DisplayablePublicityListingProperty;
  language?: Maybe<DisplayableLanguage>;
  publication?: Maybe<Scalars['String']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  region?: Maybe<DisplayableCountry>;
  title?: Maybe<PublicityListingTitleText>;
};

export type PublicityCategoryWithListings = {
  __typename?: 'PublicityCategoryWithListings';
  category: PublicityListingCategory;
  publicityListings?: Maybe<PublicityListingConnection>;
};


export type PublicityCategoryWithListingsPublicityListingsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type PublicityInterview = PublicityListingType & {
  __typename?: 'PublicityInterview';
  authors?: Maybe<Array<Maybe<Markdown>>>;
  category: PublicityListingCategory;
  date?: Maybe<Scalars['Date']['output']>;
  /** The publicity listing as a displayable property */
  displayableProperty: DisplayablePublicityListingProperty;
  language?: Maybe<DisplayableLanguage>;
  publication?: Maybe<Scalars['String']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  region?: Maybe<DisplayableCountry>;
  title?: Maybe<PublicityListingTitleText>;
};

/** A category of publicity listings describing the nature of a subset of listings, e.g. 'Article' */
export type PublicityListingCategory = {
  __typename?: 'PublicityListingCategory';
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

/** Pagination for Publicity Listing types which always has a known total number of edges. */
export type PublicityListingConnection = {
  __typename?: 'PublicityListingConnection';
  /** Pages of publicityListings */
  edges: Array<Maybe<PublicityListingEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of publicityListings */
export type PublicityListingEdge = {
  __typename?: 'PublicityListingEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A PublicityListing node */
  node: PublicityListingType;
  /** Position of the node in this context, eg: PublicityListing 4 out of 312 */
  position: Scalars['Int']['output'];
};

export type PublicityListingTitleText = {
  __typename?: 'PublicityListingTitleText';
  language?: Maybe<DisplayableLanguage>;
  text?: Maybe<Scalars['String']['output']>;
};

export type PublicityListingType = {
  category: PublicityListingCategory;
};

export type PublicityListingsFilter = {
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type PublicityMagazineCover = PublicityListingType & {
  __typename?: 'PublicityMagazineCover';
  authors?: Maybe<Array<Maybe<Markdown>>>;
  category: PublicityListingCategory;
  date?: Maybe<Scalars['Date']['output']>;
  /** The publicity listing as a displayable property */
  displayableProperty: DisplayablePublicityListingProperty;
  language?: Maybe<DisplayableLanguage>;
  publication?: Maybe<Scalars['String']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  region?: Maybe<DisplayableCountry>;
  title?: Maybe<PublicityListingTitleText>;
};

export type PublicityPictorial = PublicityListingType & {
  __typename?: 'PublicityPictorial';
  authors?: Maybe<Array<Maybe<Markdown>>>;
  category: PublicityListingCategory;
  date?: Maybe<Scalars['Date']['output']>;
  /** The publicity listing as a displayable property */
  displayableProperty: DisplayablePublicityListingProperty;
  language?: Maybe<DisplayableLanguage>;
  publication?: Maybe<Scalars['String']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  region?: Maybe<DisplayableCountry>;
  title?: Maybe<PublicityListingTitleText>;
};

/** Push notification metadata for an authenticated user. */
export type PushNotificationUserSettings = {
  __typename?: 'PushNotificationUserSettings';
  /** Push notification ID for the authenticated user. */
  pushNotificationUserId: Scalars['ID']['output'];
};

/** Query */
export type Query = {
  __typename?: 'Query';
  /**
   * Retrieves the data for displaying account data access dialogs. The function
   * returns the text to be displayed for REQUEST, CONFIRM
   *
   * ---------------------
   * Graphlet Details:
   * - Name: privacy
   * - CTI: IMDb/GraphQL/Privacy
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-detected-country-region, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  accountDataDialog: AccountDataDialogOutput;
  /**
   * Search all IMDb names based on a wide variety of constraints
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  advancedNameSearch?: Maybe<AdvancedNameSearchConnection>;
  /**
   * Search all IMDb titles based on a wide variety of constraints.
   *
   * If a Pro-only constraint is used, the x-imdb-customer-id header is required.
   *
   * The following errors can occur if a Pro-only constraint is used:
   *   Throws UNAUTHENTICATED if not logged in
   *   Throws FORBIDDEN if customer w/o any IMDbPro subscription
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  advancedTitleSearch?: Maybe<AdvancedTitleSearchConnection>;
  /**
   * Used to fetch advertising related information for IMDb mobile apps.
   * Returns an object containing eligibility for apps to serve 3p ads and a configuration map for the slots on each page.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  appAdsInfo?: Maybe<AppAdsInfoOutput>;
  /**
   * Used to fetch advertising related information for IMDb mobile apps.
   * Returns an object containing eligibility for apps to serve 3p ads and a configuration map for the slots on each page.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  appAdsInfoV2?: Maybe<AppAdsInfoOutput>;
  /**
   * Get all available badge guide help entries in the system which represent one
   * or more badges for providing awarding instructions and context
   * e.g. Oscars yearly badges are represented by the Oscars badge guide entry.
   * Some entries only represent a single badge, like the IMDb Staff badge.
   * Ordering handled by service ranking.
   *
   * 22 badge guide entries are supported initially.
   *
   * Throws UNSUPPORTED_IMAGE_TYPE if service cannot provide the requested image type
   *
   * ---------------------
   * Graphlet Details:
   * - Name: badges
   * - CTI: IMDb/GraphQL/Badges
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pwr-public
   */
  badgeGuideEntries: BadgeGuideEntryConnection;
  /**
   * At most 30 Names born on the given date, ordered by STARmeter, excluding adult and controversial names.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  bornToday?: Maybe<NameSearchConnection>;
  /**
   * Highest-grossing titles at the domestic box office over the most recent weekend.  At most 10 titles.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: mojo
   * - CTI: IMDb/GraphQL/Mojo
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  boxOfficeWeekendChart?: Maybe<BoxOfficeWeekendChart>;
  /**
   * Query used to fetch specified CTAs.
   * Each CTA is defined as an individual field in CallToAction
   *
   * ---------------------
   * Graphlet Details:
   * - Name: callToAction
   * - CTI: IMDb/GraphQL/Call To Action
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  callToAction?: Maybe<CallToAction>;
  /**
   * True if this customer can claim a name page
   *
   * Throws UNAUTHENTICATED if customer not authenticated
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  canClaimNamePage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * @maxAuthAge=900
   * Returns a URL to redirect to for user login & security page
   * Throws UNAUTHENTICATED if user needs to reauthenticate
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid association handle is provided.
   * Throws GRAPHQL_VALIDATION_FAILED if returnURL is not an absolute URL or not an IMDb domain (ends with 'imdb.com') if passed
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  changeLoginSecurityRedirectURL?: Maybe<ChangeLoginSecurityRedirectUrlOutput>;
  /**
   * Retrieves data associated with specific ranking chart in ordered ranking by default.
   * It supports all filters and sorts, as needed by the Chart pages.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  chartNames?: Maybe<ChartNameSearchConnection>;
  /**
   * Retrieves data associated with specific ranking chart in ordered ranking by default.
   * It supports all filters and sorts, as needed by the Chart pages.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  chartTitles?: Maybe<ChartTitleSearchConnection>;
  /**
   * Get a Cinema by it's `ci` const.
   *
   * Notes:
   *  - Returns null if the cinema doesn't exist.
   *
   * Errors:
   * - Throws `BAD_USER_INPUT` if `id` isn't a valid `ci` const
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  cinema?: Maybe<Cinema>;
  /**
   * The requesting customer's claimed name information
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  claimedName?: Maybe<ClaimedName>;
  /**
   * At most 100 titles releasing wide within 45 days of the given Date, ordered by MOVIEmeter, excluding adult titles.
   * NOTE: This will return data for the US no matter what x-imdb-user-country value is passed in.
   * SEE: https://t.corp.amazon.com/V362117929/communication
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  comingSoon?: Maybe<TitleSearchConnection>;
  /**
   * Output will be in the same order as input, including remapped (returned as
   * mapped id) and non-existent consts (returned with null fields)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  companies: Array<Maybe<Company>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  company?: Maybe<Company>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  companyMetadata?: Maybe<CompanyMetadata>;
  /**
   * Contributor leaderboard queries
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contributor
   * - CTI: IMDb/GraphQL/Contributor
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-contributors-tech
   */
  contributorLeaderboards?: Maybe<ContributorLeaderboards>;
  /**
   * Return contributor ranking for 1 or more leaderboards in reverse chronological order
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contributor
   * - CTI: IMDb/GraphQL/Contributor
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-contributors-tech
   */
  contributorRankings: ContributorLeaderboardRankConnection;
  /**
   * Returns a URL to redirect to for user account creation
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid association handle is provided.
   * Throws GRAPHQL_VALIDATION_FAILED if returnURL is not an absolute URL or not an IMDb domain (ends with 'imdb.com') if passed
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  createAccountRedirectURL?: Maybe<CreateAccountRedirectUrlOutput>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  creditCategory?: Maybe<CreditCategory>;
  /**
   * Retrieves the data for displaying deletion dialogs. The function returns the
   * text to be displayed and, if it's for a deletion REQUEST dialog, a requestId as well.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: privacy
   * - CTI: IMDb/GraphQL/Privacy
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-detected-country-region, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  deletionDialog: DeletionDialogOutput;
  /**
   * Query used to fetch one or more ads for an IMDb app.
   * Returns an array of ad slots and their creative info returned from the AAX call
   *
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  displayAdsForApp?: Maybe<Array<Maybe<AdSlot>>>;
  /**
   * Query used to fetch one or more ads for an IMDb app.
   * Returns an array of ad slots and their creative info returned from the AAX call
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  displayAdsForAppV2?: Maybe<Array<Maybe<AdSlot>>>;
  /**
   * Determine if a prompt should be displayed
   * constId: const id of item to determine if prompt should be displayed for
   * promptType: the type of prompt to be displayed
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  displayablePrompt: DisplayablePrompt;
  /**
   * Retrieves all email preferences for the authenticated user.
   *
   * The customer ID is automatically determined from the x-imdb-customer-id header.
   * Returns the master marketing preference toggle and all individual email preferences
   * categorized by type (marketing and subscription).
   *
   * @throws UNAUTHENTICATED if the customer is not logged in
   *
   * ---------------------
   * Graphlet Details:
   * - Name: notificationPreferences
   * - CTI: IMDb/GraphQL/Notification Preferences
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-core-tech
   */
  emailPreferences: EmailPreferences;
  /**
   * Data for displaying the live winners for an ongoing award event. If there is no current ongoing event, returns null.
   * Server Cache TTL is 15 minutes when null is returned, 30 seconds when data is returned.
   *
   * Optionally specify event override to return data for past events or events to be used for testing.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: winnersWidget
   * - CTI: IMDb/GraphQL/Winners Widget
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  eventLiveResults?: Maybe<EventLiveResults>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  eventMetadata?: Maybe<EventMetadata>;
  /**
   * @experimental Query used to fetch ads for a specific web page.
   * Returns ad slots and their creative info for the requested slots.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  experimental_webAds: Experimental_WebAdsOutput;
  /**
   * @experimental Get configuration information for web ads on a specific page.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  experimental_webAdsConfig?: Maybe<Experimental_WebAdsConfigOutput>;
  /**
   * Retrieves Fan Picks titles. Max batch size is 100 titles.
   *
   * Providing filter input params filters fan picks titles response based on filtering criteria. Currently we support
   * filtering by title type movie or tv.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  fanPicksTitles?: Maybe<FanPicksConnection>;
  /**
   * Query used to determine if a customer has access to a given feature.
   *
   * Each field returns true if the feature access is allowed, false if not.
   * Each field will return its default state for logged out customers, and will state its default in its comments.
   *
   * This field by itself does not grant access to any data, it just signals to the
   * client that they should attempt to access a feature.
   * It is intended for low latency gating checks that cannot otherwise be determined by using an entitled API directly,
   * for example due to an entitled API being expensive to call at scale, or that there is no corresponding entitled API.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: callToAction
   * - CTI: IMDb/GraphQL/Call To Action
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  featureAccess?: Maybe<FeatureAccess>;
  /**
   * Returns a paginated list of the requesting a logged in customer's followed
   * entities. By default, the list is sorted by last updated date.
   *
   * In this context, entities refers to content the user has followed with a
   * unique ID.  This could be publicly available content like an Interest or Name,
   * or in the future a user could follow a conversation or a topic.
   *
   * Supports page size of at most 250.  Requesting a page size larger than the
   * maximum supported will result in the maximum size being returned.
   *
   * Throws UNAUTHENTICATED if not logged in as determined via the x-imdb-customer-id header.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: follows
   * - CTI: IMDb/GraphQL/Follows
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  followedEntities?: Maybe<FollowedEntitiesConnection>;
  /**
   * Returns a URL to redirect to for user account forgot password flow
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid association handle is provided.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  forgotPasswordRedirectURL?: Maybe<ForgotPasswordRedirectUrlOutput>;
  /**
   * Retrieves the details of all exports based on the provided input. The identity
   * of the owner of the exports is determined by the x-amzn-sessionid header for
   * non-logged in users or the x-imdb-customer-id header for logged in users.
   * If sort is not provided, export details are sorted by the export's StartedOn
   * value in descending order, from the most recent to the oldest.
   * Relevant headers: 'x-amzn-sessionid', 'x-imdb-customer-id'
   *
   * If the operation fails to complete, a SERVICE_UNAVAILABLE_ERROR will be thrown.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: privacy
   * - CTI: IMDb/GraphQL/Privacy
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-detected-country-region, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  getExports: ExportDetailConnection;
  /**
   * Provide a way for a client to re-fetch the last UI workflow model for a given
   * workflow execution, to support recovery from an error, or debugging tools.
   * Throws UNAUTHENTICATED if the requesting customer is not logged in.
   * Throws FORBIDDEN if the requesting customer is not entitled to view the workflow execution requested.
   * Throws RESOURCE_NOT_FOUND if the workflow execution ID requested does not exist.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contributionSDUI
   * - CTI: IMDb/GraphQL/ContributionSDUI
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-sdui
   */
  getLatestUIWorkflow?: Maybe<GetLatestUiWorkflowOutput>;
  /**
   * Retrieve guild membership detail for the currently logged in customer for the
   * input companyId. Returns null if the guild membership detail record does not exist
   *
   * Throws UNAUTHENTICATED if customer is not authenticated
   * Throws FORBIDDEN if the customer does not have access to retrieve the membership detail
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  guildMembershipDetail?: Maybe<GuildMembershipDetail>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  image?: Maybe<Image>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  imageGalleries: Array<Maybe<ImageGallery>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  imageGallery?: Maybe<ImageGallery>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  images: Array<Maybe<Image>>;
  /**
   * Metadata about a single interest.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  interest?: Maybe<Interest>;
  /**
   * A paginated list of all available interest categories, sorted alphabetically. Supports page size of at most 250.
   * Requesting a page size larger than the maximum supported will result in the maximum size being returned.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  interestCategories?: Maybe<InterestCategoryConnection>;
  /**
   * Metadata about an array of interests.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  interests: Array<Maybe<Interest>>;
  /**
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid provider is provided.
   * If a user with an existing linkage reaches this page, they will have to try login again.
   * Returns an error page when user attempts to sign in with Google or Apple and does not have an existing linkage.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  invalidAuthProviderInterstitial?: Maybe<InvalidAuthProviderInterstitialOutput>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  keyword?: Maybe<Keyword>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  keywordMetadata?: Maybe<KeywordMetadata>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  keywords: Array<Maybe<Keyword>>;
  /**
   * Paginated list of latest attachments sorted by attachment time (most recent first).
   *
   * An attachment is when a name is attached to a title.
   *
   * Supports page size of at most 250. Requesting a page size larger than the
   * maximum supported will result in the maximum size being returned.
   *
   * Throws UNAUTHENTICATED if not logged in
   * Throws FORBIDDEN if customer w/o any IMDbPro subscription
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  latestNameToTitleAttachments?: Maybe<NameToTitleAttachmentConnection>;
  /**
   * Return single list.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  list?: Maybe<List>;
  /**
   * Returns attribute metadata about the different fields of a list, allowing for users to determine the proper
   * structure/standards for these fields (i.e. what is the maximum number of characters that a list name could be)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  listFieldAttributeMetadata: ListFieldAttributeMetadata;
  /**
   * Returns lists for the requested user filtered on provided input.
   * The requested user is in the optional input listOwnerUserId if provided.
   * Otherwise the requested user is the current authenticated user.
   * listOwnerUserId can be omitted only when request is made with authenticated user.
   * If listOwnerUserId is provided, whether user is currently authenticated or not, the result includes only public lists belongs to the listOwnerUserId.
   * Otherwise the result includes lists with all visibilities belongs to the current authenticated user.
   * If there's no matching list, it returns empty result.
   * Default sort order is most recently modified first.
   *
   * This query is cacheable except when authenticated user loading their own lists (query made with authenticated user and without providing listOwnerUserId).
   *
   * Throws UNAUTHENTICATED if user is not logged in and listOwnerUserId is not provided.
   * Throws BAD_USER_INPUT if the listOwnerUserId is not valid.
   * Throws RESOURCE_NOT_FOUND if the listOwnerUserId doesn't exist.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  lists: ListCollectionConnection;
  /**
   * Returns a URL to redirect to for user account log out
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid association handle is provided.
   * Throws GRAPHQL_VALIDATION_FAILED if returnURL is not an absolute URL or not an IMDb domain (ends with 'imdb.com') if passed
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  logoutRedirectURL?: Maybe<LogoutRedirectUrlOutput>;
  /**
   * Main search, searches one or multiple data types to find a mixed result set of answers.
   *
   * Note: Forward Pagination currently only works if you ask for one data type (eg, just NAMEs).
   * Multi-index pagination might be added in the future.
   *
   * See: https://quip-amazon.com/Nsb2Ad66R8xF/Main-Search-Design
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  mainSearch?: Maybe<MainSearchConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  name?: Maybe<Name>;
  /**
   * Retrieves data associated with a specifc ranking chart in ordered ranking
   * first: number of rankings to return for that chart. max is 250.
   * input: type for querying certain ranking chart. Only India STARmeter chart is currently supported.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  nameChartRankings?: Maybe<NameChartRankingsConnection>;
  /**
   * Details of a request to be a manager of a name page, identified by id and token
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  nameManagingPermissionRequest?: Maybe<NameManagingPermissionRequestResponse>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nameMetadata?: Maybe<NameMetadata>;
  /**
   * Names recommended to the customer based on titles/names/other signals that the customer has shown interest in.
   *
   * Only for logged in customers (x-imdb-customer-id header; the gateway determines this from the request).
   *
   * Max returned count is 20. Pagination is currently not supported.
   *
   * For use in features recommending Names for the customer to favorite.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  nameRecommendations?: Maybe<NameRecommendations>;
  /**
   * Output will be in the same order as input, including remapped (returned as
   * mapped id) and non-existent consts (returned with null fields)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  names: Array<Maybe<Name>>;
  /**
   * Get cinemas in ascending distance from the request location.
   *
   * Notes:
   * - If `filter.favorites` is specified as `ONLY_FAVORITES`, `filter.location.radiusInMeters` can be left as null to get all of a user's favorite cinemas.
   * - If both lat/long and postal code are provided to `filter.location`, the location will default to using lat/long.
   * - It's strongly recommended to explicitly provide startTime to avoid timezone mismatches between server and client, but if `filter.dateRange` is not provided, the startTime will default to server's 'now' and the endTime will default to `3000-01-01T00:00:00Z`.
   * - If `filter.dateRange.endTime` is not provided, the endTime will default to `3000-01-01T00:00:00Z`.
   * - Backwards pagination is not currently supported.
   *
   * Errors:
   * - Throws `BAD_USER_INPUT` if `filter.location.radiusInMeters` is null AND filter.favorites` is not set to `ONLY_FAVORITES.
   * - Throws `BAD_USER_INPUT` with symbol `filter.location.postalCode` if the location is unknown.
   * - Throws `BAD_USER_INPUT` if lat/long is too precise. See `LatLong` input.
   *
   * Limits:
   * - `first` is limited to a maximum of 100. If the `first` argument exceeds the maximum, the results will be capped to the maximum.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  nearbyCinemas?: Maybe<CinemaConnection>;
  /**
   * Paginated list of latest news articles.
   * Supports both Consumer and Pro news categories.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  news?: Maybe<NewsConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  newsArticle?: Maybe<News>;
  /**
   * List of news categories along with additional metadata.
   *
   * The returned categoryIds can be used as inputs to the news() query.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  newsCategories: Array<Maybe<NewsCategoryMetadata>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  newsSource?: Maybe<NewsSource>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nomination?: Maybe<Nomination>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nominationEvent?: Maybe<NominationEvent>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nominationEventEdition?: Maybe<NominationEventEdition>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nominationEventEditions?: Maybe<Array<Maybe<NominationEventEdition>>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nominationEvents?: Maybe<Array<Maybe<NominationEvent>>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nominations?: Maybe<Array<Maybe<Nomination>>>;
  /**
   * Returns a paginated list of the requesting customer's notifications. By default, the list is sorted by last updated time.
   *
   * Supports page size of at most 250.  Requesting a page size larger than the
   * maximum supported will result in the maximum size being returned.
   *
   * Throws UNAUTHENTICATED if neither x-imdb-customer-id nor x-amzn-sessionid is present in the header.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: notificationcenter
   * - CTI: IMDb/GraphQL/NotificationCenter
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language, x-imdb-client-name, x-imdb-client-ip, user-agent
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  notifications: UserNotificationConnection;
  /**
   * Query used to fetch a video ad that plays as outstream on an IMDb app
   * Outstream video definition: Video ad not directly tied to IMDb video content (no related viconst)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  outstreamVideoAdApp?: Maybe<Scalars['URL']['output']>;
  /**
   * @maxAuthAge=900
   * Returns current settings for user's personal details.
   * Throws UNAUTHENTICATED if customer needs to re-authenticate.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  personalDetails: PersonalDetailsOutput;
  /**
   * Returns the detail of a poll.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  poll?: Maybe<Poll>;
  /**
   * Returns the list of poll admin activities (poll created/synced), from latest to earliest.
   * Customer needs to have POLL_ADMIN entitlement to call this.
   *
   * Throws UNAUTHENTICATED if not logged in.
   * @entitlement(POLL_ADMIN)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  pollAdminActivities?: Maybe<PollAdminActivityConnection>;
  /**
   * Returns a paginated list of the polls on IMDb. By default, the list is sorted by create time in descending order.
   * Supports page size of at most 250. Requesting a page size larger than the maximum supported will result in the maximum size being returned.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  polls?: Maybe<PollsConnection>;
  /**
   * Paginated list of most popular interests.
   * Supports page size of at most 250. Requesting a page size larger than the
   * maximum supported will result in the maximum size being returned.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  popularInterests?: Maybe<InterestSearchConnection>;
  /**
   * The most popular released movie or TV series titles, as determined by the movie meter ranking.
   * If the specified limit is over the query's page limit (100), the limit will be capped at the query's limit
   * To be replaced by topMeterTitles, which follows the Relay spec.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  popularTitles?: Maybe<PaginatedTitles>;
  /**
   * Retrieve predefined user lists. Predefined User Lists have a ListClass of CHECK_INS, FAVORITE_ACTORS,
   * FAVORITE_THEATRES, NOT_INTERESTED, RESEARCH_NOTES, SEEN, or WATCH_LIST. They are automatically created for a user,
   * and cannot be deleted or renamed.
   * Predefined lists can be accessed by userId and list class pair as there can only be one per user for a type.
   * userId can be omitted only when the request is made while the authenticated user is present in the context (e.g., the user is logged in).
   * If the predefined list does not exist for the user, it returns null instead of throwing an exception.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  predefinedList?: Maybe<List>;
  /**
   * Gets the privacy directives that must be enforced for the user
   * Relevant headers: 'x-amzn-sessionid', 'x-imdb-customer-id', 'x-imdb-client-ip', 'x-imdb-client-name'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: privacy
   * - CTI: IMDb/GraphQL/Privacy
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-detected-country-region, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  privacyDirectives: PrivacyDirectivesOutput;
  /**
   * If applicable, fetch the privacy prompt information that must be displayed to the user
   * Relevant headers: 'x-amzn-sessionid', 'x-imdb-customer-id', 'x-imdb-client-ip', 'x-imdb-client-name'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: privacy
   * - CTI: IMDb/GraphQL/Privacy
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-detected-country-region, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  privacyPrompt: PrivacyPromptOutput;
  /**
   * Query used to fetch profession detail
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  profession?: Maybe<NameProfession>;
  /**
   * Query used to fetch profession Category detail.
   * Output will be in the same order as input with non-existent consts being removed from response
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  professionCategories: Array<Maybe<ProfessionCategory>>;
  /**
   * Query used to fetch profession Category detail
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  professionCategory?: Maybe<ProfessionCategory>;
  /**
   * Names people in a particular profession tend to track
   *
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  professionNameTrackRecommendations?: Maybe<NameTrackRecommendationsConnection>;
  /**
   * Titles people in a particular profession tend to track
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  professionTitleTrackRecommendations?: Maybe<TitleTrackRecommendationsConnection>;
  /**
   * Query used to fetch profession detail.
   * Output will be in the same order as input with non-existent consts being removed from response
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  professions: Array<Maybe<NameProfession>>;
  /**
   * This query is used to fetch the Promoted Video Ad if one exists for the client
   * If there is an adOverrideCreativeId or x-imdb-adsystem-overrides, it will instead fetch that Promoted Video Ad
   * Relevant headers: 'user-agent', 'x-amzn-sessionid', 'x-imdb-adsystem-overrides', 'x-imdb-client-ip', 'x-imdb-customer-id'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  promotedVideoAd?: Maybe<PromotedVideoAd>;
  /**
   * This query is used to fetch the Promoted Video Ad if one exists for the client
   * If there is an adOverrideCreativeId or x-imdb-adsystem-overrides, it will instead fetch that Promoted Video Ad
   * Relevant headers: 'user-agent', 'x-amzn-sessionid', 'x-imdb-adsystem-overrides', 'x-imdb-client-ip', 'x-imdb-customer-id'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  promotedVideoAdV2?: Maybe<PromotedVideoAd>;
  /**
   * Field exposing push notification information for authenticated users.
   * Does not expose any param.
   * Returns null if user not signed in.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: pushNotification
   * - CTI: IMDb/GraphQL/Push Notification
   * - Affected by headers: x-imdb-customer-id
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-core-tech
   */
  pushNotificationUserSettings?: Maybe<PushNotificationUserSettings>;
  /**
   * Retrieves the latest videos that has been added to the video catalog.
   *
   * If the limit exceeds the maximum, the results will be capped to 100.
   * Optionally, a list of VideoContentType can be provided to be used as a filter. If none are provided,
   * we will return all results. When a pagination token is provided, the query filter will be ignored.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  recentVideos?: Maybe<PaginatedVideos>;
  /**
   * Retrieves RecentlyViewed items.
   * Can query views for specific site (default is Consumer site).
   *
   * For Consumer page views:
   * - Based on SessionId for all users
   * - Max batch size is 100 items
   * - Returns name and title consts
   *
   * For Pro page views:
   * - Based on CustomerId for all users
   * - Max batch size is 20 items
   * - Returns name, title, and company consts
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  recentlyViewedItems?: Maybe<RecentlyViewedConnection>;
  /**
   * Returns news articles related to names, titles, and/or companies
   * mentioned in the article.
   *
   * A maximum of 3 total related name, title, and/or company consts will be returned.
   * For each related const, a maximum of 3 news items will be returned.
   *
   * For example, for an article that mentions Keanu Reeves and The Matrix,
   * the response could include a list of 3 articles related to Keanu Reeves
   * and a list of 3 articles related to The Matrix.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  relatedNews?: Maybe<Array<Maybe<RelatedNews>>>;
  /**
   * Accepts any markdown string to be rendered
   *
   * ---------------------
   * Graphlet Details:
   * - Name: markdown
   * - CTI: IMDb/GraphQL/Markdown
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  renderedMarkdown?: Maybe<Markdown>;
  /**
   * @maxAuthAge=900
   * Retrieves the requested account data after data processing triggered by `confirmAccountDataRequest` mutation is complete.
   * Relevant headers: 'x-imdb-customer-id'
   * If re-authentication is successful, the function returns the downloadable data
   * information through fileMetadata, success will be true,
   * and a success text will be in message and a success title text in title.
   * If it was unsuccessful, success will be false and an error text will be in message
   * and an error title text will be in title. fileMetadata will have its values set to empty.
   * Throws UNAUTHENTICATED if the user is not logged in or fails 15 minute maxAuthAge check.
   * Throws FORBIDDEN if logged in user doesn't match the customerID from the initial request.
   * Throws INVALID_INPUT_EXCEPTION if dataRequestId provided is invalid.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: privacy
   * - CTI: IMDb/GraphQL/Privacy
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-detected-country-region, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  retrieveAccountData: RetrieveAccountDataOutput;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  review?: Maybe<Review>;
  /**
   * Get paginated saved search filters, of a given input SavedSearchFilterType, for a customerId.
   * Sorted by updatedTimestamp, descending.
   * Customer ID is taken from the request header, not as part of this input.
   *
   * Supports page size of at most 250. Requesting a page size larger than the
   * maximum supported will result in the maximum size being returned.
   *
   * Throws UNAUTHENTICATED if user is not logged in.
   * Throws BAD_USER_INPUT if the customerId is not valid.
   * Throws RESOURCE_NOT_FOUND if the customerId doesn't exist.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  savedSearchFilters?: Maybe<SavedSearchFiltersConnection>;
  /**
   * Data that can be useful for crafting search queries.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  searchMetadata?: Maybe<SearchMetadata>;
  /**
   * Metadata for some self-verified name data attributes
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  selfVerifiedNameMetadata?: Maybe<SelfVerifiedNameMetadata>;
  /**
   * Retrieves Showtimes titles. Max batch size is 100 titles. We currently do not support pagination in existing
   * showtimes API but hope to in the future.
   *
   * Throws if `location.radiusInMeters` is null.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  showtimesTitles?: Maybe<ShowtimesTitleConnection>;
  /**
   * Retrieves titles currently showing in the specified cinemas.
   *
   * Notes:
   * - It's strongly recommended to explicitly provide startTime to avoid timezone mismatches between server and client, but if `filter.dateRange` is not provided, the startTime will default to server's 'now' and the endTime will default to `3000-01-01T00:00:00Z`.
   * - If `filter.dateRange.endTime` is not provided, the endTime will default to `3000-01-01T00:00:00Z`.
   * - We currently do not support pagination in existing showtimes API but hope to in the future.
   *
   * Sorting:
   * - There is no guaranteed sort order for results returned.
   *
   * Throws:
   * - Throws `GRAPHQL_VALIDATION_FAILED` if `cinemasMetadata.anyCinemaIds` is null.
   * - Throws `BAD_USER_INPUT` if more than 400 unique cinemas are provided in `cinemasMetadata.anyCinemaIds`.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  showtimesTitlesByCinemas?: Maybe<ShowtimesTitleConnection>;
  /**
   * Returns a single sign in option redirect URL based on association handle from login context
   * The associationHandle in the input will affect the single sign in option returned
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid association handle is provided.
   * Throws GRAPHQL_VALIDATION_FAILED if returnURL is not an absolute URL or not an IMDb domain (ends with 'imdb.com') if passed
   * Throws GRAPHQL_VALIDATION_FAILED if no additionalWebAuthContext is given and associationHandle in input is an association handle
   *     used in AAP (Amazon account pool) creation/conversion i.e. 'imdb_amazon', 'imdb_pro_amazon', etc.
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid signInPrefilledEmail is provided.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  signInOptionRedirectURL?: Maybe<SignInOptionRedirectUrlOutput>;
  /**
   * Returns sign in options redirect URLs based on association handle from login context
   * The associationHandle in the input will only affect the 1P IMDb sign in option, all of the other 3P logins will be configured with their own association handles
   * Throws GRAPHQL_VALIDATION_FAILED if an invalid association handle is provided.
   * Throws GRAPHQL_VALIDATION_FAILED if returnURL is not an absolute URL or not an IMDb domain (ends with 'imdb.com') if passed
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  signInOptionsRedirectURLs?: Maybe<SignInOptionsRedirectUrLsOutput>;
  /**
   * Names people that tend to track similar pages track
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  similarNameTrackRecommendations?: Maybe<NameTrackRecommendationsConnection>;
  /**
   * Titles people that tend to track similar pages track
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  similarTitleTrackRecommendations?: Maybe<TitleTrackRecommendationsConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: zukoTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  staticSchemaTest?: Maybe<Test>;
  /**
   * Gets the StreamingTitles for the providers applicable for this user/territory
   * Since this is a personalized selection it will always be a finite size (typically
   * less than 15 providers worth)
   * Caller may optionally filter to only a select set of providers if the IDs have
   * already been obtained
   * Throws InvalidParameterError if filter is for TitleTypeCategoryValue other than tv or movie
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  streamingTitles: Array<Maybe<StreamingTitles>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: zukoStubs
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: None
   * - Cache TTL: 300 seconds
   * - Slack Channel: #imdb-api-gateway-external
   */
  stubQuery?: Maybe<QueryStubs>;
  /**
   * Top search suggestions
   *
   * This suggestionSearch query is used by IMDb Consumer and "Pro" products for filling in suggestions for the search bar.
   * More info at https://w.amazon.com/bin/view/IMDb/Search/Suggestion/
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  suggestionSearch?: Maybe<SuggestionSearchConnection>;
  /**
   * Retrieves a list of placements from Content Symphony.
   *
   * This graphlet utilizes dynamic caching (https://w.amazon.com/bin/view/IMDb/Zuko/DynamicGraphletResponseCaching)
   * The cached flag is false by default, customer and session IDs WILL be used to fetch placements,
   * and the response WILL NOT be cached. If the cached flag is true,
   * then customer and session IDs WILL NOT be used, and the response WILL be cached.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: contentSymphony
   * - CTI: IMDb/GraphQL/ContentSymphony
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-detected-country, x-imdb-client-name, x-imdb-client-ip, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-foundation-web-platform-office-hours
   */
  symphonyPlacements?: Maybe<Array<Maybe<SymphonyPlacement>>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: zukoTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  test?: Maybe<Test>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testAuth?: Maybe<TestAuth>;
  /**
   * @maxAuthAge=120
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testAuthTimer?: Maybe<TestAuthTimer>;
  /**
   * True if granted entitlement
   * @entitlement(PREMIUM_OR_NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testCombinedEntitlement?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Each entry responds to input array, true if granted entitlement
   * @entitlement(NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testContextEntitlement: Array<Maybe<Scalars['Boolean']['output']>>;
  /**
   * True if granted entitlement
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testEntitlement?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Test field with useEntitlement defaulting to false (query author can opt in)
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testEntitlementWithOptIn?: Maybe<Scalars['String']['output']>;
  /**
   * Test field with useEntitlement defaulting to true (query author can opt out)
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testEntitlementWithOptOut?: Maybe<Scalars['String']['output']>;
  /**
   * All received entitlements.
   * @entitlement(NAME_OWNER,PRO_ANY_TIER,PRO_PREMIUM,PREMIUM_OR_NAME_OWNER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testEntitlements?: Maybe<Array<Maybe<TestEntitlement>>>;
  /**
   * True if granted entitlement
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testProAnyTierEntitlement?: Maybe<Scalars['Boolean']['output']>;
  /**
   * True if granted entitlement
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: zukoAuthTest
   * - CTI: IMDb/GraphQL/Gateway
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-ip, x-imdb-detected-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-api-gateway-external
   */
  testProPremiumEntitlement?: Maybe<Scalars['Boolean']['output']>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  title?: Maybe<Title>;
  /**
   * Retrieves data associated with a specifc ranking chart in ordered ranking
   * first: number of rankings to return for that chart
   * after: pagination token to begin returning ranking set (Optional)
   * input: type for querying certain ranking chart
   *
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  titleChartRankings?: Maybe<TitleChartRankingsConnection>;
  /**
   * Titles recommended based on title genre a customer has shown interest in. Only for logged in customers.
   * Max batch size is 30 items.
   * Will return an UNAUTHENTICATED error code if no customer associated with the request.
   *
   * For use in Genre recommendation features.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  titleGenreRecommendations?: Maybe<TitleGenreRecommendation>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  titleMetadata?: Maybe<TitleMetadata>;
  /**
   * Titles recommended based on activity, either by user id when available, or session id otherwise.
   *
   * For use in Top Picks features.
   *
   * Providing placement context in request generates different title recommendations based on input. If no placement
   * context is provided, or pageType passed in is not supported, the default behavior is optimized for home page
   * placement, which is today's behavior. Currently supported page types are: home, title.
   *
   * Providing filter input params filters title recommendations response based on filtering criteria. Currently we support
   * filtering by title type movie or tv.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  titleRecommendations?: Maybe<TitleRecommendationConnection>;
  /**
   * Returns personalized watchlist title recommendations for a logged in customer (x-imdb-customer-id header; the gateway determines this from the request).
   *
   * For a customer with zero watchlist titles (cold start behavior), there will be no recommended titles returned. Cold start recommendations may be added in the future.
   *
   * Max returned count is 10. Pagination is currently not supported, but will be supported later.
   *
   * Recommendations returned as sorted by title aggregate rating in descending order.
   *
   * Will return an UNAUTHENTICATED error code if no customer associated with the request.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  titleWatchlistRecommendations?: Maybe<TitleWatchlistRecommendationConnection>;
  /**
   * Output will be in the same order as input, including remapped (returned as
   * mapped id) and non-existent consts (returned with null fields)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  titles: Array<Maybe<Title>>;
  /**
   * Top grossing releases at the Box Office for the specified filter.
   * Currently there will be at most 10 releases.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: mojo
   * - CTI: IMDb/GraphQL/Mojo
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  topGrossingReleases?: Maybe<TopGrossingReleasesConnection>;
  /**
   * Returns a collection of top Lists
   * first can have a maximum value of <LIMIT>
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  topListsForItem: ListCollectionConnection;
  /**
   * The most popular names, sorted by StarMeter.
   * Max page size supported is 250.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  topMeterNames?: Maybe<NameSearchConnection>;
  /**
   * The most popular titles, sorted by MovieMeter.
   * Max page size supported is 250.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  topMeterTitles?: Maybe<TitleSearchConnection>;
  /**
   * Prefer titleRecommendations, which includes recommendation explanations
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  topPicksTitles?: Maybe<TopPicksConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  topTrendingNames?: Maybe<TrendingNameConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  topTrendingSetsPredefined?: Maybe<TrendingTitleConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  topTrendingTitles?: Maybe<TrendingTitleConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  topTrendingVideos?: Maybe<TrendingVideoConnection>;
  /**
   * The requesting user's tracked names
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  trackedNames?: Maybe<TrackedNamesConnection>;
  /**
   * The requesting user's tracked titles
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  trackedTitles?: Maybe<TrackedTitlesConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  trendingNamesCollectionOptions?: Maybe<TrendingNameCollectionOptions>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  trendingTitles?: Maybe<PaginatedTitles>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: trending
   * - CTI: IMDb/GraphQL/Trending
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  trendingTitlesCollectionOptions?: Maybe<TrendingTitleCollectionOptions>;
  /**
   * Query to return the unread notification count for the customer. 0 means no unread notification.
   *
   * The unread status is determined by the last time a customer visited their notification center. Clients should call
   * updateNotificationCenterAccess to update it at proper times.
   *
   * Throws UNAUTHENTICATED if neither x-imdb-customer-id nor x-amzn-sessionid is present in the header.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: notificationcenter
   * - CTI: IMDb/GraphQL/NotificationCenter
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language, x-imdb-client-name, x-imdb-client-ip, user-agent
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  unreadNotificationCount: Scalars['Int']['output'];
  /**
   * Unreleased titles people in a particular profession tend to track
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  unreleasedTitleTrackRecommendations?: Maybe<TitleTrackRecommendationsConnection>;
  /**
   * Field exposing information for requestingUserId. Does not expose any param
   * Includes private information for signed in user
   * Returns null if user not signed in
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  user?: Maybe<User>;
  /**
   * Get all earned badges, for either the authenticated user or for the optionally given userid
   * Ordering handled by service ranking.
   *
   * 100 badges are supported initially.
   *
   * Throws UNAUTHENTICATED if userId is not provided and the x-imdb-customer-id header is empty.
   * Throws UNSUPPORTED_IMAGE_TYPE if service cannot provide the requested image type
   *
   * ---------------------
   * Graphlet Details:
   * - Name: badges
   * - CTI: IMDb/GraphQL/Badges
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pwr-public
   */
  userBadges: BadgeConnection;
  /**
   * Fetch whether the current user is opted in or out of a consent.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: privacy
   * - CTI: IMDb/GraphQL/Privacy
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-detected-country-region, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  userConsent?: Maybe<UserConsentOutput>;
  /**
   * @maxAuthAge=900
   * Returns status and linking information for all auth providers for the current user.
   * Throws UNAUTHENTICATED if customer needs to re-authenticate.
   * Throws GRAPHQL_VALIDATION_FAILED if returnURL is not an absolute URL or not an IMDb domain (ends with 'imdb.com') if passed
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  userLinkedAuthProviderStatuses?: Maybe<UserLinkedAuthProviderStatusesOutput>;
  /**
   * Returns a filtered and sorted list of lists for a user
   *
   * There are two behaviors
   *   1. authenticated user - retrun private and public lists
   *   2. listOwnerUserId - return public lists owned by the user
   *   Note: listOwnerUserId takes precendence over the authenticated user
   *
   * This query currently uses non-cached endpoint as IMDbSearchGraphlet does not support caching for List now.
   * This query is designed for search scenarios, leveraging the search index to deliver eventual consistency while
   * offering an efficient and cost effective approach to filtering and sorting user lists.
   *
   * For strict consistency requirements, the following APIs offer direct access to lists from the primary data store:
   * 1. lists API: Retrieves the lists for a user.
   * 2. predefinedList API: Retrieves a specific predefined list for a user.
   * 3. list API: Retrieves a single list for a list id.
   *
   * Throws UNAUTHENTICATED if user is not logged in and listOwnerUserId is not provided.
   * Throws BAD_USER_INPUT if the listOwnerUserId is not valid.
   * Throws RESOURCE_NOT_FOUND if the listOwnerUserId doesn't exist.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: search
   * - CTI: IMDb/GraphQL/Search
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-country, x-imdb-user-language, x-imdb-normalized-languages
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-disco
   */
  userListSearch: ListCollectionConnection;
  /**
   * Returns a user's profile.
   *
   * When the optional userId is omitted, authentication is required and the current user's profile is returned.
   * When the userId is provided, the public version of the user profile is returned.
   * This query is not cacheable when the userId is omitted for authenticated users viewing their own profile.
   *
   * Possible Errors:
   * - Throws UNAUTHENTICATED if the user is not logged-in and no userId is provided.
   * - Throws BAD_USER_INPUT if the userId is not valid.
   * - Throws RESOURCE_NOT_FOUND if the userId doesn't exist.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: userProfile
   * - CTI: IMDb/GraphQL/UserProfile
   * - Affected by headers: x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  userProfile?: Maybe<UserProfile>;
  /**
   * Find a user's title ratings based on a variety of constraints
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  userRatings?: Maybe<RatingsConnection>;
  /**
   * Find a user's title reviews based on a variety of constraints
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  userReviews: ReviewsConnection;
  /**
   * Returns the list of polls a customer has voted on, from latest to earliest.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  userVotedPolls?: Maybe<PollsConnection>;
  /**
   * Returns all the titles this customer has watched. first would have a maximum
   * value of 1000. CustomerId will be taken from x-imdb-customer-id header.
   * - Throws AuthenticationError for non-authenticated requests.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watched
   * - CTI: IMDb/GraphQL/Watched
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  userWatchedTitles: WatchedTitlesConnection;
  /**
   * Information about a vanity URL
   *
   * ---------------------
   * Graphlet Details:
   * - Name: managedName
   * - CTI: IMDb/GraphQL/Managed Name
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  vanityUrl?: Maybe<VanityUrl>;
  /**
   * Retrieves a Video by its Id
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  video?: Maybe<Video>;
  /**
   * This query is used to fetch an ad feedback URL for a given video ad
   *
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  videoAdFeedbackUrl: Scalars['URL']['output'];
  /**
   * This query is used to fetch an ad feedback URL for a given video ad
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  videoAdFeedbackUrlV2: Scalars['URL']['output'];
  /**
   * Returns video items, with ad display indicators intermixed
   * This query considers customer and session states
   *
   * first: number of items requested
   * after: cursor for pagination. the value is from previous page's endCursor
   * context: additional context used to generate the response
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  videoRecommendations?: Maybe<VideoRecommendationsConnection>;
  /**
   * Retrieves Videos for all given video Ids. Maximum batch size is 100 videos
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  videos: Array<Maybe<Video>>;
  /**
   * Paginated list of all available watch providers in the requester's location, sorted alphabetically.
   * Maximum page size supported is 250.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  watchProviders?: Maybe<WatchProviderConnection>;
  /**
   * Query used to fetch display ads for a specific web page.
   * Returns ad slots and their creative info for the requested slots.
   * Throws SERVICE_UNAVAILABLE_ERROR if unable to render page header markup template.
   * Throws BAD_USER_INPUT if bid request to PAS fails input validation.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  webAds: WebAdsOutput;
  /**
   * Get configuration information for web ads on a specific page.
   * Throws SERVICE_UNAVAILABLE_ERROR if unable to render ad creative markup template.
   * Fails open on other dependency failures, returning minimal ad response.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  webAdsConfig: WebAdsConfigOutput;
};


/** Query */
export type QueryAccountDataDialogArgs = {
  input: AccountDataDialogInput;
};


/** Query */
export type QueryAdvancedNameSearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  constraints?: InputMaybe<AdvancedNameSearchConstraints>;
  first: Scalars['Int']['input'];
  jumpToPosition?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<AdvancedNameSearchSort>;
};


/** Query */
export type QueryAdvancedTitleSearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  constraints?: InputMaybe<AdvancedTitleSearchConstraints>;
  first: Scalars['Int']['input'];
  jumpToPosition?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<AdvancedTitleSearchSort>;
};


/** Query */
export type QueryBadgeGuideEntriesArgs = {
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryBornTodayArgs = {
  first: Scalars['Int']['input'];
  today: Scalars['MonthDay']['input'];
};


/** Query */
export type QueryBoxOfficeWeekendChartArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Query */
export type QueryCallToActionArgs = {
  context?: InputMaybe<CallToActionContextInput>;
};


/** Query */
export type QueryChangeLoginSecurityRedirectUrlArgs = {
  input: ChangeLoginSecurityRedirectUrlInput;
};


/** Query */
export type QueryChartNamesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  chart: ChartNameOptions;
  filter?: InputMaybe<AdvancedNameSearchConstraints>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<AdvancedNameSearchSort>;
};


/** Query */
export type QueryChartTitlesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  chart: ChartTitleOptions;
  filter?: InputMaybe<AdvancedTitleSearchConstraints>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<AdvancedTitleSearchSort>;
};


/** Query */
export type QueryCinemaArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryComingSoonArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  comingSoonType: ComingSoonType;
  disablePopularityFilter?: InputMaybe<Scalars['Boolean']['input']>;
  first: Scalars['Int']['input'];
  regionOverride?: InputMaybe<Scalars['String']['input']>;
  releasingOnOrAfter: Scalars['Date']['input'];
  releasingOnOrBefore?: InputMaybe<Scalars['Date']['input']>;
  sort?: InputMaybe<Array<InputMaybe<ComingSoonSort>>>;
};


/** Query */
export type QueryCompaniesArgs = {
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};


/** Query */
export type QueryCompanyArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryContributorRankingsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter: ContributorRankingsFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** Query */
export type QueryCreateAccountRedirectUrlArgs = {
  input: CreateAccountRedirectUrlInput;
};


/** Query */
export type QueryCreditCategoryArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryDeletionDialogArgs = {
  input: DeletionDialogInput;
};


/** Query */
export type QueryDisplayAdsForAppArgs = {
  input: DisplayAdsForAppInput;
};


/** Query */
export type QueryDisplayAdsForAppV2Args = {
  input: DisplayAdsForAppInput;
};


/** Query */
export type QueryDisplayablePromptArgs = {
  constId: Scalars['ID']['input'];
  promptType: PromptType;
};


/** Query */
export type QueryEmailPreferencesArgs = {
  domain?: InputMaybe<BusinessDomain>;
};


/** Query */
export type QueryEventLiveResultsArgs = {
  override?: InputMaybe<EventLiveResultsOverrideInput>;
};


/** Query */
export type QueryExperimental_WebAdsArgs = {
  input: Experimental_WebAdsInput;
};


/** Query */
export type QueryExperimental_WebAdsConfigArgs = {
  input: Experimental_WebAdsInput;
};


/** Query */
export type QueryFanPicksTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<FanPicksFilter>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryFollowedEntitiesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<FollowFilter>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<FollowSort>;
};


/** Query */
export type QueryForgotPasswordRedirectUrlArgs = {
  input: ForgotPasswordRedirectUrlInput;
};


/** Query */
export type QueryGetExportsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ExportFilterByInput>;
  first: Scalars['Int']['input'];
  input: GetExportsInput;
  sort?: InputMaybe<ExportSortByInput>;
};


/** Query */
export type QueryGetLatestUiWorkflowArgs = {
  input: GetLatestUiWorkflowInput;
};


/** Query */
export type QueryGuildMembershipDetailArgs = {
  companyId: Scalars['ID']['input'];
};


/** Query */
export type QueryImageArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryImageGalleriesArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryImageGalleryArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryImagesArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryInterestArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryInterestCategoriesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<InterestCategoriesFilter>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryInterestsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryInvalidAuthProviderInterstitialArgs = {
  input: InvalidAuthProviderInterstitialInput;
};


/** Query */
export type QueryKeywordArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryKeywordsArgs = {
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};


/** Query */
export type QueryLatestNameToTitleAttachmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  attachmentConstraint?: InputMaybe<AttachmentSearchConstraint>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryListArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryListsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter: ListFilter;
  first: Scalars['Int']['input'];
  listOwnerUserId?: InputMaybe<Scalars['ID']['input']>;
  sort?: InputMaybe<ListSort>;
};


/** Query */
export type QueryLogoutRedirectUrlArgs = {
  input: LogoutRedirectUrlInput;
};


/** Query */
export type QueryMainSearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
  options: MainSearchOptions;
};


/** Query */
export type QueryNameArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryNameChartRankingsArgs = {
  first: Scalars['Int']['input'];
  input: NameChartRankingsInput;
};


/** Query */
export type QueryNameManagingPermissionRequestArgs = {
  id: Scalars['ID']['input'];
  token: Scalars['String']['input'];
};


/** Query */
export type QueryNamesArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryNearbyCinemasArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter: NearbyCinemasFilter;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryNewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  category: NewsCategory;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryNewsArticleArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryNewsCategoriesArgs = {
  constraints?: InputMaybe<NewsCategoryConstraints>;
};


/** Query */
export type QueryNewsSourceArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryNominationArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryNominationEventArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryNominationEventEditionArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryNominationEventEditionsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryNominationEventsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryNominationsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryNotificationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<UserNotificationsSortOrder>;
};


/** Query */
export type QueryOutstreamVideoAdAppArgs = {
  input: OutstreamAdParametersApp;
};


/** Query */
export type QueryPollArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryPollAdminActivitiesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Query */
export type QueryPollsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<PollFilter>;
  first: Scalars['Int']['input'];
  jumpToPosition?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<PollSort>;
};


/** Query */
export type QueryPopularInterestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryPopularTitlesArgs = {
  limit: Scalars['Int']['input'];
  paginationToken?: InputMaybe<Scalars['String']['input']>;
  queryFilter?: InputMaybe<PopularTitlesQueryFilter>;
};


/** Query */
export type QueryPredefinedListArgs = {
  classType: ListClassId;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


/** Query */
export type QueryPrivacyPromptArgs = {
  input: PrivacyPromptInput;
};


/** Query */
export type QueryProfessionArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryProfessionCategoriesArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryProfessionCategoryArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryProfessionNameTrackRecommendationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  input: TrackRecommendationsInput;
};


/** Query */
export type QueryProfessionTitleTrackRecommendationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  input: TrackRecommendationsInput;
};


/** Query */
export type QueryProfessionsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryPromotedVideoAdArgs = {
  input: PromotedVideoAdParameters;
};


/** Query */
export type QueryPromotedVideoAdV2Args = {
  input: PromotedVideoAdParameters;
};


/** Query */
export type QueryRecentVideosArgs = {
  limit: Scalars['Int']['input'];
  paginationToken?: InputMaybe<Scalars['String']['input']>;
  queryFilter?: InputMaybe<RecentVideosQueryFilter>;
};


/** Query */
export type QueryRecentlyViewedItemsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<RecentlyViewedItemsFilter>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryRelatedNewsArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryRenderedMarkdownArgs = {
  markdownString: Scalars['String']['input'];
};


/** Query */
export type QueryRetrieveAccountDataArgs = {
  input: RetrieveAccountDataInput;
};


/** Query */
export type QueryReviewArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QuerySavedSearchFiltersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
  type: SavedSearchFilterType;
};


/** Query */
export type QueryShowtimesTitlesArgs = {
  first: Scalars['Int']['input'];
  location: ShowtimesLocation;
  queryMetadata: ShowtimesTitlesQueryMetadata;
};


/** Query */
export type QueryShowtimesTitlesByCinemasArgs = {
  cinemasMetadata: ShowtimesTitlesCinemasMetadata;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** Query */
export type QuerySignInOptionRedirectUrlArgs = {
  input: SignInOptionRedirectUrlInput;
};


/** Query */
export type QuerySignInOptionsRedirectUrLsArgs = {
  input: SignInOptionsRedirectUrLsInput;
};


/** Query */
export type QuerySimilarNameTrackRecommendationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** Query */
export type QuerySimilarTitleTrackRecommendationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** Query */
export type QueryStreamingTitlesArgs = {
  filter?: InputMaybe<StreamingTitlesFilter>;
};


/** Query */
export type QuerySuggestionSearchArgs = {
  filter?: InputMaybe<SuggestionSearchFilter>;
  first: Scalars['Int']['input'];
  options?: InputMaybe<SuggestionSearchOptions>;
  searchTerm: Scalars['String']['input'];
  shouldShowOriginalTitles?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Query */
export type QuerySymphonyPlacementsArgs = {
  cached?: InputMaybe<Scalars['Boolean']['input']>;
  input: GetPlacementsInput;
};


/** Query */
export type QueryTestContextEntitlementArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryTestEntitlementWithOptInArgs = {
  id: Scalars['String']['input'];
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Query */
export type QueryTestEntitlementWithOptOutArgs = {
  id: Scalars['String']['input'];
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Query */
export type QueryTitleArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryTitleChartRankingsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  input: TitleChartRankingsInput;
};


/** Query */
export type QueryTitleRecommendationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TitleRecommendationsFilter>;
  first: Scalars['Int']['input'];
  placementContext?: InputMaybe<PlacementContext>;
};


/** Query */
export type QueryTitleWatchlistRecommendationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryTitlesArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryTopGrossingReleasesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter: TopGrossingReleasesFilter;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryTopListsForItemArgs = {
  first: Scalars['Int']['input'];
  itemId: Scalars['String']['input'];
  topListType: TopListType;
};


/** Query */
export type QueryTopMeterNamesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryTopMeterTitlesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TopMeterTitlesFilter>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryTopPicksTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryTopTrendingNamesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  input: TopTrendingInput;
};


/** Query */
export type QueryTopTrendingSetsPredefinedArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  input: TopTrendingSetsPredefinedInput;
};


/** Query */
export type QueryTopTrendingTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  input: TopTrendingInput;
};


/** Query */
export type QueryTopTrendingVideosArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  input: TopTrendingInput;
};


/** Query */
export type QueryTrackedNamesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** Query */
export type QueryTrackedTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** Query */
export type QueryTrendingTitlesArgs = {
  limit: Scalars['Int']['input'];
  paginationToken?: InputMaybe<Scalars['String']['input']>;
};


/** Query */
export type QueryUnreleasedTitleTrackRecommendationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  input: TrackRecommendationsInput;
};


/** Query */
export type QueryUserBadgesArgs = {
  first: Scalars['Int']['input'];
  input: UserBadgesInput;
};


/** Query */
export type QueryUserConsentArgs = {
  input: UserConsentInput;
};


/** Query */
export type QueryUserLinkedAuthProviderStatusesArgs = {
  input?: InputMaybe<UserLinkedAuthProviderStatusesInput>;
};


/** Query */
export type QueryUserListSearchArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ListSearchFilter>;
  first: Scalars['Int']['input'];
  listOwnerUserId?: InputMaybe<Scalars['ID']['input']>;
  sort?: InputMaybe<ListSearchSort>;
};


/** Query */
export type QueryUserProfileArgs = {
  input?: InputMaybe<UserProfileInput>;
};


/** Query */
export type QueryUserRatingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  constraints?: InputMaybe<RatingsConstraints>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<RatingsSort>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


/** Query */
export type QueryUserReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  input?: InputMaybe<UserReviewsInput>;
};


/** Query */
export type QueryUserVotedPollsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  userId: Scalars['ID']['input'];
};


/** Query */
export type QueryUserWatchedTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
  input?: InputMaybe<UserWatchedTitlesInput>;
};


/** Query */
export type QueryVanityUrlArgs = {
  urlPath?: InputMaybe<Scalars['String']['input']>;
};


/** Query */
export type QueryVideoArgs = {
  id: Scalars['ID']['input'];
};


/** Query */
export type QueryVideoAdFeedbackUrlArgs = {
  input: VideoAdFeedbackUrlInput;
};


/** Query */
export type QueryVideoAdFeedbackUrlV2Args = {
  input: VideoAdFeedbackUrlInput;
};


/** Query */
export type QueryVideoRecommendationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  context: VideoRecommendationsContext;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryVideosArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


/** Query */
export type QueryWatchProvidersArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<WatchProvidersQueryFilter>;
  first: Scalars['Int']['input'];
};


/** Query */
export type QueryWebAdsArgs = {
  input: WebAdsInput;
};


/** Query */
export type QueryWebAdsConfigArgs = {
  input: WebAdsInput;
};

export type QueryStubs = {
  __typename?: 'QueryStubs';
  matrix?: Maybe<Title>;
};

/** Defines standard form constraints for a radio group type of input. */
export type RadioGroupFieldConstraints = {
  __typename?: 'RadioGroupFieldConstraints';
  /** Specifies if the customer must select an option in the radio group */
  isRequired?: Maybe<BooleanValidationConstraint>;
};

export type RankChange = {
  __typename?: 'RankChange';
  /** Indicates whether the current rank is better (UP), worse (DOWN), or unchanged (FLAT) from the previous rank */
  changeDirection: RankChangeDirection;
  /** A non-negative integer indicating the difference between the current and the previous ranks */
  difference: Scalars['Int']['output'];
};

export enum RankChangeDirection {
  Down = 'DOWN',
  Flat = 'FLAT',
  Up = 'UP'
}

/** The lifetime gross for the title within the relevant area. */
export type RankedLifetimeBoxOfficeGross = {
  __typename?: 'RankedLifetimeBoxOfficeGross';
  /** The BoxOfficeAreaType the gross is related to. */
  boxOfficeAreaType: BoxOfficeAreaType;
  /** The all-time rank for the title. */
  rank?: Maybe<Scalars['Int']['output']>;
  /** The total amount the title made at the box office. */
  total: Money;
};

export type RankedLifetimeBoxOfficeGrossConnection = {
  __typename?: 'RankedLifetimeBoxOfficeGrossConnection';
  /** Pages of ranked lifetime box office grosses */
  edges: Array<Maybe<RankedLifetimeBoxOfficeGrossEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type RankedLifetimeBoxOfficeGrossEdge = {
  __typename?: 'RankedLifetimeBoxOfficeGrossEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** An ranked lifetime box office gross node */
  node: RankedLifetimeBoxOfficeGross;
  /** Position of the node in this context, eg: ranked lifetime box office gross 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type RankedLifetimeBoxOfficeGrossFilter = {
  boxOfficeAreaCodes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type RankedTitleList = {
  /** Match titles based on their ranks */
  rankRange?: InputMaybe<IntRangeInput>;
  /** Select a ranking algorithm */
  rankedTitleListType: RankedTitleListType;
};

export type RankedTitleListSearchConstraint = {
  /** A title match must be in ALL of these ranked title lists. */
  allRankedTitleLists?: InputMaybe<Array<InputMaybe<RankedTitleList>>>;
  /**
   * A title match must be in NONE of these ranked title lists.
   *
   * If the same input is specified in the all and exclude constraints,
   * then the results should be empty.
   */
  excludeRankedTitleLists?: InputMaybe<Array<InputMaybe<RankedTitleList>>>;
};

export enum RankedTitleListType {
  /** Ranking description: https://w.amazon.com/bin/view/IMDb/Ratings/Build/Logic#Lowest_Rated_Movies */
  LowestRatedMovies = 'LOWEST_RATED_MOVIES',
  /** Popularity-based ranking that aggregates titles of type movie, short, and video. */
  MovieMeter = 'MOVIE_METER',
  /** Popularity-based ranking that aggregates titles of all types aside from episodes (like podcast, tv, audio ...) */
  TitleMeter = 'TITLE_METER',
  /** Ranking description: https://w.amazon.com/bin/view/IMDb/Ratings/Build/Logic#Top_Rated_Movies */
  TopRatedMovies = 'TOP_RATED_MOVIES',
  /** Popularity-based ranking that aggregates titles of type tv_series, tv_miniseries, tv_movie, tv_short, and tv_special */
  TvMeter = 'TV_METER'
}

export type Rating = {
  __typename?: 'Rating';
  date: Scalars['DateTime']['output'];
  value: Scalars['Int']['output'];
};

export type RatingValueConstraint = {
  /** Condition we'll be using to match the titles ratings */
  type: RatingsCondition;
  /** Match titles based on their user rating */
  value: Scalars['Int']['input'];
};

export type RatingsBody = {
  __typename?: 'RatingsBody';
  /** The ratings body code. */
  id: Scalars['ID']['output'];
  /** Display text for the rating body. */
  text: Scalars['String']['output'];
};

export enum RatingsCondition {
  Equals = 'EQUALS'
}

export type RatingsConnection = {
  __typename?: 'RatingsConnection';
  edges: Array<Maybe<RatingsEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type RatingsConstraints = {
  ratings?: InputMaybe<RatingValueConstraint>;
};

export type RatingsEdge = {
  __typename?: 'RatingsEdge';
  cursor: Scalars['ID']['output'];
  node: RatingsResult;
};

export type RatingsExportDetail = ExportDetail & {
  __typename?: 'RatingsExportDetail';
  /**
   * The date when the export becomes unavailable.
   * After this date, the export will no longer be returned by the backend.
   */
  expiresOn?: Maybe<Scalars['DateTime']['output']>;
  exportType: ExportType;
  resultUrl?: Maybe<Scalars['URL']['output']>;
  startedOn: Scalars['DateTime']['output'];
  status: ExportStatus;
  /** number of objects in the export */
  totalExportedObjects?: Maybe<Scalars['Int']['output']>;
};

export type RatingsPrivacy = {
  __typename?: 'RatingsPrivacy';
  id: Scalars['ID']['output'];
  /** The language of the ratings privacy setting */
  language: DisplayableLanguage;
  /** The ratings privacy setting. */
  setting: RatingsPrivacySetting;
  /** Localized string value of ratings privacy setting. */
  text: Scalars['String']['output'];
};

export enum RatingsPrivacySetting {
  /** Ratings are always private */
  Private = 'PRIVATE',
  /** Ratings are always public */
  Public = 'PUBLIC',
  /** Ratings are only public with attached review */
  PublicWithReviews = 'PUBLIC_WITH_REVIEWS'
}

export type RatingsResult = {
  __typename?: 'RatingsResult';
  title: Title;
  /**
   * Retrieve user's rating data for the associated title. A null value is supported here
   * in case a rating does not exist.
   * Error cases:
   * - Throws FORBIDDEN if requesting user is not authorized to view this rating
   * This field intentionally mirrors Title.userRating's behavior to maintain
   * consistency across the API. While the same information could be accessed via
   * title.userRating, this field provides better performance when retrieving multiple ratings
   */
  userRating?: Maybe<Rating>;
};

export type RatingsSort = {
  by: RatingsSortBy;
  order: SortOrder;
};

export enum RatingsSortBy {
  /**
   * Sort by most recent rating date.
   * ASC: Oldest ratings will be first.
   * DESC: Newest ratings will be first.
   */
  MostRecent = 'MOST_RECENT',
  /**
   * Sort by highest rating
   * ASC: Highest ratings will be first.
   * DESC: Lowest ratings will be first.
   */
  TopRated = 'TOP_RATED'
}

export type RatingsSummary = {
  __typename?: 'RatingsSummary';
  aggregateRating?: Maybe<Scalars['Float']['output']>;
  /**
   * Optional notification text to be displayed about ratings summary.
   * Notification language will default to English for now
   */
  notificationText?: Maybe<LocalizedMarkdown>;
  topRanking?: Maybe<TopRanking>;
  voteCount: Scalars['Int']['output'];
};

export type RatingsSummaryByCountry = {
  __typename?: 'RatingsSummaryByCountry';
  aggregate: Scalars['Float']['output'];
  country: Country;
  /** Defaults to English for now */
  displayText: LocalizedString;
  voteCount: Scalars['Int']['output'];
};

/** Defines the base Reaction type, holding a description and ID */
export type Reaction = {
  __typename?: 'Reaction';
  /** Obfuscated identifier for the localized reaction */
  id: Scalars['ID']['output'];
  /** Language of the display text */
  language: DisplayableLanguage;
  /** Unique, readable identifier for the reaction */
  reactionId: Scalars['ID']['output'];
  /** User-visible description of the reaction */
  text: Scalars['String']['output'];
};

/** Holds a reaction and its current count */
export type ReactionSummary = {
  __typename?: 'ReactionSummary';
  /** Current reaction count */
  count: Scalars['Int']['output'];
  /** Count used for display purposes, utilizes truncation. For example '3200' will be truncated to '3.2k' */
  displayCount: LocalizedString;
  /** The entity reaction */
  reaction: Reaction;
};

/** Defines a group of reactions */
export type ReactionSummaryGroup = {
  __typename?: 'ReactionSummaryGroup';
  /** Sum of all reaction counts in the group */
  aggregateCount: Scalars['Int']['output'];
  /** Count used for display purposes, utilizes truncation. For example '3200' will be truncated to '3.2k' */
  displayCount: LocalizedString;
  /** Unique identifier for the group. */
  groupId: Scalars['ID']['output'];
  /** List of reactions in the group, and their individual counts */
  reactionSummaries: Array<Maybe<ReactionSummary>>;
  /** Denotes if a given ReactionsGroup should allow a SINGLE reaction to be selected, or MULTIPLE */
  selectionType: ReactionsGroupSelectionType;
};

/**
 * Denotes if a given ReactionsGroup should allow a SINGLE reaction to be selected,
 * or MULTIPLE
 */
export enum ReactionsGroupSelectionType {
  /** Denotes there is no limit to the number of reactions from a group that may be selected */
  Multiple = 'MULTIPLE',
  /** Denotes only one reaction from the group may be selected at a time */
  Single = 'SINGLE'
}

/** Defines list of Reaction Summary Groups */
export type ReactionsSummary = {
  __typename?: 'ReactionsSummary';
  /**
   * Array of multiple groups of reactions
   * Sorted by aggregate count, descending
   * Groups each set of reactions, defines how many reactions can be selected from
   * the group at a time, and provides an aggregate count for all reactions in the group
   */
  reactionSummaryGroups: Array<Maybe<ReactionSummaryGroup>>;
};

export type RecentVideosQueryFilter = {
  contentTypes?: InputMaybe<Array<InputMaybe<VideoContentTypeId>>>;
};

export type RecentlyViewedConnection = {
  __typename?: 'RecentlyViewedConnection';
  edges: Array<Maybe<RecentlyViewedEdge>>;
  pageInfo: PageInfo;
  refTag?: Maybe<RefTag>;
};

export type RecentlyViewedEdge = {
  __typename?: 'RecentlyViewedEdge';
  cursor: Scalars['ID']['output'];
  node: RecentlyViewedItem;
  position: Scalars['Int']['output'];
};

export type RecentlyViewedItem = Company | Name | Title;

/** Filter which recently viewed items to return */
export type RecentlyViewedItemsFilter = {
  domain: BusinessDomain;
};

/**
 * Recent page view statistics for a given Pro claimed name page,
 * including a more detailed breakdown if available
 */
export type RecentlyViewedStatistics = {
  __typename?: 'RecentlyViewedStatistics';
  /** Summary of profession counts of people who viewed the page */
  professionCountsSummary?: Maybe<ProfessionCountsSummary>;
  /** Number of unique customers who viewed the page */
  uniquePageViewCount: Scalars['Int']['output'];
};

export type RecommendationExplanation = {
  __typename?: 'RecommendationExplanation';
  title: Title;
};

export type RecommendedVideoTimedTextTrackFilter = {
  /** If no VideoTimedTextTrackFormat is provided it will default to SRT. */
  format?: InputMaybe<VideoTimedTextTrackFormat>;
  /** Used to override the language from the x-imdb-user-language header. */
  language?: InputMaybe<Scalars['Language']['input']>;
};

export type RedirectLink = {
  __typename?: 'RedirectLink';
  /** The text to display for the link */
  label: LocalizedString;
  /** The URL to redirect to */
  url: Scalars['URL']['output'];
};

export type RefTag = {
  __typename?: 'RefTag';
  ep13nReftag?: Maybe<Scalars['String']['output']>;
};

export type RegionCertificateRatingInput = {
  /** For example: 'PG-13' */
  rating: Scalars['String']['input'];
  /** For example: 'US' */
  region: Scalars['String']['input'];
};

/** Details of news items related to a particular article */
export type RelatedNews = {
  __typename?: 'RelatedNews';
  /** Entity of the title, name, or company mentioned in the input article */
  entity: NewsEntity;
  /** List of most recent items about the entity */
  items: Array<Maybe<News>>;
};

export type RelationName = {
  __typename?: 'RelationName';
  /** Relative displayable property as Markdown */
  displayableProperty: DisplayableRelationNameProperty;
  /** Name association to the relative if the relative has an IMDb Name that is known */
  name?: Maybe<Name>;
  /** Display name text as plain text */
  nameText?: Maybe<Scalars['String']['output']>;
};

export enum RelationshipTypeFilter {
  Children = 'CHILDREN',
  Others = 'OTHERS',
  Parents = 'PARENTS',
  Unrelated = 'UNRELATED'
}

export type ReleaseDate = {
  __typename?: 'ReleaseDate';
  /** Additional attributes */
  attributes?: Maybe<Array<Maybe<DisplayableAttribute>>>;
  country?: Maybe<LocalizedDisplayableCountry>;
  day?: Maybe<Scalars['Int']['output']>;
  /** The release date displayable property */
  displayableProperty: DisplayableTitleReleaseDateProperty;
  month?: Maybe<Scalars['Int']['output']>;
  restriction?: Maybe<ReleaseDateRestriction>;
  year?: Maybe<Scalars['Int']['output']>;
};

export type ReleaseDateConnection = {
  __typename?: 'ReleaseDateConnection';
  edges: Array<Maybe<ReleaseDateEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type ReleaseDateEdge = {
  __typename?: 'ReleaseDateEdge';
  cursor: Scalars['ID']['output'];
  node: ReleaseDate;
  position: Scalars['Int']['output'];
};

/** Information about restrictions applied to release date */
export type ReleaseDateRestriction = {
  __typename?: 'ReleaseDateRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
};

export type ReleaseDateSearchConstraint = {
  /** The earliest release date for a title must fall within the specified range */
  releaseDateRange?: InputMaybe<DateRange>;
};

export type RepresentationRelationshipType = {
  __typename?: 'RepresentationRelationshipType';
  /** An obfuscated persistent id to uniquely identify this data */
  id: Scalars['ID']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /**
   * A non-localized, somewhat human readable string representing this relationship
   * type
   *
   * Intended to support filtering or search behavior where we need a unique
   * way to represent this relationship type
   *
   * Example: 'talentAgent'
   */
  relationshipTypeId: Scalars['String']['output'];
  /** The display text for this relationship type - 'Talent Agent' */
  text: Scalars['String']['output'];
};

/** Restriction explanations */
export type RestrictionExplanation = {
  __typename?: 'RestrictionExplanation';
  /** Explanation id */
  id: Scalars['ID']['output'];
  /** Restriction reason for which explanation is about. */
  reason: ContentRestrictionReason;
  /**
   * A human readable text string, intended to provide details of what is being
   * restricted e.g. Cast is limited to 5 for in-development titles.
   */
  text: Scalars['String']['output'];
};

/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type Resume = {
  __typename?: 'Resume';
  /** Self verified additional awards for this name. */
  additionalAwards?: Maybe<SelfVerifiedAwardConnection>;
  /** Self verified additional credits data for this name. */
  additionalCreditCategories?: Maybe<ResumeAdditionalCreditsCategories>;
  /** Self verified additional resume sections for this name. */
  additionalResumeInfo?: Maybe<AdditionalResumeInfoConnection>;
  /** Self verified training history data for this name. */
  education?: Maybe<SelfVerifiedEducationConnection>;
  /** Self verified performer profile data for this name. */
  performerProfile?: Maybe<Array<Maybe<ResumeDataItem>>>;
  /** Self verified personal details data for this name. */
  personalDetails?: Maybe<Array<Maybe<ResumeDataItem>>>;
  /** Self verified profession background data for this name. */
  professionalBackground?: Maybe<Array<Maybe<ResumeDataItem>>>;
  /** Self verified references for this name. */
  references?: Maybe<SelfVerifiedReferenceConnection>;
  /** Self verified skills data for this name. */
  skills?: Maybe<Array<Maybe<ResumeDataItem>>>;
  /** Self verified training history data for this name. */
  training?: Maybe<SelfVerifiedTrainingConnection>;
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumeAdditionalAwardsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumeAdditionalCreditCategoriesArgs = {
  input?: InputMaybe<AdditionalCreditCategoriesInput>;
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumeAdditionalResumeInfoArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumeEducationArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumePerformerProfileArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumePersonalDetailsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumeProfessionalBackgroundArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumeReferencesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumeSkillsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


/**
 * All fields under this type are considered self-verified. This means that we accept the Pro customer's submission for
 *   their own name page at face value and display it on their page without any guarantees of its validity.
 */
export type ResumeTrainingArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};

export type ResumeAdditionalCreditsCategories = {
  __typename?: 'ResumeAdditionalCreditsCategories';
  /** A list of categories for additional credits on a name page. */
  categories: Array<Maybe<ResumeAdditionalCreditsCategory>>;
  /** The total number of categories returned. */
  total: Scalars['Int']['output'];
};

/**
 * These categories differ from normal credit categories and are specific to the
 *   unvetted additional credits pro customers can add to their resume.
 */
export type ResumeAdditionalCreditsCategory = {
  __typename?: 'ResumeAdditionalCreditsCategory';
  /**
   * A list of credits belonging to this category.
   *
   * Ordered by ascending contribution date.
   */
  credits: Array<Maybe<AdditionalCreditItem>>;
  /** The unique identifier for the credit category. */
  id: Scalars['ID']['output'];
  /** The displayable title for the category. */
  title: LocalizedString;
  /** The total number of credits in this category. */
  total: Scalars['Int']['output'];
};


/**
 * These categories differ from normal credit categories and are specific to the
 *   unvetted additional credits pro customers can add to their resume.
 */
export type ResumeAdditionalCreditsCategoryCreditsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type ResumeDataItem = {
  __typename?: 'ResumeDataItem';
  /** The label for the data item. */
  label: LocalizedString;
  /** The value for the data item. */
  values?: Maybe<Array<Maybe<LocalizedString>>>;
};

export type RetrieveAccountDataInput = {
  /** Part of the confirmation link */
  dataRequestId: Scalars['ID']['input'];
};

export type RetrieveAccountDataOutput = {
  __typename?: 'RetrieveAccountDataOutput';
  /** Returns the file metadata for the requested data. Will return one file. */
  fileMetadata: Array<Maybe<FileMetadata>>;
  message: LocalizedMarkdown;
  success: Scalars['Boolean']['output'];
  title: LocalizedMarkdown;
};

/** Cacheable except when query includes correctionLink and/or deletionLink fields. */
export type Review = {
  __typename?: 'Review';
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  author?: Maybe<UserProfile>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  authorRating?: Maybe<Scalars['Int']['output']>;
  /**
   * Returns the Contribute Site link for the requesting user to edit the review if they authored it.
   * Returns null if the requesting user did not author the review.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  correctionLink?: Maybe<ContributionLink>;
  /**
   * Returns the Contribute Site link for the requesting user to delete the review if they authored it.
   * Returns null if the requesting user did not author the review.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  deletionLink?: Maybe<ContributionLink>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  helpfulness?: Maybe<ReviewHelpfulness>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  id: Scalars['ID']['output'];
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  language?: Maybe<Scalars['Language']['output']>;
  /**
   * Returns the review reporting link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  reportingLink?: Maybe<ContributionLink>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  spoiler?: Maybe<Scalars['Boolean']['output']>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  submissionDate?: Maybe<Scalars['Date']['output']>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  summary?: Maybe<ReviewSummary>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  text?: Maybe<ReviewText>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  title?: Maybe<Title>;
};


/** Cacheable except when query includes correctionLink and/or deletionLink fields. */
export type ReviewCorrectionLinkArgs = {
  contributionContext: ContributionContext;
};


/** Cacheable except when query includes correctionLink and/or deletionLink fields. */
export type ReviewDeletionLinkArgs = {
  contributionContext: ContributionContext;
};


/** Cacheable except when query includes correctionLink and/or deletionLink fields. */
export type ReviewReportingLinkArgs = {
  contributionContext: ContributionContext;
};

export type ReviewEdge = {
  __typename?: 'ReviewEdge';
  cursor: Scalars['ID']['output'];
  node: Review;
};

export type ReviewHelpfulness = {
  __typename?: 'ReviewHelpfulness';
  downVotes: Scalars['Int']['output'];
  score: Scalars['Float']['output'];
  upVotes: Scalars['Int']['output'];
};

export type ReviewSummary = {
  __typename?: 'ReviewSummary';
  originalText: Scalars['String']['output'];
};

export type ReviewText = {
  __typename?: 'ReviewText';
  originalText: Markdown;
};

export type ReviewsConnection = {
  __typename?: 'ReviewsConnection';
  edges: Array<Maybe<ReviewEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type ReviewsFilter = {
  /** Filter by author's Rating value. Ratings value can be any integer between 1 and 10. */
  authorRating?: InputMaybe<Scalars['Int']['input']>;
  /** Filter reviews based on whether they contain spoilers. */
  spoiler?: InputMaybe<FilterInclusion>;
};

export type ReviewsSort = {
  by: ReviewsSortBy;
  order: SortOrder;
};

export enum ReviewsSortBy {
  HelpfulnessScore = 'HELPFULNESS_SCORE',
  SubmissionDate = 'SUBMISSION_DATE',
  SubmitterReviewCount = 'SUBMITTER_REVIEW_COUNT',
  TotalVotes = 'TOTAL_VOTES',
  UserRating = 'USER_RATING'
}

export type Runtime = {
  __typename?: 'Runtime';
  attributes: Array<Maybe<DisplayableAttribute>>;
  country?: Maybe<DisplayableCountry>;
  displayableProperty: DisplayableTitleRuntimeProperty;
  id: Scalars['ID']['output'];
  seconds: Scalars['Int']['output'];
};

/** Pagination for Runtime types which always has a known total number of edges. */
export type RuntimeConnection = {
  __typename?: 'RuntimeConnection';
  /** Pages of Runtime */
  edges: Array<Maybe<RuntimeEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Runtime */
export type RuntimeEdge = {
  __typename?: 'RuntimeEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Runtime node */
  node: Runtime;
  /** Position of the node in this context, eg: Runtime 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type RuntimeSearchConstraint = {
  /** A title match must have a runtime within the specified range */
  runtimeRangeMinutes?: InputMaybe<IntRangeInput>;
};

export type Salary = {
  __typename?: 'Salary';
  amount?: Maybe<Money>;
  /** The attributes/qualifiers of that salary */
  attributes?: Maybe<Array<Maybe<DisplayableAttribute>>>;
  /** The salary as a displayable property */
  displayableProperty: DisplayableSalaryProperty;
  id: Scalars['ID']['output'];
  /** The title for which this salary applies. */
  title: Title;
};

/** Pagination for Salary */
export type SalaryConnection = {
  __typename?: 'SalaryConnection';
  /** Pages of Salary */
  edges: Array<Maybe<SalaryEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Salary */
export type SalaryEdge = {
  __typename?: 'SalaryEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the person's salaries */
  node: Salary;
  /** Position of the node in this context, eg: Salary 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type SavedSearchFilter = {
  __typename?: 'SavedSearchFilter';
  /** The time when the filter was created */
  createdTimestamp: Scalars['DateTime']['output'];
  /** The name of the saved filter */
  name: Scalars['String']['output'];
  /** Generated field, this will be unique under the same user and filter type. */
  saveId: Scalars['ID']['output'];
  /**
   * The domain the filter applies to, such as Names, Titles etc.
   * The types available are defined in SavedSearchFilterType
   */
  type: SavedSearchFilterType;
  /** The time when the filter was last updated */
  updatedTimestamp: Scalars['DateTime']['output'];
  /** Url of the filter */
  url: Scalars['String']['output'];
};

export enum SavedSearchFilterType {
  /** Filter on tagged names in lists */
  ListItemNameTags = 'LIST_ITEM_NAME_TAGS',
  /** Filter on tagged titles in lists */
  ListItemTitleTags = 'LIST_ITEM_TITLE_TAGS',
  /** Filter on Names */
  Name = 'NAME',
  /** Filter on Titles */
  Title = 'TITLE'
}

/** Pagination for SavedSearchFilters. */
export type SavedSearchFiltersConnection = {
  __typename?: 'SavedSearchFiltersConnection';
  edges: Array<Maybe<SavedSearchFiltersEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

/** Item in a page of saved search filters results. */
export type SavedSearchFiltersEdge = {
  __typename?: 'SavedSearchFiltersEdge';
  cursor: Scalars['ID']['output'];
  /** Saved search filters node */
  node: SavedSearchFilter;
};

/**
 * Date and time of a screening.
 * The screening time will be in the timezone of the Cinema.
 */
export type ScreeningDateTime = {
  __typename?: 'ScreeningDateTime';
  /** DateTime of the screening in ISO 8601 format. */
  dateTime: Scalars['DateTime']['output'];
  /** Unique identifier for this ScreeningDateTime. */
  id: Scalars['ID']['output'];
  /** Language of the display text for the time of the screening. */
  language: DisplayableLanguage;
  /** Display text for the time of the screening. */
  text: Scalars['String']['output'];
};

export type SearchAwardCategory = {
  __typename?: 'SearchAwardCategory';
  /** Search-specific identifier for the award category for use in search filtering. */
  id: Scalars['ID']['output'];
  /** Language of the display text returned for the award category */
  language: DisplayableLanguage;
  /** Localized displayable name for the award category. */
  text: Scalars['String']['output'];
};

export type SearchAwardEvent = {
  __typename?: 'SearchAwardEvent';
  /** A selection of award categories specific to this event to be displayed as additional search filtering options. */
  awardCategories?: Maybe<Array<Maybe<SearchAwardCategory>>>;
  /** The event const. For example, `ev0000003` is the id for Oscars. */
  id: Scalars['ID']['output'];
  /** Language of the display text returned for the event */
  language: DisplayableLanguage;
  /** Localized displayable name for the event. */
  text: Scalars['String']['output'];
};

export type SearchAwardEventOptions = {
  __typename?: 'SearchAwardEventOptions';
  /** Collection of events and specific award categories to display as options for search. */
  events: Array<Maybe<SearchAwardEvent>>;
};

export type SearchFacet = {
  __typename?: 'SearchFacet';
  /** The value which can be used in a search constraint */
  filterId: Scalars['ID']['output'];
  /** A globally unique identifier for this facet */
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
  /** The count of entities associated with this facet */
  total: Scalars['Int']['output'];
};

export type SearchMetadata = {
  __typename?: 'SearchMetadata';
  /** Curated list of award events and categories to use as filters for advanced search. */
  advancedSearchAwardOptions: SearchAwardEventOptions;
};

export enum SearchTheaterAttribute {
  OnlineTicketing = 'ONLINE_TICKETING'
}

export enum SearchWatchOptionType {
  /**
   * Match titles with any digital watch options including subscriptions and
   * rent/buy to stream online.
   */
  AnyDigital = 'ANY_DIGITAL',
  /**
   * Match titles with a subscription-based streaming watch option
   * For example, watch options on Prime, Hulu, Netflix, etc. that can be streamed
   * with a subscription
   */
  Subscription = 'SUBSCRIPTION'
}

export type SeasonValueDisplayableProperty = {
  __typename?: 'SeasonValueDisplayableProperty';
  value: Markdown;
};

export type SectionCallToAction = {
  __typename?: 'SectionCallToAction';
  /** Contains the action link data */
  action: ActionLink;
  /**
   * An identifier for the returned result of a CTA.
   * A CTA will have multiple potential results, with each result having its own identifier.
   * This value is only unique within the CTA. It is not globally unique.
   * The resultId can be used as resultOverride input argument to specify a specific result
   * should be returned for the requested CTA.
   */
  resultId: Scalars['ResultID']['output'];
  /** Provides the secondary localized text for a CTA. */
  sectionContent?: Maybe<CallToActionText>;
  /** Provides the primary localized text for a CTA. */
  sectionTitle?: Maybe<CallToActionText>;
};

/** Defines standard form constraints for a select / dropdown type of input, */
export type SelectFieldConstraints = {
  __typename?: 'SelectFieldConstraints';
  /** Specifies if the customer must select an option in the dropdown/select menu */
  isRequired?: Maybe<BooleanValidationConstraint>;
};

export type SelfVerified = {
  __typename?: 'SelfVerified';
  /** Returns true if the item has been verified by the name owner */
  isSelfVerified: Scalars['Boolean']['output'];
};

export type SelfVerifiedAward = {
  __typename?: 'SelfVerifiedAward';
  /** The title of the award. */
  awardTitle?: Maybe<LocalizedString>;
  /** Additional details about the award. */
  details?: Maybe<LocalizedString>;
  /** The name of the event for the award. */
  event?: Maybe<LocalizedString>;
  /** A unique identifier for a resume self-verified award. */
  id: Scalars['ID']['output'];
  /** The year in which the award was received. */
  year?: Maybe<Scalars['Int']['output']>;
};

export type SelfVerifiedAwardConnection = {
  __typename?: 'SelfVerifiedAwardConnection';
  edges: Array<Maybe<SelfVerifiedAwardEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type SelfVerifiedAwardEdge = {
  __typename?: 'SelfVerifiedAwardEdge';
  cursor: Scalars['ID']['output'];
  node: SelfVerifiedAward;
  position: Scalars['Int']['output'];
};

export type SelfVerifiedEducation = {
  __typename?: 'SelfVerifiedEducation';
  /** The degree that the person received. */
  degree?: Maybe<LocalizedString>;
  /** Additional details about their education. */
  details?: Maybe<LocalizedString>;
  /** A unique identifier for the resume education item. */
  id: Scalars['ID']['output'];
  /** The location of the school */
  location?: Maybe<LocalizedString>;
  /** The name of the school. */
  school?: Maybe<LocalizedString>;
  /** The year in which they completed their education. */
  year?: Maybe<Scalars['Int']['output']>;
};

export type SelfVerifiedEducationConnection = {
  __typename?: 'SelfVerifiedEducationConnection';
  edges: Array<Maybe<SelfVerifiedEducationEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type SelfVerifiedEducationEdge = {
  __typename?: 'SelfVerifiedEducationEdge';
  cursor: Scalars['ID']['output'];
  node: SelfVerifiedEducation;
  position: Scalars['Int']['output'];
};

export type SelfVerifiedNameAttribute = {
  __typename?: 'SelfVerifiedNameAttribute';
  /** Total number of individual values (different than values length, if it is constrained by 'limit' argument) */
  total: Scalars['Int']['output'];
  /** The individual values matching input arguments (e.g. 'limit') */
  values: Array<Maybe<SelfVerifiedNameAttributeValue>>;
};

export type SelfVerifiedNameAttributeMetadata = {
  __typename?: 'SelfVerifiedNameAttributeMetadata';
  /** Whether this attribute allows free-form text value */
  allowFreeFormText: Scalars['Boolean']['output'];
  /** The maximum number of values a customer can have for this attribute. A null value means no limit */
  limit?: Maybe<Scalars['Int']['output']>;
  /** All valid values for this attribute */
  validValues?: Maybe<Array<Maybe<SelfVerifiedNameAttributeValue>>>;
};

export type SelfVerifiedNameAttributeValue = {
  __typename?: 'SelfVerifiedNameAttributeValue';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type SelfVerifiedNameAward = {
  __typename?: 'SelfVerifiedNameAward';
  /** Any additional details of the award */
  details?: Maybe<SelfVerifiedNameAttributeValue>;
  event: SelfVerifiedNameAttributeValue;
  /** The unique ID of this award item */
  id: Scalars['ID']['output'];
  name: SelfVerifiedNameAttributeValue;
  year: Scalars['Int']['output'];
};

export type SelfVerifiedNameAwardConnection = {
  __typename?: 'SelfVerifiedNameAwardConnection';
  /** A page of awards */
  edges: Array<Maybe<SelfVerifiedNameAwardEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of awards */
  total: Scalars['Int']['output'];
};

export type SelfVerifiedNameAwardEdge = {
  __typename?: 'SelfVerifiedNameAwardEdge';
  cursor: Scalars['ID']['output'];
  /** A single award node */
  node: SelfVerifiedNameAward;
  /** 1-based position of the node in this context */
  position: Scalars['Int']['output'];
};

export type SelfVerifiedNameCredit = {
  __typename?: 'SelfVerifiedNameCredit';
  companyOrDirector?: Maybe<SelfVerifiedNameAttributeValue>;
  /** The unique ID of this credit item */
  id: Scalars['ID']['output'];
  projectTitle: SelfVerifiedNameAttributeValue;
  roleOrPosition?: Maybe<SelfVerifiedNameAttributeValue>;
  type: SelfVerifiedNameCreditType;
};

export type SelfVerifiedNameCreditConnection = {
  __typename?: 'SelfVerifiedNameCreditConnection';
  /** A page of credits */
  edges: Array<Maybe<SelfVerifiedNameCreditEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of credits */
  total: Scalars['Int']['output'];
};

export type SelfVerifiedNameCreditEdge = {
  __typename?: 'SelfVerifiedNameCreditEdge';
  cursor: Scalars['ID']['output'];
  /** A single credit node */
  node: SelfVerifiedNameCredit;
  /** 1-based position of the node in this context */
  position: Scalars['Int']['output'];
};

export type SelfVerifiedNameCreditMetadata = {
  __typename?: 'SelfVerifiedNameCreditMetadata';
  /** All credit types */
  creditTypes: Array<Maybe<SelfVerifiedNameCreditType>>;
  /** The maximum number of credits a customer can have for each credit type */
  limit: Scalars['Int']['output'];
};

export type SelfVerifiedNameCreditType = {
  __typename?: 'SelfVerifiedNameCreditType';
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
};

export type SelfVerifiedNameCreditTypeFilter = {
  /** Type credit types to exclude from the response (cannot be specified together with 'includeTypes') */
  excludeTypes?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Type credit types to include in the response (cannot be specified together with 'excludeTypes') */
  includeTypes?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type SelfVerifiedNameCreditTypeWithCredits = {
  __typename?: 'SelfVerifiedNameCreditTypeWithCredits';
  creditType: SelfVerifiedNameCreditType;
  credits?: Maybe<SelfVerifiedNameCreditConnection>;
};


export type SelfVerifiedNameCreditTypeWithCreditsCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type SelfVerifiedNameData = {
  __typename?: 'SelfVerifiedNameData';
  /**
   * The person's accents
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  accents?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The age range of characters that the person can play
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  agePlayingRange?: Maybe<AgePlayingRange>;
  /**
   * The person's athletic skills
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  athleticSkills?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's self-verified awards
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  awards?: Maybe<SelfVerifiedNameAwardConnection>;
  /**
   * Link for the person's blog
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  blog?: Maybe<BlogLink>;
  /**
   * The person's self-verified credits grouped by credit types
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  creditTypes?: Maybe<Array<Maybe<SelfVerifiedNameCreditTypeWithCredits>>>;
  /**
   * The types of the person's dance skills
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  danceSkills?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's educational history
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  educationalHistory?: Maybe<SelfVerifiedNameEducationalHistoryConnection>;
  /**
   * The person's ethnic appearances, i.e. ethnicities the person appears to be in
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  ethnicAppearances?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's eye color
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  eyeColor?: Maybe<SelfVerifiedNameAttributeValue>;
  /** The person's guild affiliation visibilities */
  guildAffiliationVisibilities?: Maybe<GuildAffiliationVisibilitiesConnection>;
  /** The person's guild affiliations */
  guildAffiliations?: Maybe<GuildAffiliationsConnection>;
  /**
   * The person's guild status
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  guildStatus?: Maybe<GuildStatus>;
  /**
   * The person's hair color
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  hairColor?: Maybe<SelfVerifiedNameAttributeValue>;
  /**
   * The person's hair length
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  hairLength?: Maybe<SelfVerifiedNameAttributeValue>;
  /**
   * True if the person has valid passport
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  hasValidPassport?: Maybe<Scalars['Boolean']['output']>;
  /**
   * True if the person is willing to work unpaid
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  isWillingToWorkUnpaid?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The person's self-verified job categories
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  jobCategories?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's job titles
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  jobTitles?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * Musical instruments that the person can play
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  musicalInstruments?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's performer skills
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  performerSkills?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's personal locations
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  personalLocations?: Maybe<NamePersonalLocations>;
  /**
   * The person's physique
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  physique?: Maybe<SelfVerifiedNameAttributeValue>;
  /**
   * The person's primary citizenship
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  primaryCitizenship?: Maybe<LocalizedDisplayableCountry>;
  /**
   * The person's references from other people
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  references?: Maybe<SelfVerifiedNameReferenceConnection>;
  /**
   * The person's custom sections in resume
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  resumeCustomSections?: Maybe<SelfVerifiedResumeCustomSectionConnection>;
  /**
   * The person's additional resume details
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  resumeDetails?: Maybe<SelfVerifiedNameAttributeValue>;
  /**
   * Languages that the person can speak
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  spokenLanguages?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's training experiences
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  trainings?: Maybe<SelfVerifiedNameTrainingConnection>;
  /**
   * Link for the person's twitter
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  twitter?: Maybe<TwitterLink>;
  /**
   * The person's unique traits
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  uniqueTraits?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's voice types
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  voiceTypes?: Maybe<SelfVerifiedNameAttribute>;
  /**
   * The person's weight
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  weight?: Maybe<NameWeight>;
  /**
   * The person's work authorization information in countries
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  workAuthorizationCountries?: Maybe<WorkAuthorizationCountries>;
  /**
   * The credit types the person has ever worked as
   *
   * Throws UNAUTHENTICATED if not logged in
   * @entitlement(PRO_ANY_TIER)
   */
  workHistoryCreditTypes?: Maybe<SelfVerifiedNameAttribute>;
};


export type SelfVerifiedNameDataAccentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataAthleticSkillsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataAwardsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataCreditTypesArgs = {
  filter?: InputMaybe<SelfVerifiedNameCreditTypeFilter>;
};


export type SelfVerifiedNameDataDanceSkillsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataEducationalHistoryArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataEthnicAppearancesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataGuildAffiliationVisibilitiesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<GuildAffiliationsFilter>;
  first: Scalars['Int']['input'];
};


export type SelfVerifiedNameDataGuildAffiliationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<GuildAffiliationsFilter>;
  first: Scalars['Int']['input'];
};


export type SelfVerifiedNameDataJobCategoriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataJobTitlesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataMusicalInstrumentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataPerformerSkillsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataPersonalLocationsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataReferencesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataResumeCustomSectionsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataSpokenLanguagesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataTrainingsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataUniqueTraitsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataVoiceTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataWeightArgs = {
  input?: InputMaybe<GetNameWeightInput>;
};


export type SelfVerifiedNameDataWorkAuthorizationCountriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type SelfVerifiedNameDataWorkHistoryCreditTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type SelfVerifiedNameEducation = {
  __typename?: 'SelfVerifiedNameEducation';
  degree: SelfVerifiedNameAttributeValue;
  details?: Maybe<SelfVerifiedNameAttributeValue>;
  /** The unique ID of this education item */
  id: Scalars['ID']['output'];
  location: SelfVerifiedNameAttributeValue;
  school: SelfVerifiedNameAttributeValue;
  year: Scalars['Int']['output'];
};

export type SelfVerifiedNameEducationEdge = {
  __typename?: 'SelfVerifiedNameEducationEdge';
  cursor: Scalars['ID']['output'];
  /** A single education item node */
  node?: Maybe<SelfVerifiedNameEducation>;
  /** 1-based position of the node in this context */
  position: Scalars['Int']['output'];
};

export type SelfVerifiedNameEducationalHistoryConnection = {
  __typename?: 'SelfVerifiedNameEducationalHistoryConnection';
  /** A page of education items */
  edges: Array<Maybe<SelfVerifiedNameEducationEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of education items */
  total: Scalars['Int']['output'];
};

/** Metadata for some self-verified name data attributes */
export type SelfVerifiedNameMetadata = {
  __typename?: 'SelfVerifiedNameMetadata';
  accent?: Maybe<SelfVerifiedNameAttributeMetadata>;
  athleticSkill?: Maybe<SelfVerifiedNameAttributeMetadata>;
  award?: Maybe<SelfVerifiedNameAttributeMetadata>;
  credit?: Maybe<SelfVerifiedNameCreditMetadata>;
  danceSkill?: Maybe<SelfVerifiedNameAttributeMetadata>;
  educationalHistory?: Maybe<SelfVerifiedNameAttributeMetadata>;
  ethnicAppearance?: Maybe<SelfVerifiedNameAttributeMetadata>;
  eyeColor?: Maybe<SelfVerifiedNameAttributeMetadata>;
  guildAffiliation?: Maybe<SelfVerifiedNameAttributeMetadata>;
  hairColor?: Maybe<SelfVerifiedNameAttributeMetadata>;
  hairLength?: Maybe<SelfVerifiedNameAttributeMetadata>;
  jobCategory?: Maybe<SelfVerifiedNameAttributeMetadata>;
  jobTitle?: Maybe<SelfVerifiedNameAttributeMetadata>;
  musicalInstrument?: Maybe<SelfVerifiedNameAttributeMetadata>;
  performerSkill?: Maybe<SelfVerifiedNameAttributeMetadata>;
  personalLocation?: Maybe<NamePersonalLocationMetadata>;
  physique?: Maybe<SelfVerifiedNameAttributeMetadata>;
  primaryCitizenship?: Maybe<CountryAttributeMetadata>;
  reference?: Maybe<SelfVerifiedNameAttributeMetadata>;
  resumeCustomSection?: Maybe<SelfVerifiedNameAttributeMetadata>;
  spokenLanguage?: Maybe<SelfVerifiedNameAttributeMetadata>;
  training?: Maybe<SelfVerifiedNameAttributeMetadata>;
  uniqueTrait?: Maybe<SelfVerifiedNameAttributeMetadata>;
  voiceType?: Maybe<SelfVerifiedNameAttributeMetadata>;
  workAuthorizationCountry?: Maybe<CountryAttributeMetadata>;
  workHistoryCreditType?: Maybe<SelfVerifiedNameAttributeMetadata>;
};

export type SelfVerifiedNameReference = {
  __typename?: 'SelfVerifiedNameReference';
  contactInfo?: Maybe<SelfVerifiedNameAttributeValue>;
  /** The unique ID of this reference item */
  id: Scalars['ID']['output'];
  name: SelfVerifiedNameAttributeValue;
  relationship: SelfVerifiedNameAttributeValue;
};

export type SelfVerifiedNameReferenceConnection = {
  __typename?: 'SelfVerifiedNameReferenceConnection';
  /** A page of references */
  edges: Array<Maybe<SelfVerifiedNameReferenceEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of references */
  total: Scalars['Int']['output'];
};

export type SelfVerifiedNameReferenceEdge = {
  __typename?: 'SelfVerifiedNameReferenceEdge';
  cursor: Scalars['ID']['output'];
  /** A single reference node */
  node: SelfVerifiedNameReference;
  /** 1-based position of this node in this context */
  position: Scalars['Int']['output'];
};

export type SelfVerifiedNameTraining = {
  __typename?: 'SelfVerifiedNameTraining';
  details?: Maybe<SelfVerifiedNameAttributeValue>;
  /** The unique ID of this training item */
  id: Scalars['ID']['output'];
  instructor: SelfVerifiedNameAttributeValue;
  location: SelfVerifiedNameAttributeValue;
  school: SelfVerifiedNameAttributeValue;
  type?: Maybe<SelfVerifiedNameAttributeValue>;
  year: Scalars['Int']['output'];
};

export type SelfVerifiedNameTrainingConnection = {
  __typename?: 'SelfVerifiedNameTrainingConnection';
  /** A page of trainings */
  edges: Array<Maybe<SelfVerifiedNameTrainingEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of trainings */
  total: Scalars['Int']['output'];
};

export type SelfVerifiedNameTrainingEdge = {
  __typename?: 'SelfVerifiedNameTrainingEdge';
  cursor: Scalars['ID']['output'];
  /** A single training node */
  node?: Maybe<SelfVerifiedNameTraining>;
  /** 1-based position of the node in this context */
  position: Scalars['Int']['output'];
};

export type SelfVerifiedReference = {
  __typename?: 'SelfVerifiedReference';
  /** A contact value for this reference, can be a phone number, email address, etc. */
  contact?: Maybe<LocalizedString>;
  /** A unique identifier for this reference item. */
  id: Scalars['ID']['output'];
  /** The name of their reference. */
  name?: Maybe<LocalizedString>;
  /** Their relationship to this reference. */
  relationship?: Maybe<LocalizedString>;
};

export type SelfVerifiedReferenceConnection = {
  __typename?: 'SelfVerifiedReferenceConnection';
  edges: Array<Maybe<SelfVerifiedReferenceEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type SelfVerifiedReferenceEdge = {
  __typename?: 'SelfVerifiedReferenceEdge';
  cursor: Scalars['ID']['output'];
  node: SelfVerifiedReference;
  position: Scalars['Int']['output'];
};

export type SelfVerifiedResumeCustomSection = {
  __typename?: 'SelfVerifiedResumeCustomSection';
  body: SelfVerifiedNameAttributeValue;
  /** The unique ID of this custom section item */
  id: Scalars['ID']['output'];
  title: SelfVerifiedNameAttributeValue;
};

export type SelfVerifiedResumeCustomSectionConnection = {
  __typename?: 'SelfVerifiedResumeCustomSectionConnection';
  /** A page of customer sections */
  edges: Array<Maybe<SelfVerifiedResumeCustomSectionEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of resume custom sections */
  total: Scalars['Int']['output'];
};

export type SelfVerifiedResumeCustomSectionEdge = {
  __typename?: 'SelfVerifiedResumeCustomSectionEdge';
  cursor: Scalars['ID']['output'];
  /** A single custom section node */
  node: SelfVerifiedResumeCustomSection;
  /** 1-based position of this node in this context */
  position: Scalars['Int']['output'];
};

export type SelfVerifiedTraining = {
  __typename?: 'SelfVerifiedTraining';
  /** Additional details about the training. */
  details?: Maybe<LocalizedString>;
  /** A unique identifier for this resume training item. */
  id: Scalars['ID']['output'];
  /** The name of the person who instructed them. */
  instructor?: Maybe<LocalizedString>;
  /** The location of the school. */
  location?: Maybe<LocalizedString>;
  /** The name of the school or place where they received training. */
  school?: Maybe<LocalizedString>;
  /** The type of training they received. */
  training?: Maybe<LocalizedString>;
  /** The year in which they completed the training. */
  year?: Maybe<Scalars['Int']['output']>;
};

export type SelfVerifiedTrainingConnection = {
  __typename?: 'SelfVerifiedTrainingConnection';
  edges: Array<Maybe<SelfVerifiedTrainingEdge>>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};

export type SelfVerifiedTrainingEdge = {
  __typename?: 'SelfVerifiedTrainingEdge';
  cursor: Scalars['ID']['output'];
  node: SelfVerifiedTraining;
  position: Scalars['Int']['output'];
};

export type Series = {
  __typename?: 'Series';
  displayableEpisodeNumber: DisplayableEpisodeNumber;
  /** The next episode of this series, if there is one */
  nextEpisode?: Maybe<Title>;
  /** The previous episode of this series, if there is one */
  previousEpisode?: Maybe<Title>;
  series: Title;
};

export type SeriesCreditAttribute = CreditAttribute & {
  __typename?: 'SeriesCreditAttribute';
  /** An opaque unique identifier for the displayable SeriesCreditAttribute. */
  id: Scalars['ID']['output'];
  language: DisplayableLanguage;
  text: Scalars['String']['output'];
  /** The total number of episodes this attribute appears on */
  total: Scalars['Int']['output'];
};

/**
 * The severity level of a particular title, together with the number of users
 * who voted for this level of severity.
 */
export type SeverityLevel = {
  __typename?: 'SeverityLevel';
  /** Severity ID */
  id: Scalars['ID']['output'];
  /** The language the text is written in */
  language: DisplayableLanguage;
  /** Severity text, e.g. 'Mild', 'Moderate', 'Severe' */
  text: Scalars['String']['output'];
  /** The SeverityVote type used in voteForSeverityTitleParentGuide mutation */
  voteType: SeverityVote;
  /** The number of users who voted for this level of severity */
  votedFor: Scalars['Int']['output'];
};

export enum SeverityVote {
  Mild = 'MILD',
  Moderate = 'MODERATE',
  None = 'NONE',
  Severe = 'SEVERE'
}

/** Count for a CreditCategory, used to fiter the name connections data */
export type SharedCreditCategorySummary = {
  __typename?: 'SharedCreditCategorySummary';
  creditCategory: CreditCategory;
  /** Number of shared names connections for this Credit Category */
  total: Scalars['Int']['output'];
};

/** Page of Name that have a 2 degree connection with the input and parent names */
export type SharedNameEdge = {
  __typename?: 'SharedNameEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A shared name Item with related info */
  node: SharedNameItem;
  /** Position of the node in this context, eg: SharedTitleEdge 2 out of 10 */
  position: Scalars['Int']['output'];
};

/** A shared name item containing all the data related to mutual nmconst */
export type SharedNameItem = {
  __typename?: 'SharedNameItem';
  /** The name of the mutual nmconst */
  mutualName: Name;
  /**
   * Bounded list of titles shared between the input and mutual nmconsts.
   * The default number of titles returned is 2.
   * The titles are returned in the default order (ie. matching tango).
   */
  sharedTitlesWithNameInput: Array<Maybe<SharedTitle>>;
  /**
   * Bounded list of titles shared between the parent and mutual nmconsts.
   * The default number of titles returned is 2.
   * The titles are returned in the default order (ie. matching tango).
   */
  sharedTitlesWithNamePage: Array<Maybe<SharedTitle>>;
  /** Total number of shared titles between the input and mutual nmconsts */
  totalSharedTitlesWithNameInput: Scalars['Int']['output'];
  /** Total number of shared titles between the parent and mutual nmconsts. */
  totalSharedTitlesWithNamePage: Scalars['Int']['output'];
};


/** A shared name item containing all the data related to mutual nmconst */
export type SharedNameItemSharedTitlesWithNameInputArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A shared name item containing all the data related to mutual nmconst */
export type SharedNameItemSharedTitlesWithNamePageArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type SharedNamesConnection = {
  __typename?: 'SharedNamesConnection';
  /** Pages of Names that have a 2 degree connection with the input and parent nmconsts */
  edges: Array<Maybe<SharedNameEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of shared names */
  total: Scalars['Int']['output'];
};

export type SharedNamesFilter = {
  /** Match the name connections with the credit categories of input-mutual and parent-mutual names */
  creditCategoryIds: Array<InputMaybe<Scalars['ID']['input']>>;
};

export type SharedNamesInput = {
  /**
   * NameId used to generate shared names with the parent nameId
   * If no nameId is provided, we will use the claimed nameId of the logged in user.
   *
   * Throws FORBIDDEN is no nameId is passed in with input AND user does not have an active name claim.
   */
  nameId?: InputMaybe<Scalars['ID']['input']>;
};

export type SharedNamesResult = {
  __typename?: 'SharedNamesResult';
  sharedCreditCategorySummary?: Maybe<Array<Maybe<SharedCreditCategorySummary>>>;
  /** A connection of shared names */
  sharedNames?: Maybe<SharedNamesConnection>;
  /** Null if customer has connections, otherwise contains messaging for customer. */
  statusMessage?: Maybe<LocalizedMarkdown>;
};

export type SharedNamesSummary = {
  __typename?: 'SharedNamesSummary';
  /** Whether or not the current user is in the same network as this name. */
  inNetwork: Scalars['Boolean']['output'];
  /**
   * Displayable text for the connections summary. Is null if there are no shared connections.
   *
   * ex. "In your network" or "7 shared connections
   */
  summaryText?: Maybe<LocalizedString>;
  /** The total number of shared connection the current user has with this name. */
  totalSharedConnections: Scalars['Int']['output'];
};

export type SharedTitle = {
  __typename?: 'SharedTitle';
  /**
   * The job categories the input name is credited with on this title.
   * Results are sorted with the acting credit always first, followed by the default crew credit sort order.
   */
  nameInputCreditedJobCategories: Array<Maybe<CreditCategory>>;
  /**
   * The job categories the name page is credited with on this title.
   * Results are sorted with the acting credit always first, followed by the default crew credit sort order.
   */
  namePageCreditedJobCategories: Array<Maybe<CreditCategory>>;
  /** The title that is shared between two name pages */
  title: Title;
};


export type SharedTitleNameInputCreditedJobCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type SharedTitleNamePageCreditedJobCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type SharedTitleEdge = {
  __typename?: 'SharedTitleEdge';
  /** Cursor ID of the shared title */
  cursor: Scalars['ID']['output'];
  /** A shared Title node */
  node: SharedTitle;
  /** Position of the node in this context, eg: SharedTitleEdge 2 out of 10 */
  position: Scalars['Int']['output'];
};

export type SharedTitlesConnection = {
  __typename?: 'SharedTitlesConnection';
  /** Pages of shared titles between the input and the parent name */
  edges: Array<Maybe<SharedTitleEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of shared titles */
  total: Scalars['Int']['output'];
};

export type SharedTitlesInput = {
  /**
   * NameId used to generate shared titles with the parent nameId.
   * If no nameId is provided, we will use the claimed nameId of the logged in user.
   *
   * Throws FORBIDDEN is no nameId is passed in with input AND user does not have an active name claim.
   */
  nameId?: InputMaybe<Scalars['ID']['input']>;
};

/** A single showtime for a title at a particular cinema. */
export type Showtime = {
  __typename?: 'Showtime';
  /** Unique identifier for this showtime. */
  id: Scalars['ID']['output'];
  /**
   * The primary ticketing information for this showtime.
   * A null `ticketing` value indicates that there is no ticketing information available.
   */
  primaryTicketing?: Maybe<ShowtimeTicketing>;
  /** Date and time of the screening. */
  screeningStart: ScreeningDateTime;
  /** The screening type of this showing (e.g., standard, 3D, IMAX). */
  screeningType: ShowtimeScreeningType;
};

/** The type of showtime screening with displayable text. */
export type ShowtimeScreeningType = {
  __typename?: 'ShowtimeScreeningType';
  /** Unique identifier for this showtime screening type. */
  id: Scalars['ID']['output'];
  /** Language of the showtime screening type display text. */
  language: DisplayableLanguage;
  /** Localized text indicating the showtime screening type. */
  text: Scalars['String']['output'];
};

/** Ticketing information for a showtime. */
export type ShowtimeTicketing = {
  __typename?: 'ShowtimeTicketing';
  /** URL for purchasing tickets for this showtime. */
  link: Scalars['URL']['output'];
};

/** List of showtimes for this screening type and title at this cinema. */
export type ShowtimesByScreeningType = {
  __typename?: 'ShowtimesByScreeningType';
  /** The screening type of the showtimes contained in this object (e.g., standard, 3D, IMAX). */
  screeningType: ShowtimeScreeningType;
  /**
   * List of showtimes for this screening type and title at this cinema.
   * Ordered by ascending date time of the showtime/screening.
   * If no limit is provided, all showtimes will be provided for this Title/Cinema and date range.
   */
  showtimes: Array<Maybe<Showtime>>;
};


/** List of showtimes for this screening type and title at this cinema. */
export type ShowtimesByScreeningTypeShowtimesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * The location of the client. A lat/long or postal code location must be given for the client input to be valid. If both
 * lat/long and postal code are provided we default to using lat/long.
 */
export type ShowtimesLocation = {
  latLong?: InputMaybe<LatLong>;
  postalCode?: InputMaybe<ShowtimesPostalCodeLocation>;
  /**
   * This can be null in some cases; see the calling field for more information.
   * Value must be greater than 0 and less then or equal to 100,000.
   */
  radiusInMeters?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * The location of the client by postal code. The country field is an ISO 3166-1 alpha-2 country code (ex. US or GB).
 * The postalCode field is alpha numeric (ex. 98109 or D-11179).
 * See Supported Countries:
 * https://help.imdb.com/article/imdb/discover-watch/showtimes-ticket-experience-faq/GVV88QD6CJ8FJ2EK#
 */
export type ShowtimesPostalCodeLocation = {
  country: Scalars['String']['input'];
  postalCode: Scalars['String']['input'];
};

export type ShowtimesTitleConnection = {
  __typename?: 'ShowtimesTitleConnection';
  edges: Array<Maybe<ShowtimesTitleEdge>>;
  pageInfo: PageInfo;
};

export type ShowtimesTitleEdge = {
  __typename?: 'ShowtimesTitleEdge';
  cursor: Scalars['ID']['output'];
  node: Title;
  position: Scalars['Int']['output'];
};

/** The cinemas to retrieve showtimes for. If no cinemas are provided no showtimes will be returned. */
export type ShowtimesTitlesCinemasMetadata = {
  /**
   * Include titles that are showing in at least one of the specified theaters.
   * There is no guaranteed sort order for results returned.
   * Throws `BAD_USER_INPUT` if more than 400 unique cinemas are provided.
   */
  anyCinemaIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Include titles that have showtimes for a given date range. */
  dateRange?: InputMaybe<ShowtimesTitlesDateRangeFilter>;
};

/**
 * Filter showtimes to those within the given date range.
 * It's strongly recommended to explicitly provide startTime to avoid timezone mismatches between server and client, but if `ShowtimesTitlesDateRangeFilter` is not provided, the startTime will default to server's 'now' and the endTime will default to `3000-01-01T00:00:00Z`.
 * If no endTime is provided, the endTime will default to `3000-01-01T00:00:00Z`.
 */
export type ShowtimesTitlesDateRangeFilter = {
  endTime?: InputMaybe<Scalars['DateTime']['input']>;
  startTime: Scalars['DateTime']['input'];
};

/**
 * Filter for constraining titles that have a showtime in a theater across a specific date/time range.
 * Both `start` and `end` DateTimes must be in ISO-8601 format (e.g. `2025-06-19T17:35:25Z`).
 */
export type ShowtimesTitlesDateTimeRangeFilter = {
  /**
   * The `end DateTime to filter to (inclusive).
   * Must be provided in ISO-8601 format (e.g. `2025-06-19T17:35:25Z`).
   * Defaults to `3000-01-01T00:00:00Z` if not provided.
   */
  end?: InputMaybe<Scalars['DateTime']['input']>;
  /**
   * The `start` DateTime to filter from (inclusive).
   * Must be provided in ISO-8601 format (e.g. `2025-06-19T17:35:25Z`).
   */
  start: Scalars['DateTime']['input'];
};

export type ShowtimesTitlesQueryMetadata = {
  dateRange?: InputMaybe<ShowtimesTitlesDateRangeFilter>;
  sortField: ShowtimesTitlesSortField;
  sortOrder: ShowtimesTitlesSortOrder;
  ticketingTypes?: InputMaybe<Array<InputMaybe<TicketingType>>>;
};

export enum ShowtimesTitlesSortField {
  ShowtimesCount = 'SHOWTIMES_COUNT'
}

export enum ShowtimesTitlesSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type SignInOption = {
  __typename?: 'SignInOption';
  /** Redirect URL for the sign in option */
  redirectURL: Scalars['URL']['output'];
  /** Type of authentication provider */
  type: AuthProviderType;
};

export type SignInOptionRedirectUrlInput = {
  /**
   * Optional additional web context for URL building including the client context (i.e. ubid token)
   * Required if associationHandle in input is an association handle used in AAP (Amazon account pool) creation/conversion
   *     i.e. 'imdb_amazon', 'imdb_pro_amazon', etc., otherwise throws GRAPHQL_VALIDATION_FAILED error
   */
  additionalWebAuthContext?: InputMaybe<AdditionalWebAuthContext>;
  /**
   * Association handle of the login context i.e. imdb_us
   * This will affect the single sign in option returned
   */
  associationHandle: Scalars['String']['input'];
  /** Optional URL to return to post sign in, defaults to home page if omitted */
  returnURL?: InputMaybe<Scalars['URL']['input']>;
  /** Optional prefilled email for use on Pro when signing in with an Amazon account email that matches an IMDb account email */
  signInPrefilledEmail?: InputMaybe<Scalars['String']['input']>;
};

export type SignInOptionRedirectUrlOutput = {
  __typename?: 'SignInOptionRedirectURLOutput';
  /** Option for a user to sign in through IMDb or a Third Party Provider based on association handle provided in input */
  signInOption: SignInOption;
};

export type SignInOptionsRedirectUrLsInput = {
  /**
   * Additional web context for URL building including the client context (i.e. ubid token)
   * Required for building cross domain Amazon login redirect URL
   */
  additionalWebAuthContext: AdditionalWebAuthContext;
  /**
   * Optional flag to tell if you need Amazon login url with email gating.
   * Default returning login url without email gating if not provided
   * This will only affect sign-in with Amazon since Amazon account can be registered with mobile only.
   * This is used for clients who requires customer to have email with their account (For example: Help site)
   */
  amazonAccountEmailGating?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Association handle of the login context i.e. imdb_us
   * This will only affect the 1P IMDb sign in option, all of the other 3P logins will be configured with their own association handles
   */
  associationHandle: Scalars['String']['input'];
  /** Optional URL to return to post sign in, defaults to home page if omitted */
  returnURL?: InputMaybe<Scalars['URL']['input']>;
};

export type SignInOptionsRedirectUrLsOutput = {
  __typename?: 'SignInOptionsRedirectURLsOutput';
  /** Options for a user to sign in through IMDb or a Third Party Provider */
  signInOptions: Array<Maybe<SignInOption>>;
};

/** Constrain the search results based on a user's ratings. */
export type SingleUserRatingSearchConstraint = {
  /**
   * Select whether constraint should restrict-to or exclude titles that the customer has rated.
   * Example: undefined if we sort titles by SINGLE_USER_RATING/SINGLE_USER_RATING_DATE without filtering.
   * Example: INCLUDE if we restrict to only titles within rating range and sort
   * titles by SINGLE_USER_RATING/SINGLE_USER_RATING_DATE.
   */
  filterType?: InputMaybe<SingleUserRatingSearchFilterType>;
  /**
   * Match titles based on rating given by the requesting user.
   * Infers "min: 1", or "max: 10" if one of those is not provided.
   * Example: To restrict to only titles the customer rated between 5-10, use {min: 5}
   *
   * Example: To restrict to only titles the customer has rated use {min: 1, max: 5}
   */
  ratingRange?: InputMaybe<IntRangeInput>;
  /**
   * The user id we are filtering/sorting ratings for.
   *
   * If the provided user is invalid or the requested
   * user's ratings are private and not the requesting user, an error will be returned
   * identifying which case occurred.
   * - Throws BAD_USER_INPUT if user ID is invalid
   * - Throws FORBIDDEN if user is not authorized to retrieve ratings
   */
  userId: Scalars['ID']['input'];
};

export enum SingleUserRatingSearchFilterType {
  Exclude = 'EXCLUDE',
  Include = 'INCLUDE'
}

/**
 * Entry in the slots size map.
 * This type serves as an input descriptor of an ad slot, while CreativeSize denotes the size of the returned ad.
 * These are not the same for certain types of ad.
 */
export type SlotSize = {
  /** The height of the slot in pixels */
  height: Scalars['Int']['input'];
  /** The name of the slot */
  name: Scalars['String']['input'];
  /** The width of the slot in pixels */
  width: Scalars['Int']['input'];
};

/** The order in which listed elements should be sorted */
export enum SortOrder {
  /** Ascending order e.g. 1, 2, 3 */
  Asc = 'ASC',
  /** Descending order e.g. 3, 2, 1 */
  Desc = 'DESC'
}

export enum SortSearchOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** A sound mix, along with any attributes. For example, we could have a DTS sound that used an RCA sound system. */
export type SoundMix = {
  __typename?: 'SoundMix';
  attributes: Array<Maybe<DisplayableAttribute>>;
  /** Sound mix as displayable property */
  displayableProperty: DisplayableTechnicalSpecificationProperty;
  /** An ID for this sound mix, suitable for use in URLs */
  id: Scalars['ID']['output'];
  /** The display text for this sound mix */
  text: Scalars['String']['output'];
};

/**
 * Example: if you want to match titles of sound mix 'Silent' OR 'Dolby' AND NOT 'Mono',
 * specify anySoundMixTypes: ['silent','dolby'] and excludeSoundMixTypes: ['mono']
 */
export type SoundMixSearchConstraint = {
  /** Match titles that have the specific sound mix */
  anySoundMixTypes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Match titles that do not have the specific sound mix
   *
   * If the same input is specified in the any and exclude constraints,
   * then the results should be empty.
   */
  excludeSoundMixTypes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Sound mixes for this title. */
export type SoundMixes = {
  __typename?: 'SoundMixes';
  /** The list of sound mix items */
  items: Array<Maybe<SoundMix>>;
  restriction?: Maybe<TechnicalSpecificationsRestriction>;
  /** Total number of sound mix items */
  total: Scalars['Int']['output'];
};

/** Pagination for soundtrack items which always has a known total number of edges. */
export type SoundtrackConnection = {
  __typename?: 'SoundtrackConnection';
  /** Pages of tracks */
  edges: Array<Maybe<SoundtrackEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  restriction?: Maybe<SoundtrackRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Tracks */
export type SoundtrackEdge = {
  __typename?: 'SoundtrackEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Track node */
  node: Track;
  /** Position of the Track in this context, eg: Track 6 out of 11 */
  position: Scalars['Int']['output'];
};

/**
 * Example: if you want to match titles of soundtrack 'Dissolved Girl' OR 'String Quartet', PLUS
 * the title must contain 'Dead Fingers Talking', specify anyAlternateTextTerms: ['Dissolved Girl',
 *  'String Quartet'] plus allSoundtrackTextTerms: ['Dead Fomgers Talking'].
 */
export type SoundtrackMatchingSearchConstraint = {
  /** A title match must contain ALL of these search terms in at least one of its tracks. */
  allSoundtrackTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these search terms in at least one of its tracks. */
  anySoundtrackTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Restriction information applied to Soundtracks */
export type SoundtrackRestriction = {
  __typename?: 'SoundtrackRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

/** Image source details, including attribution requirements. */
export type Source = {
  __typename?: 'Source';
  /** Link provided by the image source, if required by the license */
  attributionUrl?: Maybe<Scalars['String']['output']>;
  /** Attribution banner image, if required by the license */
  banner?: Maybe<Banner>;
  /** The image source ID */
  id: Scalars['ID']['output'];
  /** Displayable text for the image source, if required by the license */
  text?: Maybe<Scalars['String']['output']>;
};

export type SpokenLanguage = {
  __typename?: 'SpokenLanguage';
  /** Spoken language as displayable property. */
  displayableProperty: DisplayableTitleSpokenLanguageProperty;
  /** The language code - either an ISO 639 code or an internally defined code if no ISO code exists for the language. */
  id: Scalars['ID']['output'];
  /** The language of the display text. */
  language: DisplayableLanguage;
  /** Display text for the language (e.g. 'English'). */
  text: Scalars['String']['output'];
};

export type SpokenLanguages = {
  __typename?: 'SpokenLanguages';
  /** DEPRECATED - DO NOT USE */
  language: DisplayableLanguage;
  spokenLanguages: Array<Maybe<SpokenLanguage>>;
};


export type SpokenLanguagesSpokenLanguagesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type SpouseAttributes = {
  __typename?: 'SpouseAttributes';
  /** The spouse attribute */
  id: Scalars['ID']['output'];
  /** The language of the localized text */
  language: DisplayableLanguage;
  /** The localized text */
  text: Scalars['String']['output'];
};

export type SpouseName = {
  __typename?: 'SpouseName';
  /** Display name text as plain text, or nmconst link if person is an IMDb name */
  asMarkdown: Markdown;
  /** Name association to the spouse if the spouse has an IMDb Name that is known */
  name?: Maybe<Name>;
};

/** StaffCategory: The most specific group / org this account belongs to */
export enum StaffCategory {
  ImDb = 'IMDb'
}

/** StaffStatus: contains related staff information */
export type StaffStatus = {
  __typename?: 'StaffStatus';
  category: StaffCategory;
};

export type StreamingTitle = {
  __typename?: 'StreamingTitle';
  refTag: Scalars['String']['output'];
  title: Title;
};

export type StreamingTitleConnection = {
  __typename?: 'StreamingTitleConnection';
  edges: Array<Maybe<StreamingTitleEdge>>;
  pageInfo: PageInfo;
};

export type StreamingTitleEdge = {
  __typename?: 'StreamingTitleEdge';
  cursor: Scalars['ID']['output'];
  node: StreamingTitle;
};

export type StreamingTitles = {
  __typename?: 'StreamingTitles';
  /**
   * The place where a customer can stream the given titles; for example, "primeVideo".
   *
   * Please note given the federated nature of this API there is a chance that this value may be null;
   * in those cases you should assume that the returned titles should not be displayed to customers.
   */
  provider?: Maybe<WatchProvider>;
  /**
   * Returns a paginated view of the titles that are currently streaming on the provider. Again, if the above
   * provider is requested and null, then these probably should not be shown to customers.
   */
  titles?: Maybe<StreamingTitleConnection>;
};


export type StreamingTitlesTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};

export type StreamingTitlesFilter = {
  /**
   * Includes streaming titles for below title type category values. At time of writing, streamingTitles() only
   * supports movie and tv title type categories.
   */
  includeTitleTypes?: InputMaybe<Array<InputMaybe<TitleTypeCategoryValue>>>;
  /** Limits the number of providers to get streaming titles for, by pruning the providers list based on size */
  maxProviders?: InputMaybe<Scalars['Int']['input']>;
  /** List of providers to get streaming titles for */
  providers?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type SuggestionSearchConnection = {
  __typename?: 'SuggestionSearchConnection';
  edges: Array<Maybe<SuggestionSearchEdge>>;
  pageInfo: PageInfo;
};

export type SuggestionSearchConstraints = {
  nameConstraints?: InputMaybe<SuggestionSearchNameConstraints>;
};

export type SuggestionSearchEdge = {
  __typename?: 'SuggestionSearchEdge';
  cursor: Scalars['ID']['output'];
  node: SuggestionSearchItem;
};

export type SuggestionSearchFilter = {
  constraints?: InputMaybe<SuggestionSearchConstraints>;
  type?: InputMaybe<Array<InputMaybe<SuggestionSearchType>>>;
};

export type SuggestionSearchItem = {
  __typename?: 'SuggestionSearchItem';
  constId?: Maybe<Scalars['ID']['output']>;
  displayLabels?: Maybe<DisplayLabels>;
  id: Scalars['ID']['output'];
  image?: Maybe<MediaServiceImage>;
  rank?: Maybe<Scalars['Int']['output']>;
  /**
   * Partial ref tag suffix for overrides.
   * Ex: 'gnr_act' could be used to represent the Action genre override,
   * which would then be used to generate a full ref tag such as 'andp_srch_sg_gnr_act'.
   */
  refTagFragment?: Maybe<Scalars['String']['output']>;
  releaseYear?: Maybe<YearRange>;
  titleTypeId?: Maybe<Scalars['String']['output']>;
  topVideos?: Maybe<Array<Maybe<VideoMedia>>>;
  /** Url path of the IMDb destination page */
  url?: Maybe<Scalars['String']['output']>;
  videoCount?: Maybe<Scalars['Int']['output']>;
};

export enum SuggestionSearchMethodType {
  /** search index */
  InstantIndexV1 = 'INSTANT_INDEX_V1',
  /** Weighted week + day ranking on the */
  Instant = 'instant'
}

export type SuggestionSearchNameConstraints = {
  professions?: InputMaybe<Array<InputMaybe<SuggestionSearchNameProfession>>>;
};

export enum SuggestionSearchNameProfession {
  TalentAgent = 'TALENT_AGENT'
}

export type SuggestionSearchOptions = {
  /** Controls for different search algorithms. Defaults to basic consumer suggestion search. */
  searchType: SuggestionSearchMethodType;
};

export enum SuggestionSearchType {
  Company = 'COMPANY',
  Interest = 'INTEREST',
  Name = 'NAME',
  Title = 'TITLE'
}

export type SymphonyArgument = {
  __typename?: 'SymphonyArgument';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type SymphonyMetadata = {
  __typename?: 'SymphonyMetadata';
  contentId?: Maybe<Scalars['ID']['output']>;
  creativeId?: Maybe<Scalars['ID']['output']>;
  /** The name of the multi-slot optimization group name. Null if it is not part of an MSO group */
  multiSlotGroupName?: Maybe<Scalars['String']['output']>;
  /** The order of the slot in it's multi-slot group. Null if it is not part of an MSO group */
  multiSlotOrder?: Maybe<Scalars['Int']['output']>;
  placementId?: Maybe<Scalars['ID']['output']>;
};

export type SymphonyMultiValueMapEntry = {
  key: Scalars['String']['input'];
  value: Array<InputMaybe<Scalars['String']['input']>>;
};

export type SymphonyPlacement = {
  __typename?: 'SymphonyPlacement';
  /** The key-value pair arguments defined in the symphony component/creative */
  componentArguments: Array<Maybe<SymphonyArgument>>;
  /** The metadata of the Symphony placement. */
  componentMetadata?: Maybe<SymphonyMetadata>;
  /** The name of the widget */
  componentName: Scalars['String']['output'];
  /**
   * The name of the slot
   * eg. "center-1
   */
  slot: Scalars['String']['output'];
};

/** Tagline details */
export type Tagline = {
  __typename?: 'Tagline';
  /** The tagline displayable property */
  displayableProperty: DisplayableTitleTaglineProperty;
  /** The tagline text */
  text: Scalars['String']['output'];
};

/** Pagination for tagline types which always has a known total number of edges. */
export type TaglineConnection = {
  __typename?: 'TaglineConnection';
  /** Pages of taglines */
  edges: Array<Maybe<TaglineEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of taglines */
export type TaglineEdge = {
  __typename?: 'TaglineEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Tagline node */
  node: Tagline;
  /** Position of the node in this context, eg: Tagline 4 out of 46 */
  position: Scalars['Int']['output'];
};

/** A set of technical specifications */
export type TechnicalSpecifications = {
  __typename?: 'TechnicalSpecifications';
  aspectRatios: AspectRatios;
  cameras: Cameras;
  colorations: Colorations;
  filmLengths: FilmLengths;
  laboratories: Laboratories;
  negativeFormats: NegativeFormats;
  printedFormats: PrintedFormats;
  processes: Processes;
  soundMixes: SoundMixes;
};

/** Allows filtering of technical specifications based on different versions of a title. */
export type TechnicalSpecificationsFilter = {
  versions?: InputMaybe<FilterVersions>;
};

/** Information about restrictions applied to technicalSpecifications */
export type TechnicalSpecificationsRestriction = {
  __typename?: 'TechnicalSpecificationsRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

export type Test = {
  __typename?: 'Test';
  error?: Maybe<Scalars['String']['output']>;
  /** @experimental experimental field */
  experimental?: Maybe<Scalars['String']['output']>;
  result?: Maybe<Scalars['String']['output']>;
  testItems?: Maybe<Array<Maybe<TestItem>>>;
};


export type TestTestItemsArgs = {
  cachebuster?: InputMaybe<Scalars['String']['input']>;
  limit: Scalars['Int']['input'];
};

export type TestAuth = {
  __typename?: 'TestAuth';
  cacheableResult?: Maybe<Scalars['String']['output']>;
  cacheableResultWithNoCacheCustomerId?: Maybe<Scalars['String']['output']>;
  cacheableResultWithNoCacheUserId?: Maybe<Scalars['String']['output']>;
  clientIp?: Maybe<Scalars['String']['output']>;
  detectedCountry?: Maybe<Scalars['String']['output']>;
  hasAuthenticationHeaders?: Maybe<Scalars['Boolean']['output']>;
  hasGatewayName?: Maybe<Scalars['Boolean']['output']>;
  hasTransitiveAuthenticationHeaders?: Maybe<Scalars['Boolean']['output']>;
  isInternalClient?: Maybe<Scalars['Boolean']['output']>;
  isNon1PInternalClient?: Maybe<Scalars['Boolean']['output']>;
  nonCacheableResult?: Maybe<Scalars['String']['output']>;
  operationName?: Maybe<Scalars['String']['output']>;
  result?: Maybe<Scalars['String']['output']>;
};

export type TestAuthTimer = {
  __typename?: 'TestAuthTimer';
  authTimer?: Maybe<Scalars['String']['output']>;
};

export type TestEntitlement = {
  __typename?: 'TestEntitlement';
  entitlement: Scalars['String']['output'];
  result: Scalars['String']['output'];
};

export type TestItem = {
  __typename?: 'TestItem';
  id: Scalars['ID']['output'];
};

/**
 * Defines a standard shape for vending form constraints for a text area input.
 * Currently the same as text constraints but in future may include text-area
 * specific constraints such as maximum lines or rows.
 */
export type TextAreaFieldConstraints = {
  __typename?: 'TextAreaFieldConstraints';
  /** Specifies if the customer must provide a non-empty (ie not null or empty string) value */
  isRequired?: Maybe<BooleanValidationConstraint>;
  /** Specifies the maximum allowed number of characters for this text area input */
  maximumCharacterLength?: Maybe<IntThresholdValidationConstraint>;
  /** Specifies the minimum allowed number of characters for this text area input */
  minimumCharacterLength?: Maybe<IntThresholdValidationConstraint>;
};

/** Defines a standard shape for vending form constraints for a text input. */
export type TextFieldConstraints = {
  __typename?: 'TextFieldConstraints';
  /** Specifies if the customer must provide a non-empty (ie not null or empty string) value */
  isRequired?: Maybe<BooleanValidationConstraint>;
  /** Specifies the maximum allowed number of characters for this text input */
  maximumCharacterLength?: Maybe<IntThresholdValidationConstraint>;
  /** Specifies the minimum allowed number of characters for this text input */
  minimumCharacterLength?: Maybe<IntThresholdValidationConstraint>;
};

export type ThirdPartyTrackers = {
  __typename?: 'ThirdPartyTrackers';
  /** Third Party trackers to fire when the ad is displayed */
  impressionTrackers: Array<Maybe<Scalars['URL']['output']>>;
  /** Third Party trackers to fire when the title poster image is clicked */
  titlePosterClickTrackers: Array<Maybe<Scalars['URL']['output']>>;
  /** Third Party trackers to fire when the video completes */
  videoCompleteTrackers: Array<Maybe<Scalars['URL']['output']>>;
  /** Third Party trackers to fire when the video reaches the first quartile */
  videoFirstQuartileTrackers: Array<Maybe<Scalars['URL']['output']>>;
  /** Third Party trackers to fire when the video reaches the midpoint */
  videoMidpointTrackers: Array<Maybe<Scalars['URL']['output']>>;
  /** Third Party trackers to fire when the video starts */
  videoStartTrackers: Array<Maybe<Scalars['URL']['output']>>;
  /** Third Party trackers to fire when the video reaches the third quartile */
  videoThirdQuartileTrackers: Array<Maybe<Scalars['URL']['output']>>;
};

export type Thumbnail = {
  __typename?: 'Thumbnail';
  height: Scalars['Int']['output'];
  url: Scalars['String']['output'];
  width: Scalars['Int']['output'];
};

export enum TicketingType {
  Online = 'ONLINE'
}

/** Enums */
export enum TimeUnit {
  Seconds = 'SECONDS'
}

/**
 * Title type
 * Extends external type.
 */
export type Title = {
  __typename?: 'Title';
  /**
   * Aggregate Ratings Breakdown for the title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  aggregateRatingsBreakdown?: Maybe<AggregateRatingsBreakdown>;
  /**
   * Other title texts by which this Title is known
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  akas?: Maybe<AkaConnection>;
  /**
   * Alexa top questions.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ziggy
   * - CTI: IMDb/GraphQL/Ziggy
   * - Affected by headers: x-imdb-user-language
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-ziggy
   */
  alexaTopQuestions?: Maybe<AlexaQuestionConnection>;
  /**
   * Alternate versions for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  alternateVersions?: Maybe<AlternateVersionConnection>;
  /**
   * Album products of Amazon Music related to this title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  amazonMusicAlbums?: Maybe<Array<Maybe<AmazonMusicProduct>>>;
  /**
   * The awards that the title has won or been nominated for
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  awardNominations?: Maybe<AwardNominationConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  canRate?: Maybe<CanRate>;
  /**
   * A full URL to see the title on www.imdb.com
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  canonicalUrl?: Maybe<Scalars['String']['output']>;
  /**
   * The localized certificate for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  certificate?: Maybe<Certificate>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  certificates?: Maybe<CertificatesConnection>;
  /**
   * For a given Title, returns the Title's showtimes grouped by cinema and screening type.
   *
   * Notes:
   * - Only cinemas with showtimes for the requested title will be returned.
   * - If both lat/long and postal code are provided to `filter.location`, the location will default to using lat/long.
   * - It's strongly recommended to explicitly provide startTime to avoid timezone mismatches between server and client, but if `filter.dateRange` is not provided, the startTime will default to the server's 'now' and the endTime will default to `3000-01-01T00:00:00Z`.
   * - If `filter.dateRange.endTime` is not provided, the endTime will default to `3000-01-01T00:00:00Z`.
   * - Backwards pagination is not currently supported.
   * - If `fallback` is not provided, there will be no fallback logic applied to the response.
   * - If `fallback` has `NEXT_AVAILABLE_DATE`  as it's value and the original result contains no data, the graphlet will attempt to fallback the results to the showtimes for the next available date from the provided `filter.dateRange.startTime` input value. If fallback results are found, the `fallback` results field will be non-null and provide information about the fallback result set.
   *
   * Sorting:
   * - If `filter.location` provided, sorting will be in ascending distance from the provided location.
   * - If `filter.anyCinemaIds` provided, the sort order will not be guaranteed. Currently, there is no requirement to support any sort for the resulting cinemaShowtimes, since the only use case we have is for a singular cinema, which will only return a single node.
   *
   * Errors:
   * - Throws `BAD_USER_INPUT` with symbol `filter.location.postalCode` if the location is unknown.
   * - Throws `BAD_USER_INPUT` if lat/long is too precise. See `LatLong` input.
   * - Throws `BAD_USER_INPUT` if `filter.location.radiusInMeters` is null.
   * - Throws `BAD_USER_INPUT` if both or neither `filter.anyCinemaIds` and `filter.location` are provided. Exactly one must be provided.
   * - Throws `BAD_USER_INPUT` if both `filter.anyCinemaIds` and `fallback` are provided.
   * - Throws `BAD_USER_INPUT` if more than 400 unique cinemas are provided in `filter.anyCinemaIds`.
   *
   * Limits:
   * - `first` is limited to a maximum of 100. If the `first` argument exceeds the maximum, the results will be capped to the maximum.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: titleAppointments
   * - CTI: IMDb/GraphQL/Title Appointments
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  cinemaShowtimesByScreeningType?: Maybe<TitleCinemaShowtimesByScreeningTypeConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  companyCreditCategories?: Maybe<Array<Maybe<CompanyCreditCategoryWithCompanyCredits>>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  companyCredits?: Maybe<CompanyCreditConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  connectionCategories?: Maybe<Array<Maybe<ConnectionCategoryWithConnections>>>;
  /**
   * The connections for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  connections?: Maybe<TitleConnectionConnection>;
  /**
   * A list of the countries of origin for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  countriesOfOrigin?: Maybe<CountriesOfOrigin>;
  /**
   * Crazy credits for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  crazyCredits?: Maybe<CrazyCreditConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  creditCategories?: Maybe<Array<Maybe<TitleCreditCategoryWithCredits>>>;
  /**
   * Vends name credits for this title, grouped into "Groupings" in a way that best represents a title's end credits.
   * Actor and Actress credits are grouped together in a 'Cast' grouping.
   * Archive Footage and similar roles where the person was not directly involved, are kept within this 'Cast' grouping
   * (which differs to how name.creditGroupings vends credits).
   * All other credit categories are presented 1-1 as groupings.
   *
   * Groupings are presented in a fixed order, presenting groupings in an order similar to that seen
   * on movie or TV end credits. This field is suitable for building experiences that highlight work on a title separately
   * across disciplines, such as displaying all credits for a title.
   *
   * When a name has credits on individual episodes in a series, these are rolled up and presented at the series level
   * as a single CreditV2 value, giving a summary of their contribution. Details of individual episodes are available
   * from "episodeCredits" on a CreditedRole within a CreditV2 value, or on the CreditV2 value.
   *
   * When a credit has performed many roles on a title, these are aggregated into a single CreditV2 value, with each
   * individual role represented as a separate CreditedRole within the CreditV2.
   * This makes this field useful for building experiences where you want to show each name for a title only once.
   * For example, credits for The Office (2005-2013) (tt0386676) would include Mindy Kaling (nm1411676) once per grouping.
   * All of their roles as producer (co-executive producer, producer, and so on) are vended as a single CreditV2 value,
   * and separate values are given for their roles as actress, writer and director.
   * Note that the aggregateBy parameter can be used to disable aggregation for specific groupings.
   *
   * Credits on in-development titles are only available to clients providing a Pro tier entitlement.
   *
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  creditGroupings?: Maybe<CreditGroupingConnection>;
  /**
   * The entire list of cast & crew members
   *
   * Default sort is done by billing order
   * If there is no billing order it is done alphabetically
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  credits?: Maybe<CreditConnection>;
  /**
   * Vends name credits for this title.
   *
   * When a name has credits on individual episodes in a series, these are rolled up and presented at the series level
   * as a single CreditV2 value, giving a summary of their contribution. Details of individual episodes are available
   * from "episodeCredits" on a CreditedRole within a CreditV2 value.
   *
   * When a credit has performed many roles on a title, these are aggregated into a single CreditV2 value, with each
   * individual role represented as a separate CreditedRole within the CreditV2.
   * For example, credits for The Office (2005-2013) (tt0386676) would include Mindy Kaling (nm1411676) once,
   * listing all of their roles as producer (co-executive producer, producer, and so on), actress, writer and director
   * as a single CreditV2.
   * This makes this field useful for building experiences where you want to show each name for a title only once.
   * Note that the aggregateBy parameter can be used to disable aggregation for specific groupings.
   *
   * Related field title.creditGroupings allows fetching credits for a title, grouped in a way that best represents
   * a title's end credits. When a single grouping contains large numbers of credits, additional pages of those credits
   * can be fetched using this field (and providing `filter.creditLevelFilter.groupings` to restrict to the grouping
   * being paginated).
   *
   * Credits on in-development titles are only available to clients providing a Pro tier entitlement.
   *
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  creditsV2?: Maybe<CreditV2Connection>;
  /**
   * Return Engagement Statistics for a title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: engagementData
   * - CTI: IMDb/GraphQL/Engagement Data
   * - Affected by headers: x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-core-tech
   */
  engagementStatistics?: Maybe<EngagementStatistics>;
  /**
   * Credits for episodes of this title by a single name. For access to more broad credit data, see
   * title.creditsV2 and title.creditGroupings fields.
   *
   * Each episode title is represented by a single CreditV2 value. When a name has performed multiple roles on the title,
   * these are represented as separate CreditedRoles within one CreditV2 value.
   *
   * Credits on in-development titles are only available to clients providing a Pro tier entitlement.
   *
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  episodeCredits?: Maybe<EpisodeCreditConnection>;
  /**
   * For titles which are a series, provides information about the episodes of that series
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  episodes?: Maybe<Episodes>;
  /**
   * Experimental Field: DO NOT USE. The entire list of credits for the title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  experimental_credits?: Maybe<ExperimentalCreditConnection>;
  /**
   * The requesting user's notification preferences for this title.
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  experimental_trackNotificationPreferences?: Maybe<Experimental_TrackNotificationPreferences>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  externalLinkCategories?: Maybe<Array<Maybe<ExternalLinkCategoryWithExternalLinks>>>;
  /**
   * External links for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  externalLinks?: Maybe<ExternalLinkConnection>;
  /**
   * Frequently asked questions (FAQs) for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  faqs?: Maybe<FaqConnection>;
  /**
   * Featured polls for the title.
   * Capped at <LIMIT> polls. No pagination
   *
   * ---------------------
   * Graphlet Details:
   * - Name: polls
   * - CTI: IMDb/GraphQL/Polls
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  featuredPolls?: Maybe<PollsConnection>;
  /**
   * Featured reviews for the title.
   * Capped at 5 reviews. No pagination
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  featuredReviews?: Maybe<ReviewsConnection>;
  /**
   * All FilmingDates for the title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  filmingDates?: Maybe<FilmingDatesConnection>;
  /**
   * Title filming locations
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  filmingLocations?: Maybe<FilmingLocationConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  goofCategories?: Maybe<Array<Maybe<GoofCategoryWithGoofs>>>;
  /**
   * Goofs for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  goofs?: Maybe<GoofConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  id: Scalars['ID']['output'];
  /**
   * Images related to the title, grouped by image types
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  imageTypes?: Maybe<Array<Maybe<ImageTypeWithImages>>>;
  /**
   * Returns the 'upload url' Link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  imageUploadLink?: Maybe<ContributionLink>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  images?: Maybe<ImageConnection>;
  /**
   * Paginated list of interests directly tagged to this title. Sorted alphabetically. Supports page size of at most 250.
   * Requesting a page size larger than the maximum supported will result in the maximum size being returned.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  interests?: Maybe<InterestConnection>;
  /**
   * A boolean flag that indicates whether IMDb considers this title to be primarily pornographic or adult genre.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  isAdult?: Maybe<Scalars['Boolean']['output']>;
  /**
   * if the writer credits have been verified for this title. WGA is the Writers
   * Guild of America they ensure that writers are credited correctly for a given title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  isWGAVerified?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Title keywords grouped by item scope category
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  keywordItemCategories?: Maybe<Array<Maybe<TitleKeywordItemCategoryWithKeywords>>>;
  /**
   * Title keywords.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  keywords?: Maybe<TitleKeywordConnection>;
  /**
   * The latest trailer for a title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  latestTrailer?: Maybe<Video>;
  /**
   * The latest trailer (player not video) for a title.
   * It's different from 'latestTrailer'. This one is used for querying a title's
   * latest trailer's webviewUrl by filter.
   *
   * Optionally, country, preferredAudioLanguage and maturityLevel can be provided in filter to be used to
   * search for the videos of specific region and with specific language, and filter out
   * videos with mature content. If none are provided, we will set them according to the description
   * in LatestTrailerFilter.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  latestTrailerWebviewPlayer?: Maybe<WebviewVideoPlayer>;
  /**
   * Liftime gross for this title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: mojo
   * - CTI: IMDb/GraphQL/Mojo
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  lifetimeGross?: Maybe<BoxOfficeGross>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  meta?: Maybe<TitleMeta>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: metacritic
   * - CTI: IMDb/GraphQL/Metacritic
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 10800 seconds
   * - Slack Channel: #imdb-community-and-video
   */
  metacritic?: Maybe<Metacritic>;
  /**
   * Returns either the MovieMeter or TVMeter value depending on the title type.
   * Ranking information beyond 5000 requires entitlement proving Pro subscription.
   * Use TITLE_METER in input to get a ranking across both TV Show and movies.
   * Use useEntitlement = false to access non entitled version.
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ranking
   * - CTI: IMDb/GraphQL/ProRanking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  meterRank?: Maybe<TitleMeterRanking>;
  /**
   * History of IMDbPro Title meter rankings of a title.
   * Requires entitlement proving Pro subscription.
   * @entitlement(PRO_PREMIUM)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ranking
   * - CTI: IMDb/GraphQL/ProRanking
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  meterRankingHistory?: Maybe<TitleMeterRankingHistory>;
  /**
   * Similar titles to this title. Clients may request a max of 100 similar titles. Number of titles returned may be fewer.
   *
   * Pagination not supported:
   * Pagination may produce duplicate title results as the ML model is not deterministic and ranking is affected
   * by customer behavioral data. Clients are advised to retrieve titles using a single request for now.
   *
   * For the 'after' parameter, please use 'PageInfo.endCursor' instead of 'MoreLikeThisEdge.cursor'.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  moreLikeThisTitles?: Maybe<MoreLikeThisConnection>;
  /**
   * News articles about a title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: bugle
   * - CTI: IMDb/GraphQL/Bugle
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  news?: Maybe<NewsConnection>;
  /**
   * The nominations that the title has won or been nominated for
   * Default sort is done by sorting nomination id in ascending order
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  nominations?: Maybe<NominationConnection>;
  /**
   * Opening weekend gross for this title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: mojo
   * - CTI: IMDb/GraphQL/Mojo
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  openingWeekendGross?: Maybe<OpeningWeekendGross>;
  /**
   * Opening weekend grosses for this title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: mojo
   * - CTI: IMDb/GraphQL/Mojo
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  openingWeekendGrosses?: Maybe<OpeningWeekendBoxOfficeGrossConnection>;
  /**
   * The original text for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  originalTitleText?: Maybe<TitleText>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  parentsGuide?: Maybe<ParentsGuide>;
  /**
   * Returns the parental guide contribution link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  parentsGuideContributionLink?: Maybe<ContributionLink>;
  /**
   * The plot for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  plot?: Maybe<Plot>;
  /**
   * Returns the plot contribution link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  plotContributionLink?: Maybe<ContributionLink>;
  /**
   * The plots for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  plots?: Maybe<PlotConnection>;
  /**
   * The most prestigious awards that the title has won or been nominated for
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  prestigiousAwardSummary?: Maybe<PrestigiousAwardSummary>;
  /**
   * The primary image for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  primaryImage?: Maybe<Image>;
  /**
   * An ordered list of the primary videos related to a title.
   * If the first argument exceeds 100, the results will be capped to 100.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  primaryVideos?: Maybe<VideoConnection>;
  /**
   * Primary watch option determined by ordering the providers based on an order defined by business.
   *
   * If the location is included, returns any location-specific watch options (will be required in the future)
   * Promoted provider feature is no longer supported by the Ads team - https://sim.amazon.com/issues/W2W-170. Passing value onto the optional parameter will not have any effect.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  primaryWatchOption?: Maybe<PrimaryWatchOption>;
  /**
   * Array of most important credit categories and credits in that category
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  principalCredits?: Maybe<Array<Maybe<PrincipalCreditsForCategory>>>;
  /**
   * Principal Credits gives the primary creative contributors to a title, organized by groupings.
   *
   * We group credits in a way that highlights the primary creative roles on a title.
   * Showrunner, Creator and Head Writer roles are moved out of their original categories
   * (typically 'Producer' and 'Writer') and presented in a separate grouping per role type.
   * For all other credits, the grouping strategy on title.creditGroupings is followed.
   * Note that we label the 'Cast' grouping as 'Stars'.
   * Also when the TOP_CAST mode is used (see filter parameter), we vend a "Top X" or "Key X" text per grouping,
   * replacing the standard text.
   *
   * The number of credits per grouping we vend is limited to 30, to reflect that most use cases
   * looking for a summary of principal credits want a limited subset of data.
   * For fuller data see title.creditGroupings.
   *
   * Clients can control the maximum number of groupings returned using the `filter` input.
   * The specific groupings returned will depend on the title type
   * (for example giving Showrunner for TV series but not for movies, and Director for movies but not for TV series).
   *
   * Note that the returned groupings may change over time, as our set of supported credit categories evolves.
   *
   * Principal credits for in-development titles only available when a Pro entitlement is provided.
   * Without this, we only provide access to a count per grouping.
   *
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  principalCreditsV2?: Maybe<Array<Maybe<PrincipalCreditsForGrouping>>>;
  /**
   * Estimated amount of money spent on the entire film project
   *
   * ---------------------
   * Graphlet Details:
   * - Name: mojo
   * - CTI: IMDb/GraphQL/Mojo
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  productionBudget?: Maybe<ProductionBudget>;
  /**
   * All productionDates for the title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  productionDates?: Maybe<ProductionDatesConnection>;
  /**
   * Current production stage of the title, and the status history.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  productionStatus?: Maybe<ProductionStatusDetails>;
  /**
   * Quotes in this Title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  quotes?: Maybe<TitleQuoteConnection>;
  /**
   * The lifetime box office gross for this title within the specified area. Rank
   * is compared to the lifetime grosses of other titles within the specified area.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: mojo
   * - CTI: IMDb/GraphQL/Mojo
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  rankedLifetimeGross?: Maybe<RankedLifetimeBoxOfficeGross>;
  /**
   * The lifetime box office grosses for this title within the specified areas.
   * Rank is compared to the lifetime grosses of other titles within the specified area.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: mojo
   * - CTI: IMDb/GraphQL/Mojo
   * - Affected by headers: x-imdb-client-name
   * - Cache TTL: 3600 seconds
   * - Slack Channel: #imdb-coverage-tech
   */
  rankedLifetimeGrosses?: Maybe<RankedLifetimeBoxOfficeGrossConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  ratingsSummary?: Maybe<RatingsSummary>;
  /**
   * Paginated list of interests related to this title's interests. Sorted alphabetically. Supports page size of at most 250.
   * Requesting a page size larger than the maximum supported will result in the maximum size being returned.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: interests
   * - CTI: IMDb/GraphQL/Interests
   * - Affected by headers: x-imdb-client-name, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 600 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  relatedInterests?: Maybe<InterestConnection>;
  /**
   * Get lists related to a title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: list
   * - CTI: IMDb/GraphQL/List
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-client-name, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-core-tech
   */
  relatedLists?: Maybe<ListCollectionConnection>;
  /**
   * The earliest localized release date of the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  releaseDate?: Maybe<ReleaseDate>;
  /**
   * All release dates of the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  releaseDates?: Maybe<ReleaseDateConnection>;
  /**
   * The year of the title. The existing IMDb concept of a year that is independent of the release
   * date.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  releaseYear?: Maybe<YearRange>;
  /**
   * Returns the review contribution link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  reviewContributionLink?: Maybe<ContributionLink>;
  /**
   * A summary of user reviews for this title, including themes.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ziggy
   * - CTI: IMDb/GraphQL/Ziggy
   * - Affected by headers: x-imdb-user-language
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-ziggy
   */
  reviewSummary?: Maybe<TitleReviewSummary>;
  /**
   * All Reviews for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  reviews?: Maybe<ReviewsConnection>;
  /**
   * The runtime for the title, in seconds
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  runtime?: Maybe<Runtime>;
  /**
   * All runtimes for the title, in seconds
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  runtimes?: Maybe<RuntimeConnection>;
  /**
   * For titles which are part of a series, provides information about its position within the series
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  series?: Maybe<Series>;
  /**
   * Sound track for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  soundtrack?: Maybe<SoundtrackConnection>;
  /**
   * A list of the languages spoken in the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  spokenLanguages?: Maybe<SpokenLanguages>;
  /**
   * Taglines for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  taglines?: Maybe<TaglineConnection>;
  /**
   * Technical specifications for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  technicalSpecifications?: Maybe<TechnicalSpecifications>;
  /**
   * The genres for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  titleGenres?: Maybe<TitleGenres>;
  /**
   * The localized text for the title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  titleText?: Maybe<TitleText>;
  /**
   * The type of a given title
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  titleType?: Maybe<TitleType>;
  /**
   * The requesting user's notification preferences for this title.
   * Throws FORBIDDEN if customer does not hve a pro subscription
   * Throws UNAUTHENTICATED if logged out
   * @entitlement(PRO_ANY_TIER)
   *
   * ---------------------
   * Graphlet Details:
   * - Name: track
   * - CTI: IMDb/GraphQL/Track
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-pro-brand-networking
   */
  trackNotificationPreferences?: Maybe<TrackNotificationPreferences>;
  /**
   * Trivia for a title.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  trivia?: Maybe<TriviaConnection>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  triviaCategories?: Maybe<Array<Maybe<TriviaCategoryWithTrivia>>>;
  /**
   * Returns the 'trivia' Link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  triviaContributionLink?: Maybe<ContributionLink>;
  /**
   * Retrieve user's rating on a title. Returns null if rating does not exist.
   * Error returned identifying specific error cases.
   * - Throws FORBIDDEN for non-authenticated requests or if requesting user is not authorized to retrieve the rating.
   * - Throws BAD_USER_INPUT if userId parameter is invalid.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: ratings
   * - CTI: IMDb/GraphQL/Ratings Reviews
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  userRating?: Maybe<Rating>;
  /**
   * Returns this customer's watched status of this title.
   * CustomerId will be taken from x-imdb-customer-id header.
   * - Throws AuthenticationError for non-authenticated requests.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watched
   * - CTI: IMDb/GraphQL/Watched
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  userWatchedStatus?: Maybe<WatchedStatus>;
  /**
   * An ordered list of prominent videos related to a title
   * If the first argument exceeds 100, the results will be capped to 100.
   * When there is no sort passed in it, default to the current videoStrip sort logic and behavior.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  videoStrip?: Maybe<VideoConnection>;
  /**
   * Videos related to the title, grouped by video type
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  videoTypes?: Maybe<Array<Maybe<VideoTypeWithVideos>>>;
  /**
   * Returns the watch option from the given provider/location for this title if it is available.
   *
   * The location is required for some providers.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  watchOption?: Maybe<WatchOption>;
  /**
   * Watch options for a given titleId.
   * The options are ordered in an order defined by business and grouped by the watch option category.
   *
   * If the location is included, returns any location-specific watch options (will be required in the future)
   * Promoted provider feature is no longer supported by the Ads team - https://sim.amazon.com/issues/W2W-170. Passing value onto the optional parameter will not have any effect.
   *
   * Returns a list with the maximum number of watch option categories based on the filters. NO PAGINATION
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  watchOptionsByCategory?: Maybe<CategorizedWatchOptionsList>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleAkasArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<AkaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<AkaSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleAlexaTopQuestionsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleAlternateVersionsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleAmazonMusicAlbumsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleAwardNominationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<AwardNominationsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<AwardNominationsSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCertificatesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<CertificatesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCinemaShowtimesByScreeningTypeArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  fallback?: InputMaybe<TitleCinemaShowtimesFallbackOption>;
  filter: TitleCinemaShowtimesFilter;
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCompanyCreditCategoriesArgs = {
  filter?: InputMaybe<CompanyCreditsFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCompanyCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<CompanyCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleConnectionsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ConnectionsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCrazyCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCreditCategoriesArgs = {
  filter?: InputMaybe<TitleCreditCategoryWithCreditsFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCreditGroupingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  aggregateBy?: InputMaybe<CreditAggregation>;
  creditSort?: InputMaybe<TitleCreditsV2Sort>;
  filter?: InputMaybe<TitleCreditsV2Filter>;
  first: Scalars['Int']['input'];
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<TitleCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<TitleCreditSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleCreditsV2Args = {
  after?: InputMaybe<Scalars['ID']['input']>;
  aggregateBy?: InputMaybe<CreditAggregation>;
  creditSort?: InputMaybe<TitleCreditsV2Sort>;
  filter?: InputMaybe<TitleCreditsV2Filter>;
  first: Scalars['Int']['input'];
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleEpisodeCreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  aggregateBy?: InputMaybe<CreditAggregation>;
  filter?: InputMaybe<TitleEpisodeCreditsFilter>;
  first: Scalars['Int']['input'];
  nameId: Scalars['ID']['input'];
  sort?: InputMaybe<EpisodeCreditsSortBy>;
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleExperimental_CreditsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ExperimentalTitleCreditsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<TitleCreditSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleExternalLinkCategoriesArgs = {
  filter?: InputMaybe<ExternalLinksFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleExternalLinksArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ExternalLinksFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleFaqsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<FaqsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleFeaturedPollsArgs = {
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleFeaturedReviewsArgs = {
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleFilmingDatesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleFilmingLocationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleGoofCategoriesArgs = {
  filter?: InputMaybe<GoofCategoryWithGoofsFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleGoofsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<GoofsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleImageTypesArgs = {
  filter?: InputMaybe<ImagesFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleImageUploadLinkArgs = {
  contributionContext: ContributionContext;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleImagesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  bust?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ImagesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleInterestsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleKeywordItemCategoriesArgs = {
  filter?: InputMaybe<TitleKeywordItemCategoriesFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleKeywordsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<TitleKeywordsSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleLatestTrailerWebviewPlayerArgs = {
  filter?: InputMaybe<LatestTrailerFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleLifetimeGrossArgs = {
  boxOfficeArea: BoxOfficeArea;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleMeterRankArgs = {
  input?: InputMaybe<TitleMeterRankingInput>;
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleMeterRankingHistoryArgs = {
  input?: InputMaybe<TitleMeterRankingHistoryInput>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleMoreLikeThisTitlesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleNewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleNominationsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<NominationsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<NominationsSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleOpeningWeekendGrossArgs = {
  boxOfficeArea: BoxOfficeArea;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleOpeningWeekendGrossesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<OpeningWeekendBoxOfficeGrossFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleParentsGuideContributionLinkArgs = {
  contributionContext: ContributionContext;
};


/**
 * Title type
 * Extends external type.
 */
export type TitlePlotContributionLinkArgs = {
  contributionContext: ContributionContext;
};


/**
 * Title type
 * Extends external type.
 */
export type TitlePlotsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<FilterPlots>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAllLocales?: InputMaybe<Scalars['Boolean']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitlePrimaryVideosArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitlePrimaryWatchOptionArgs = {
  location?: InputMaybe<WatchOptionsLocation>;
  promotedProvider?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitlePrincipalCreditsArgs = {
  filter?: InputMaybe<PrincipalCreditsFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitlePrincipalCreditsV2Args = {
  filter?: InputMaybe<PrincipalCreditsV2Filter>;
  useEntitlement?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleProductionDatesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleQuotesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<TitleQuotesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleRankedLifetimeGrossArgs = {
  boxOfficeArea: BoxOfficeArea;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleRankedLifetimeGrossesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<RankedLifetimeBoxOfficeGrossFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleRelatedInterestsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleRelatedListsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleReleaseDatesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<TitleReleaseDatesFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleReviewContributionLinkArgs = {
  contributionContext: ContributionContext;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleReviewsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ReviewsFilter>;
  first: Scalars['Int']['input'];
  sort?: InputMaybe<ReviewsSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleRuntimesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleSoundtrackArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleTaglinesArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleTechnicalSpecificationsArgs = {
  filter?: InputMaybe<TechnicalSpecificationsFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleTriviaArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<TriviaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jumpTo?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleTriviaCategoriesArgs = {
  filter?: InputMaybe<TriviaCategoryWithTriviaFilter>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleTriviaContributionLinkArgs = {
  contributionContext: ContributionContext;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleUserRatingArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleVideoStripArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<VideosQueryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<VideoSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleVideoTypesArgs = {
  filter?: InputMaybe<VideosQueryFilter>;
  sort?: InputMaybe<VideoSort>;
};


/**
 * Title type
 * Extends external type.
 */
export type TitleWatchOptionArgs = {
  location?: InputMaybe<WatchOptionsLocation>;
  providerId: Scalars['ID']['input'];
};


/**
 * Title type
 * Extends external type.
 */
export type TitleWatchOptionsByCategoryArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  location?: InputMaybe<WatchOptionsLocation>;
  promotedProvider?: InputMaybe<Scalars['String']['input']>;
  queryFilter?: InputMaybe<WatchOptionQueryFilter>;
};

export type TitleChartMetadata = {
  __typename?: 'TitleChartMetadata';
  chartDescription: LocalizedString;
  chartName: LocalizedString;
};

export type TitleChartRankingsConnection = {
  __typename?: 'TitleChartRankingsConnection';
  edges: Array<Maybe<TitleChartRankingsEdge>>;
  metadata: TitleChartMetadata;
  pageInfo: PageInfo;
};

export type TitleChartRankingsEdge = {
  __typename?: 'TitleChartRankingsEdge';
  cursor: Scalars['ID']['output'];
  node: TitleChartRankingsNode;
  position: Scalars['Int']['output'];
};

export type TitleChartRankingsInput = {
  rankingsChartType: TitleChartRankingsType;
};

export type TitleChartRankingsNode = {
  __typename?: 'TitleChartRankingsNode';
  /**
   * Rating for title that appears on the chart that may be different from ratings on other properties
   * See for details: https://w.amazon.com/bin/view/IMDb/Ratings/Build/Logic/
   */
  chartRating: Scalars['Float']['output'];
  /** Count of votes used in determining chart rating for title */
  chartVoteCount: Scalars['Int']['output'];
  item: Title;
};

/** Enum exposing all the available Title Chart Ranking Types */
export enum TitleChartRankingsType {
  /** Overall IMDb Bottom 100 Feature List */
  Bottom_100 = 'BOTTOM_100',
  /** Top 50 Bengali Feature List */
  Top_50Bengali = 'TOP_50_BENGALI',
  /** Top 50 Malayalam Feature List */
  Top_50Malayalam = 'TOP_50_MALAYALAM',
  /** Top 50 Tamil Feature List */
  Top_50Tamil = 'TOP_50_TAMIL',
  /** Top 50 Telugu Feature List */
  Top_50Telugu = 'TOP_50_TELUGU',
  /** Overall IMDb Top 250 Feature List */
  Top_250 = 'TOP_250',
  /** Top 250 English Feature List */
  Top_250English = 'TOP_250_ENGLISH',
  /** Top 250 Indian Feature List */
  Top_250India = 'TOP_250_INDIA',
  /** Overall IMDb Top 250 TV List */
  Top_250Tv = 'TOP_250_TV'
}

/** Showtimes grouped by screening type for a specific title and cinema. */
export type TitleCinemaShowtimesByScreeningType = {
  __typename?: 'TitleCinemaShowtimesByScreeningType';
  /** The cinema related to the set of showtimes given in this object. */
  cinema: Cinema;
  /**
   * Distance from the requested location to this cinema.
   * If no location input is provided, this field will be null.
   */
  distanceToCinema?: Maybe<DistanceToCinema>;
  /** Unique identifier for this TitleCinemaShowtimes. */
  id: Scalars['ID']['output'];
  /** List of showtimes for this title at this cinema by screening type. */
  showtimesByScreeningType: Array<Maybe<ShowtimesByScreeningType>>;
  /** The title related to the set of showtimes given in this object. */
  title: Title;
};

/** Connection type for paginated cinema showtimes by screening type results. */
export type TitleCinemaShowtimesByScreeningTypeConnection = {
  __typename?: 'TitleCinemaShowtimesByScreeningTypeConnection';
  /** Edges of TitleCinemaShowtimesByScreeningType. */
  edges: Array<Maybe<TitleCinemaShowtimesByScreeningTypeEdge>>;
  /**
   * Contains information about the fallback results when no showtimes were found in the original response.
   * Only populated when fallback is provided as an input and fallback results were found.
   */
  fallback?: Maybe<TitleCinemaShowtimesFallbackResult>;
  /** Pagination information. */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set. */
  total: Scalars['Int']['output'];
};

/** Edge type for cinema showtimes by screening type for a given title in a paginated result. */
export type TitleCinemaShowtimesByScreeningTypeEdge = {
  __typename?: 'TitleCinemaShowtimesByScreeningTypeEdge';
  /** Cursor for pagination. */
  cursor: Scalars['ID']['output'];
  /** Cinema showtime information for the title. */
  node: TitleCinemaShowtimesByScreeningType;
  /** Position of this edge in the result set. */
  position: Scalars['Int']['output'];
};

/**
 * If specified and the original query returns no showtimes, determines how results should be adjusted.
 * See calling field for more information.
 */
export enum TitleCinemaShowtimesFallbackOption {
  /** Fallback to the next available date of showtimes from the provided `filter.dateRange.startTime` input value, if the original result contains no showtimes. */
  NextAvailableDate = 'NEXT_AVAILABLE_DATE'
}

/**
 * Contains information about fallback results when the original query returned no showtimes data.
 * Only populated when fallback option is specified and fallback results are found.
 * See calling field for more information.
 */
export type TitleCinemaShowtimesFallbackResult = {
  __typename?: 'TitleCinemaShowtimesFallbackResult';
  /** The ISO 8601 date that the graphlet fell back to. */
  fallbackDate: Scalars['Date']['output'];
};

/** Input type for filtering cinema showtimes for a title. */
export type TitleCinemaShowtimesFilter = {
  /**
   * Filter to only include specific cinemas (e.g., `ci1234567`).
   * When combined with dateRange, will only return cinemas that have showtimes within the specified dates.
   * Exactly one of `anyCinemaIds` OR `location` must be provided, but not both.
   * Throws `BAD_USER_INPUT` if more than 400 unique cinemas are provided.
   */
  anyCinemaIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter showtimes by date range. */
  dateRange?: InputMaybe<ShowtimesTitlesDateRangeFilter>;
  /**
   * Filter cinemas based on favorite status.
   * If not provided, defaults to return all cinemas.
   */
  favorites?: InputMaybe<FavoriteFilterOption>;
  /**
   * Filter for cinemas within a certain location.
   * If Provided, the returned array will be in ascending distance from this location.
   * Exactly one of `anyCinemaIds` OR `location` must be provided, but not both.
   */
  location?: InputMaybe<ShowtimesLocation>;
};

/** Title connection details */
export type TitleConnection = {
  __typename?: 'TitleConnection';
  /** The other title in this connection */
  associatedTitle: Title;
  /** The category of this connection */
  category: TitleConnectionCategory;
  /** A description of how these two titles are connected, can contain markdown links to other names and titles */
  description?: Maybe<Markdown>;
};

export type TitleConnectionCategory = {
  __typename?: 'TitleConnectionCategory';
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

/** Pagination for title connection which always has a known total number of edges. */
export type TitleConnectionConnection = {
  __typename?: 'TitleConnectionConnection';
  /** Pages of title connections */
  edges: Array<Maybe<TitleConnectionEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of title connection */
export type TitleConnectionEdge = {
  __typename?: 'TitleConnectionEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A TitleConnection node */
  node: TitleConnection;
  /** Position of the node in this context, eg: TitleConnection 3 out of 340 */
  position: Scalars['Int']['output'];
};

export type TitleCreditCategoryWithCredits = {
  __typename?: 'TitleCreditCategoryWithCredits';
  /** Returns the credit category for the grouping, default is singular version. */
  category: CreditCategory;
  credits?: Maybe<CreditConnection>;
};


export type TitleCreditCategoryWithCreditsCategoryArgs = {
  variant?: InputMaybe<CreditCategoryDisplayVariant>;
};


export type TitleCreditCategoryWithCreditsCreditsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type TitleCreditCategoryWithCreditsFilter = {
  credited?: InputMaybe<CreditedOrUncreditedFilter>;
  excludePrincipal?: InputMaybe<Scalars['Boolean']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** If none of the fields is provided the input will be ignored. */
export type TitleCreditSearchInput = {
  /** The Character name associated with the credit */
  character?: InputMaybe<Scalars['String']['input']>;
  /**
   * The credit category associated with the credit.
   *
   * Valid credit categories can be fetched from the `NAME_CREDIT_CATEGORIES` facet, or from
   * the `nameMetadata.nameCreditCategories` query
   */
  creditCategory?: InputMaybe<Scalars['String']['input']>;
  /**
   * The job category associated with the credit.
   *
   * Valid job categories can be fetched from the `NAME_JOB_CATEGORIES` facet, or from
   * the `nameMetadata.nameCreditCategories` query
   */
  jobCategory?: InputMaybe<Scalars['String']['input']>;
  /** The NameId associated with the title credit. */
  nameId?: InputMaybe<Scalars['ID']['input']>;
};

export type TitleCreditSort = {
  by?: InputMaybe<TitleCreditSortBy>;
  order?: InputMaybe<SortOrder>;
};

export enum TitleCreditSortBy {
  /** Sort by popular cast members */
  TopCast = 'TOP_CAST'
}

/**
 * Example:
 * 1. if you want to match titles with name const `nm0000138` AND `nm0000206` then specify:
 * `
 * allCredits: [{nameId: 'nm0000138'}
 * , {nameId: 'nm0000206'}
 * ]
 * `
 *
 * 2. if you want to match titles where name const `nm0000138` was a `Director` AND `nm0000206` was a `Producer` then
 * specify:
 * `
 * allCredits: [{nameId: 'nm0000138', jobCategory: 'Director'}
 * , {nameId: 'nm0000206', jobCategory: 'Producer'}
 * ]
 * `
 *
 * 3. if you want to match titles WITHOUT a `Writer` credit then specify:
 * `
 * excludeCredits: [{jobCategory: 'Writer'}
 * ]
 * `
 *
 * 4. if you want to match Titles where `nm0185819` played `James Bond` AND `nm1560977` was a `Director` then specify:
 * `
 * allCredits: [{nameId: 'nm0185819', character: 'James Bond'}
 * , {nameId: 'nm1560977', jobCategory: 'Director'}
 * ]
 * `
 *
 * 5. if you want to match Titles where a character was called `Mario` then specifiy:
 * `
 * allCredits: [{character: 'Mario'}
 * ]
 * `
 */
export type TitleCreditsConstraint = {
  /** A title match must contain ALL of these credits */
  allCredits?: InputMaybe<Array<InputMaybe<TitleCreditSearchInput>>>;
  /** A title match must contain AT LEAST ONE of these credits */
  anyCredits?: InputMaybe<Array<InputMaybe<TitleCreditSearchInput>>>;
  /**
   * A title match must contain NONE of these credits
   *
   * If the same input is specified in the any/all and exclude constraints,
   * then the results should be empty.
   */
  excludeCredits?: InputMaybe<Array<InputMaybe<TitleCreditSearchInput>>>;
};

export type TitleCreditsFilter = {
  /** Filter for specific credit categories */
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter for credited or uncredited credits only */
  credited?: InputMaybe<CreditedOrUncreditedFilter>;
  /** Filter out specific credit categories */
  excludeCategories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  excludePrincipal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter credits on these specific names */
  names?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type TitleCreditsV2Filter = {
  /** Filters that apply at the individual contributed credit level. */
  creditLevelFilter?: InputMaybe<CreditLevelCreditsFilterSet>;
  /** Filters that apply to credits at the name level. */
  nameLevelFilter?: InputMaybe<NameLevelCreditsFilterSet>;
};

export type TitleCreditsV2Sort = {
  /**
   * This is modelled as a string to allow for altering the list of allowed values over time. Supported values are:
   *
   * CREDIT_IMPORTANCE: Credit ordering follows this priority sequence:
   * 1. Grouping - Based on a fixed order of groupings, chosen to be similar to that seen on movie or TV end credits.
   * 2. Top Stars Ranking - Priority based on special top performers list, for cast only
   * 3. Credited Status - Credited roles take precedence over uncredited
   * 4. Episode Count - For a series, higher episode counts appear first
   * 5. Order - For a series, sum the order values across all episodes. For non-series, use the order value for the credit.
   *    (Order numbers are ignored from when a large order value gap is found between 2 credits.)
   * 6. Grouped Order - Order based on multi-level groupings, as seen in Writer category.
   * 7. Chronological Order - For a series, sort earlier start years ahead of later start years. And similar for end years.
   * 8. Name Text - Alphabetical ordering by name, which typically treats "Firstname Lastname" as "Lastname, Firstname".
   * 9. Name ID - A final tie-break by name ID to ensure consistent ordering (smallest first)
   *
   * CREDIT_IMPORTANCE is the default.
   */
  by?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<SortOrder>;
};

export enum TitleDataType {
  AlternateVersion = 'ALTERNATE_VERSION',
  Award = 'AWARD',
  BusinessInfo = 'BUSINESS_INFO',
  CrazyCredit = 'CRAZY_CREDIT',
  Goof = 'GOOF',
  Location = 'LOCATION',
  Plot = 'PLOT',
  Quote = 'QUOTE',
  Soundtrack = 'SOUNDTRACK',
  Technical = 'TECHNICAL',
  Trivia = 'TRIVIA'
}

export type TitleDisplayOutput = {
  __typename?: 'TitleDisplayOutput';
  /** Current user's country or region selection for title display. ID in ISO 3166 format. */
  country?: Maybe<Scalars['ID']['output']>;
  /** Current user's language selection for title display. ISO 639 format. */
  language?: Maybe<Scalars['ID']['output']>;
  /** Current user's reference view selection for contributors. */
  prefersReferenceView: Scalars['Boolean']['output'];
};

export type TitleEpisodeCreditsFilter = {
  /** Filters that apply at the individual contributed credit level. */
  creditLevelFilter?: InputMaybe<CreditLevelCreditsFilterSet>;
  /** Filters that apply at the episode level. */
  episodes?: InputMaybe<EpisodesFilter>;
  /** Filters that apply to credits at the name level. */
  nameLevelFilter?: InputMaybe<NameLevelCreditsFilterSet>;
};

/** Pagination for title facets */
export type TitleFacetConnection = {
  __typename?: 'TitleFacetConnection';
  edges: Array<Maybe<TitleFacetEdge>>;
  pageInfo: PageInfo;
  /** Provides information on the total number of titles you could filter on */
  total: Scalars['Int']['output'];
};

export type TitleFacetEdge = {
  __typename?: 'TitleFacetEdge';
  cursor: Scalars['ID']['output'];
  node: Title;
  position: Scalars['Int']['output'];
  /** How many items are associated with this title node */
  total: Scalars['Int']['output'];
};

export enum TitleFacetField {
  Genres = 'GENRES',
  Keywords = 'KEYWORDS',
  NameCreditCategories = 'NAME_CREDIT_CATEGORIES',
  NameJobCategories = 'NAME_JOB_CATEGORIES',
  TitleType = 'TITLE_TYPE',
  WatchProviders = 'WATCH_PROVIDERS'
}

export type TitleGenre = {
  __typename?: 'TitleGenre';
  genre: GenreItem;
  relevanceRanking: Scalars['Int']['output'];
  subGenres: Array<Maybe<TitleKeyword>>;
};

export type TitleGenreRecommendation = {
  __typename?: 'TitleGenreRecommendation';
  /** Text to be displayed as a subheading for the carousel, explaining why we recommend those titles */
  explanation: LocalizedMarkdown;
  /** Text to be displayed as the title for the carousel */
  label: LocalizedString;
  refTag: Scalars['String']['output'];
  titles?: Maybe<TitleGenreRecommendationConnection>;
};


export type TitleGenreRecommendationTitlesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};

export type TitleGenreRecommendationConnection = {
  __typename?: 'TitleGenreRecommendationConnection';
  edges: Array<Maybe<TitleGenreRecommendationEdge>>;
  pageInfo: PageInfo;
};

export type TitleGenreRecommendationEdge = {
  __typename?: 'TitleGenreRecommendationEdge';
  cursor: Scalars['ID']['output'];
  node: Title;
};

export type TitleGenres = {
  __typename?: 'TitleGenres';
  genres: Array<Maybe<TitleGenre>>;
};


export type TitleGenresGenresArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<GenreSort>;
};

/** TitleKeyword details */
export type TitleKeyword = {
  __typename?: 'TitleKeyword';
  /** Votes from users about whether this keyword item is interesting */
  interestScore: InterestScore;
  /** Item scope keyword category, i.e. category assigned for keyword inside title */
  itemCategory?: Maybe<TitleKeywordItemCategory>;
  /** The keyword */
  keyword: Keyword;
  /** Legacy identifier intended for search */
  legacyId: Scalars['String']['output'];
};

/** Pagination for keywords which always has a known total number of edges. */
export type TitleKeywordConnection = {
  __typename?: 'TitleKeywordConnection';
  /** Pages of keywords */
  edges: Array<Maybe<TitleKeywordEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of keywords */
export type TitleKeywordEdge = {
  __typename?: 'TitleKeywordEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A TitleKeyword node */
  node: TitleKeyword;
  /** Position of the node in this context, eg: TitleKeyword 3 out of 340 */
  position: Scalars['Int']['output'];
};

export type TitleKeywordItemCategoriesFilter = {
  /** Filter out specific title keywords categories */
  excludeItemCategories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter for specific title keywords categories */
  itemCategories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** TitleKeyword item scope category details */
export type TitleKeywordItemCategory = {
  __typename?: 'TitleKeywordItemCategory';
  /** An opaque ID, suitable for caching the concept */
  id: Scalars['ID']['output'];
  /** Not localized category value, e.g. plot-detail, can be used for search and filters */
  itemCategoryId: Scalars['String']['output'];
  /** The language of the display text */
  language: DisplayableLanguage;
  /** Category display text */
  text: Scalars['String']['output'];
};

export type TitleKeywordItemCategoryWithKeywords = {
  __typename?: 'TitleKeywordItemCategoryWithKeywords';
  /** Keyword item scope category */
  itemCategory: TitleKeywordItemCategory;
  /** List of categorized keywords with the same category */
  keywords: TitleKeywordConnection;
};


export type TitleKeywordItemCategoryWithKeywordsKeywordsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type TitleKeywordsSort = {
  by: TitleKeywordsSortBy;
};

export enum TitleKeywordsSortBy {
  Alphabetical = 'ALPHABETICAL'
}

/**
 * Filters that apply to credits at the title level.
 * Each specified filter is AND-ed together.
 * For filters that accept a list of values, the filter is an OR across that list, so any
 * credit matching one value meets the filter's criteria.
 */
export type TitleLevelCreditsFilterSet = {
  /**
   * Filter out credits on titles with specific genres.
   * The list of genres can be accessed from titleMetadata.titleGenres.
   * By default, credits for all genres are included.
   */
  excludeGenres?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter out specific production stages.
   * Cannot be used in conjunction with "productionStage": a title can only have one of these values;
   * if you specify values to include and exclude, the behaviour for unspecified values is ambiguous.
   * By default, credits for all production stages are included.
   */
  excludeProductionStage?: InputMaybe<Array<InputMaybe<ProductionStageFilter>>>;
  /**
   * Filter out credits for titles with specific titleTypes.
   * The list of titleTypes can be accessed from titleMetadata.titleTypes.
   * Cannot be used in conjunction with "titleType": a title can only have one of these values;
   * if you specify values to include and exclude, the behaviour for unspecified values is ambiguous.
   * By default, credits for all title types are included.
   */
  excludeTitleType?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter for credits on titles with specific genres.
   * The list of genres can be accessed from titleMetadata.titleGenres.
   * By default, credits for all genres are included.
   */
  genres?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter for specific production stages.
   * Cannot be used in conjunction with "excludeProductionStage": a title can only have one of these values;
   * if you specify values to include and exclude, the behaviour for unspecified values is ambiguous.
   * By default, credits for all production stages are included.
   */
  productionStage?: InputMaybe<Array<InputMaybe<ProductionStageFilter>>>;
  /**
   * Filter for a project status of UPCOMING, PREVIOUS or PROJECT_IN_DEVELOPMENT.
   * By default, credits for all project statuses are included. Note that PROJECT_IN_DEVELOPMENT titles are not included
   * when the request has no Pro tier entitlement.
   */
  projectStatus?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter credits to only those for these specific titles.
   * By default, credits for all titles are included.
   */
  titleId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter credits for titles with specific titleTypes.
   * The list of titleTypes can be accessed from titleMetadata.titleTypes.
   * Cannot be used in conjunction with "excludeTitleType": a title can only have one of these values;
   * if you specify values to include and exclude, the behaviour for unspecified values is ambiguous.
   * By default, credits for all title types are included.
   */
  titleType?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /**
   * Filter credits for titles with specific titleTypeCategory.
   * By default, credits for all title type categories are included.
   */
  titleTypeCategory?: InputMaybe<Array<InputMaybe<TitleTypeCategoryValue>>>;
};

export type TitleListItemSearchConnection = {
  __typename?: 'TitleListItemSearchConnection';
  edges: Array<Maybe<TitleListItemSearchEdge>>;
  facet?: Maybe<Array<Maybe<SearchFacet>>>;
  /**
   * The number of titles in the filtered list that a customer has rated.
   * Cutomer Id is required for this field or an authentication error will be thrown.
   */
  myRatedCount?: Maybe<Scalars['Int']['output']>;
  /**
   * The percentage of titles in the filtered list that a customer has rated.  We round the percentage
   * to the nearest integer but we may change the precision depending on Product's requirement update.
   * Customer Id is required for this field or an authentication error will be thrown.
   */
  myRatedPercentage?: Maybe<LocalizedString>;
  pageInfo: PageInfo;
  total: Scalars['Int']['output'];
};


export type TitleListItemSearchConnectionFacetArgs = {
  facetField: TitleFacetField;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type TitleListItemSearchEdge = {
  __typename?: 'TitleListItemSearchEdge';
  cursor: Scalars['ID']['output'];
  node: ListItemSearchNode;
  title: Title;
};

export type TitleListSearchSort = {
  by: TitleListSearchSortBy;
  order: SortOrder;
};

export enum TitleListSearchSortBy {
  /**
   * Gross revenue pulled in via box-office in Domestic market for entire lifetime of title.
   * Domestic refers to North America (U.S., Canada, and Puerto Rico)
   * ASC: Lower numbers means the title has pulled in less box-office revenue, so poorer performing titles will be first.
   */
  BoxOfficeGrossDomestic = 'BOX_OFFICE_GROSS_DOMESTIC',
  /**
   * Date when the list item was added to the list
   * ASC: Earlier date will be first.
   */
  DateAdded = 'DATE_ADDED',
  /** List order determined by the customer */
  ListOrder = 'LIST_ORDER',
  /**
   * Overall Metascore based on critic reviews. Titles without a metascore are
   * placed at the end when using ASC sort order.
   * ASC: Lower Metacritic score means the title is rated more poorly, so titles with worse scores will be first.
   */
  MetacriticScore = 'METACRITIC_SCORE',
  /**
   * Star Rating given by the requesting user.
   * ASC: Lower star rating means the title the user rated the title more poorly, so most disliked titles will be first.
   */
  MyRating = 'MY_RATING',
  /**
   * Date when customer rated a title.
   * ASC: Earlier (older) ratings will be first.
   */
  MyRatingDate = 'MY_RATING_DATE',
  /**
   * TitleMeterType.TITLE_METER (aka Pro MOVIEMeter). Score given to non-episodic title types.
   * ASC: Lower popularity score means that the title is more popular, so the most popular titles will be first.
   */
  Popularity = 'POPULARITY',
  /**
   * Sort results based on specified ranking algorithm.  For the advancedTitleSearch query, exactly one ranked title list
   * constraint must be specified for using this sort option.
   * ASC: Higher ranks will be first.
   */
  Ranking = 'RANKING',
  /**
   * Earliest wide release date of a title. Titles without a release date are
   * placed at the end when using ASC sort order.
   * ASC: Earlier (older) released title will be first.
   */
  ReleaseDate = 'RELEASE_DATE',
  /**
   * The length of the title in terms of runtime.
   * ASC: Lower runtime means the title is shorter, so shortest titles will be first.
   */
  Runtime = 'RUNTIME',
  /**
   * Star Rating given by the specified user in the SpecifiedUserRatingSearchConstraint.
   * Throws BAD_USER_INPUT if the SpecifiedUserRatingSearchConstraint is not specified.
   * ASC: Lower star rating means the title the user rated the title more poorly, so most disliked titles will be first.
   */
  SingleUserRating = 'SINGLE_USER_RATING',
  /**
   * Date when the specified user rated a title.
   * Throws BAD_USER_INPUT if the SpecifiedUserRatingSearchConstraint is not specified.
   * ASC: Earlier (older) ratings will be first.
   */
  SingleUserRatingDate = 'SINGLE_USER_RATING_DATE',
  /**
   * Alphabetical sorting based on regional title text as determined by user language preferences.
   * Language preference is determined by x-imdb-user-country and x-imdb-user-language headers.
   * Only supports the languages/regions we support for localized search. Defaults to original title otherwise.
   * ASC: Lower numbers and letters near the top of the alphabet will be returned first.
   */
  TitleRegional = 'TITLE_REGIONAL',
  /**
   * Weighted IMDb Star Rating as determined by users
   * Note: IMDb maintains a threshold to a minimum number of ratings before it is considered.
   * ASC: Lower star rating means the title is rated more poorly, so titles with worse ratings will be first.
   */
  UserRating = 'USER_RATING',
  /**
   * Count of ratings given by users
   * Note: IMDb maintains a threshold to a minimum number of ratings before it is considered.
   * ASC: Lower count of ratings means the title has been rated a fewer number of
   * times, so titles with least ratings will be first.
   */
  UserRatingCount = 'USER_RATING_COUNT',
  /**
   * The recognized year of the title. Typically, the release year, but guidelines are here:
   * https://help.imdb.com/article/contribution/titles/title-formatting/G56U5ERK7YY47CQB
   * ASC: Earlier (older) titles will be first.
   */
  Year = 'YEAR'
}

export type TitleMeta = {
  __typename?: 'TitleMeta';
  canonicalId: Scalars['ID']['output'];
  publicationStatus: PublicationStatus;
  restrictions?: Maybe<TitleMetaRestrictions>;
};

/** Information about restrictions applied to meta */
export type TitleMetaRestrictions = {
  __typename?: 'TitleMetaRestrictions';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
};

export type TitleMetadata = {
  __typename?: 'TitleMetadata';
  /** All the valid external link categories */
  externalLinkCategories: Array<Maybe<ExternalLinkCategory>>;
  /** All the valid goof types */
  goofCategories: Array<Maybe<GoofCategory>>;
  /** All the connection categories */
  titleConnectionCategories: Array<Maybe<TitleConnectionCategory>>;
  /** All title Genres. */
  titleGenres: Array<Maybe<GenreItem>>;
  /** All title type categories with title types. */
  titleTypeCategories: Array<Maybe<TitleTypeCategoryWithTitleTypes>>;
  /** All title types, or all title types filtered by category. */
  titleTypes: Array<Maybe<TitleType>>;
};


export type TitleMetadataTitleTypesArgs = {
  category?: InputMaybe<TitleTypeCategoryValue>;
};

export type TitleMeterRanking = {
  __typename?: 'TitleMeterRanking';
  /**
   * The current IMDbPro meter ranking of the title. A lower value is better.
   * Ranking information beyond 5000 requires entitlement proving Pro subscription.
   */
  currentRank: Scalars['Int']['output'];
  /** The Pro Meter type that this rank represents */
  meterType?: Maybe<TitleMeterType>;
  /**
   * If a previous rank exists, this is a set of fields comparing the current rank
   * to the previous rank
   */
  rankChange?: Maybe<MeterRankChange>;
};

/** Requires entitlement proving Pro subscription. */
export type TitleMeterRankingHistory = {
  __typename?: 'TitleMeterRankingHistory';
  /**
   * The best historical IMDbPro Title Meter ranking of a title.
   * A lower value is better. By default, returns the values over all time.
   * Requires entitlement proving Pro subscription.
   */
  bestRank?: Maybe<MeterRankingHistoryEntry>;
  /** History of IMDbPro Title meter rankings of a name. */
  ranks?: Maybe<Array<Maybe<MeterRankingHistoryEntry>>>;
  restriction?: Maybe<MeterRestriction>;
};

export type TitleMeterRankingHistoryInput = {
  /**
   * Last date to obtain Title meter history for. If not provided, default is most recent ranking date.
   * If there is no ranking on end date, the date is the most recent date before this one.
   */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /**
   * Type of ranking history being requested.
   * If omitted, the meter type used will either be the pure MovieMeter, TVMeter, or TitleMeter value depending
   * on the meter type.
   */
  meterType?: InputMaybe<TitleMeterType>;
  /**
   * First date to obtain Title meter history for. If not provided, default is first ranking date.
   * If there is no ranking on start date, the date is the earliest date after this one.
   */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

export type TitleMeterRankingInput = {
  /** If omitted, the meter type used will either be the pure MovieMeter or TVMeter value depending on the title type. */
  meterType?: InputMaybe<TitleMeterType>;
};

export type TitleMeterSearchConstraint = {
  /**
   * Match titles that have a current Title Meter value that falls in the specified range
   * At this time, we only support max up to 100 for TV_METER and MOVIE_METER.
   */
  rankRange?: InputMaybe<IntRangeInput>;
  /** The default is TITLE_METER */
  titleMeterType?: InputMaybe<TitleMeterType>;
};

export enum TitleMeterType {
  /** Ranking that aggregates titles of type movie, short, and video */
  MovieMeter = 'MOVIE_METER',
  /** Ranking that aggregates all title types aside from episodes. Best used for sorting. */
  TitleMeter = 'TITLE_METER',
  /** Ranking that aggregates titles of type tv_series, tv_miniseries, tv_movie, tv_short, and tv_special */
  TvMeter = 'TV_METER'
}

/** Quote details */
export type TitleQuote = {
  __typename?: 'TitleQuote';
  /** The quote as a displayable article */
  displayableArticle: DisplayableArticle;
  /** Title Quote ID */
  id: Scalars['ID']['output'];
  /** Votes from users about whether this Quote is interesting */
  interestScore: InterestScore;
  /** Is this Title Quote a spoiler */
  isSpoiler: Scalars['Boolean']['output'];
  /** The language of this Title Quote */
  language: DisplayableLanguage;
  /** The verbal and/or non-verbal lines that make up this Title Quote */
  lines: Array<Maybe<TitleQuoteLine>>;
};

/** A character speaking a line in a Title Quote */
export type TitleQuoteCharacter = {
  __typename?: 'TitleQuoteCharacter';
  /** The name of the character in the Title */
  character: Scalars['String']['output'];
  /** The Name behind that character */
  name?: Maybe<Name>;
};

/** Pagination for Quote types which always has a known total number of edges. */
export type TitleQuoteConnection = {
  __typename?: 'TitleQuoteConnection';
  /** Pages of Quotes */
  edges: Array<Maybe<TitleQuoteEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Quotes */
export type TitleQuoteEdge = {
  __typename?: 'TitleQuoteEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Quote node */
  node: TitleQuote;
  /** Position of the node in this context, eg: Quote 3 out of 27 */
  position: Scalars['Int']['output'];
};

/** A specific line in the Title Quote. Can be a verbal line with characters speaking or stage directions */
export type TitleQuoteLine = {
  __typename?: 'TitleQuoteLine';
  /** The characters who speak this line, e.g.  'Rick'. Not required: a line may be non-verbal */
  characters?: Maybe<Array<Maybe<TitleQuoteCharacter>>>;
  /** Stage direction, e.g. 'Rick gently places his hand under her chin and raises it so their eyes meet'. Not required. */
  stageDirection?: Maybe<Scalars['String']['output']>;
  /**
   * The body of the quotation line, e.g 'Here's looking at you kid. '.  Not
   * required: you may have stage directions with no dialogue.
   */
  text?: Maybe<Scalars['String']['output']>;
};

/**
 * Example: if you want to match titles of quote 'actually mammals' OR 'planet', PLUS
 * the title must contain 'cancer', specify anyQuoteTextTerms: ['actually mammals', 'planet'] plus
 * allQuoteTextTerms: ['cancer'].
 */
export type TitleQuoteMatchingSearchConstraint = {
  /** A title match must contain ALL of these search terms in at least one of its quotes. */
  allQuoteTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these search terms in at least one of its quotes. */
  anyQuoteTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type TitleQuotesFilter = {
  /** Only return Quotes in which one of these Names are present */
  names?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter or only return spoilers */
  spoilers?: InputMaybe<FilterSpoilers>;
};

export type TitleRecommendation = {
  __typename?: 'TitleRecommendation';
  explanations: Array<Maybe<RecommendationExplanation>>;
  refTag: Scalars['String']['output'];
  title: Title;
};

export type TitleRecommendationConnection = {
  __typename?: 'TitleRecommendationConnection';
  edges: Array<Maybe<TitleRecommendationEdge>>;
  pageInfo: PageInfo;
};

export type TitleRecommendationEdge = {
  __typename?: 'TitleRecommendationEdge';
  cursor: Scalars['ID']['output'];
  node: TitleRecommendation;
};

export type TitleRecommendationsFilter = {
  /**
   * Includes title recommendation titles for below title type category values. At time of writing, titleRecommendations() only
   * supports movie and tv title type categories, and can only support filtering for a single title type.
   */
  includeTitleTypes?: InputMaybe<Array<InputMaybe<TitleTypeCategoryValue>>>;
};

export type TitleReleaseDatesFilter = {
  /**
   * Filter release dates for specific countries
   * The country code - either an ISO 3166 code or an internally defined code if no ISO code exists for that country.
   */
  countries?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Filter release dates */
  wideRelease?: InputMaybe<WideReleaseFilter>;
};

/** A review that mentions a theme, and an excerpt from it. */
export type TitleReviewExcerpt = {
  __typename?: 'TitleReviewExcerpt';
  /** The excerpt from the review (optional) */
  excerpt?: Maybe<LocalizedMarkdown>;
  /** The review */
  review: Review;
};

/** Review summaries at different length levels for a particular sentiment */
export type TitleReviewSentimentSection = {
  __typename?: 'TitleReviewSentimentSection';
  /** Long summary */
  long: LocalizedMarkdown;
  /** Medium length summary */
  medium: LocalizedMarkdown;
  /** Short summary */
  short: LocalizedMarkdown;
};

/** Summary and themes of reviews for a title */
export type TitleReviewSummary = {
  __typename?: 'TitleReviewSummary';
  /** Summary focused on negative reviews (optional) */
  negative?: Maybe<TitleReviewSentimentSection>;
  /** Overall summary of reviews across all sentiments */
  overall: TitleReviewSentimentSection;
  /** Summary focused on positive reviews (optional) */
  positive?: Maybe<TitleReviewSentimentSection>;
  /** Common themes discussed across reviews */
  themes?: Maybe<Array<Maybe<TitleReviewTheme>>>;
};


/** Summary and themes of reviews for a title */
export type TitleReviewSummaryThemesArgs = {
  filter?: InputMaybe<TitleReviewSummaryThemesFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Input type for filtering themes in a title's review summary */
export type TitleReviewSummaryThemesFilter = {
  /** Exclude themes with these sentiments */
  excludeSentiments?: InputMaybe<Array<InputMaybe<TitleReviewThemeSentiment>>>;
  /** Only include themes with these sentiments */
  includeSentiments?: InputMaybe<Array<InputMaybe<TitleReviewThemeSentiment>>>;
  /** Filter to specific theme IDs */
  themeIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** A theme identified across multiple reviews */
export type TitleReviewTheme = {
  __typename?: 'TitleReviewTheme';
  /** Displayable label for the theme, e.g. ('Intense') */
  label: LocalizedString;
  /** Reviews/excerpts related to this theme */
  reviews: Array<Maybe<TitleReviewExcerpt>>;
  /** The sentiment classification for this theme e.g. POSITIVE */
  sentiment: TitleReviewThemeSentiment;
  /** Summary text describing this theme's presence in reviews. */
  summary: LocalizedMarkdown;
  /** Identifier for the theme, e.g. ('intense') */
  themeId: Scalars['ID']['output'];
};


/** A theme identified across multiple reviews */
export type TitleReviewThemeReviewsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Sentiment classification for review themes */
export enum TitleReviewThemeSentiment {
  /** Theme is discussed negatively in reviews */
  Negative = 'NEGATIVE',
  /** Theme is discussed neutrally in reviews */
  Neutral = 'NEUTRAL',
  /** Theme is discussed positively in reviews */
  Positive = 'POSITIVE'
}

export type TitleSearchConnection = {
  __typename?: 'TitleSearchConnection';
  edges: Array<Maybe<TitleSearchEdge>>;
  pageInfo: PageInfo;
};

export type TitleSearchEdge = {
  __typename?: 'TitleSearchEdge';
  cursor: Scalars['ID']['output'];
  node: Title;
};

export type TitleSearchOptions = {
  /**
   * The earliest release date for a title must fall within the specified range
   * By default, we filter titles by release year provided in the search term, if applicable.
   * If a releaseDate is provided we do not apply default search term based release year filter.
   */
  releaseDateRange?: InputMaybe<DateRange>;
  /**
   * The types of titles to include in results.
   * By default, all title types are included in the search.
   */
  type?: InputMaybe<Array<InputMaybe<MainSearchTitleType>>>;
};

export type TitleText = {
  __typename?: 'TitleText';
  country?: Maybe<DisplayableCountry>;
  isOriginalTitle: Scalars['Boolean']['output'];
  language?: Maybe<DisplayableLanguage>;
  text: Scalars['String']['output'];
};

/**
 * Title name constraints are affected by user language preferences.
 * Language preference is determined by x-imdb-user-language header.
 */
export type TitleTextSearchConstraint = {
  /**
   * Matches titles based on their original name as well as regional name corresponding with user
   * language preferences. If no language preferences are provided, en-US is used by default.
   * There is no fuzzy matching.
   * For example: 'Toy Story' will be matched by 'Toy' and 'Story' but not 'Toy Stor'
   */
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};

export type TitleTrackRecommendationEdge = {
  __typename?: 'TitleTrackRecommendationEdge';
  /** Cursor ID of the title track recommendation */
  cursor: Scalars['ID']['output'];
  /** A title track recommendation node */
  node: Title;
  /** Position of the node in this context, e.g. TitleTrackRecommendationEdge 2 out of 10 */
  position: Scalars['Int']['output'];
};

export type TitleTrackRecommendationsConnection = {
  __typename?: 'TitleTrackRecommendationsConnection';
  /** Page of title track recommendations */
  edges: Array<Maybe<TitleTrackRecommendationEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of title track recommendations */
  total: Scalars['Int']['output'];
};

export type TitleTrivia = {
  __typename?: 'TitleTrivia';
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  category: TriviaCategory;
  /**
   * Returns the trivia correction Link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  correctionLink?: Maybe<ContributionLink>;
  /**
   * The trivia as a displayable article
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  displayableArticle: DisplayableArticle;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  id: Scalars['ID']['output'];
  /**
   * trivia Voting summary
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  interestScore: InterestScore;
  /**
   * Is this trivia item a spoiler
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  isSpoiler: Scalars['Boolean']['output'];
  /**
   * trivia Related Name IDs
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  relatedNames?: Maybe<Array<Maybe<Name>>>;
  /**
   * Returns the trivia reporting Link.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: kahlo
   * - CTI: IMDb/GraphQL/Kahlo
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-contributors-tech
   */
  reportingLink?: Maybe<ContributionLink>;
  /**
   * The trivia text
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  text: Markdown;
  /**
   * Title related to the trivia
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  title?: Maybe<Title>;
  /**
   * trivia Trademark text
   *
   * ---------------------
   * Graphlet Details:
   * - Name: janet
   * - CTI: IMDb/GraphQL/Janet
   * - Affected by headers: x-imdb-client-name, x-imdb-normalized-languages, x-imdb-user-country, x-imdb-user-language, x-imdb-customer-id
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-content-api
   */
  trademark?: Maybe<Markdown>;
};


export type TitleTriviaCorrectionLinkArgs = {
  contributionContext: ContributionContext;
};


export type TitleTriviaReportingLinkArgs = {
  contributionContext: ContributionContext;
};

/**
 * Example: if you want to match titles of trivia 'twisted ankle' OR 'shooting scenes', PLUS
 * the title must contain 're-cast', specify anyTriviaTextTerms: ['twisted ankle', 'shooting scenes']
 *  plus allTriviaTextTerms: ['re-cast'].
 */
export type TitleTriviaMatchingSearchConstraint = {
  /** A title match must contain ALL of these search terms in at least one of its trivia. */
  allTriviaTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A title match must contain AT LEAST ONE of these search terms in at least one of its trivia. */
  anyTriviaTextTerms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type TitleType = {
  __typename?: 'TitleType';
  /**
   * Whether this title type can have episodes.
   * It does not guarantee that a title of this type actually has episodes, only that it can have episodes.
   */
  canHaveEpisodes: Scalars['Boolean']['output'];
  /** The categories the title type is in. */
  categories: Array<Maybe<TitleTypeCategory>>;
  /** Title type as displayable property */
  displayableProperty: DisplayableTitleTypeProperty;
  /** Title type ID */
  id: Scalars['ID']['output'];
  /** A boolean flag asserting whether this title type is an episode. */
  isEpisode: Scalars['Boolean']['output'];
  /** A boolean flag asserting whether this title type is a series. */
  isSeries: Scalars['Boolean']['output'];
  /** The language the text is written in */
  language: DisplayableLanguage;
  /** The displayable title type, e.g. 'TV Series' */
  text: Scalars['String']['output'];
};

export type TitleTypeCategory = {
  __typename?: 'TitleTypeCategory';
  /** A token representing the title type category. */
  id: Scalars['ID']['output'];
  /** The language of the display text. */
  language: DisplayableLanguage;
  /** The display text for the title type category (e.g. 'TV'). */
  text: Scalars['String']['output'];
  /** The enum value representing the title type category. */
  value: TitleTypeCategoryValue;
};

export type TitleTypeCategorySummary = {
  __typename?: 'TitleTypeCategorySummary';
  /** The title type category */
  titleTypeCategory: TitleTypeCategory;
  /** The total number of credits for the title type category */
  total: Scalars['Int']['output'];
};

export enum TitleTypeCategoryValue {
  /** Category containing audio related title types (e.g. 'Podcast Series'). */
  Audio = 'audio',
  /** Category containing gaming related title types (e.g. 'Video Game'). */
  Gaming = 'gaming',
  /** Category containing movie related title types (e.g. 'Movie'). */
  Movie = 'movie',
  /** Category containing music related title types (e.g. 'Music Video'). */
  Music = 'music',
  /** Category containing anything else */
  Other = 'other',
  /** Category containing TV related title types (e.g. 'TV Series'). */
  Tv = 'tv',
  /** Category containing video related title types (e.g. 'Video'). */
  Video = 'video'
}

export type TitleTypeCategoryWithTitleTypes = {
  __typename?: 'TitleTypeCategoryWithTitleTypes';
  /** A category of title types. */
  category: TitleTypeCategory;
  /** All title types in the category. */
  titleTypes: Array<Maybe<TitleType>>;
};

export type TitleTypeSearchConstraint = {
  /**
   * Match titles based on any of the title types specified.
   * Title type ids can be obtained by querying `titleMetadata.titleType.id`
   * For example: movie, tvSeries, videoGame, etc.
   */
  anyTitleTypeIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Exclude titles based on any of the title types specified.
   * Title type ids can be obtained by querying `titleMetadata.titleType.id`
   * For example: movie, tvSeries, videoGame, etc.
   *
   * If the same input is specified in the any and exclude constraints,
   * then the results should be empty.
   */
  excludeTitleTypeIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type TitleTypeSummary = {
  __typename?: 'TitleTypeSummary';
  /** The title type */
  titleType: TitleType;
  /** The total number of credits for the title type */
  total: Scalars['Int']['output'];
};

export enum TitleWatchedSourceType {
  /** The customer checked-in this title before. */
  Checkin = 'CHECKIN',
  /** The customer explicitly mark this title as watched */
  Explicit = 'EXPLICIT',
  /** The customer rated this title before. */
  Rating = 'RATING',
  /** The customer reviewed this title before. */
  Review = 'REVIEW'
}

export type TitleWatchedStatus = {
  __typename?: 'TitleWatchedStatus';
  title: Title;
  /** Watched status of this title. */
  watchedStatus: WatchedStatus;
};

export type TitleWatchlistRecommendation = {
  __typename?: 'TitleWatchlistRecommendation';
  /** Title text to be displayed per recommended title, explaining why a title was recommended */
  explanation: LocalizedMarkdown;
  title: Title;
};

export type TitleWatchlistRecommendationConnection = {
  __typename?: 'TitleWatchlistRecommendationConnection';
  edges: Array<Maybe<TitleWatchlistRecommendationEdge>>;
  pageInfo: PageInfo;
  refTag: Scalars['String']['output'];
};

export type TitleWatchlistRecommendationEdge = {
  __typename?: 'TitleWatchlistRecommendationEdge';
  cursor: Scalars['ID']['output'];
  node: TitleWatchlistRecommendation;
};

export type TopGrossingReleasesConnection = {
  __typename?: 'TopGrossingReleasesConnection';
  /** Displayable Box Office area */
  displayableBoxOfficeArea?: Maybe<BoxOfficeAreaType>;
  /** Pages of top grossing releases */
  edges: Array<Maybe<TopGrossingReleasesEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** End date of the specified timeWindow */
  timeWindowEndDate: Scalars['Date']['output'];
  /** Start date of the specified timeWindow */
  timeWindowStartDate: Scalars['Date']['output'];
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type TopGrossingReleasesEdge = {
  __typename?: 'TopGrossingReleasesEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A top grossing release */
  node: TopGrossingReleasesNode;
  /** Position of the release in this context, eg: top grossing release 2 out of 10 */
  position: Scalars['Int']['output'];
};

/**
 * Filter to specify the constraints to use to calculate the grosses.
 * Requesting constraints for which no data is available will return null.
 * Requesting invalid constraints (i.e. a non-existing area) will return an error.
 * Currently only the following are available:
 * - XDOM + LATEST_DAY
 * - XDOM + LATEST_WEEKEND
 * - GB + LATEST_WEEKEND
 */
export type TopGrossingReleasesFilter = {
  /** Time window over which the grosses are calculated */
  timeWindow: TopGrossingReleasesTimeWindow;
  /** Area for which the grosses are calculated */
  topGrossingReleasesArea: BoxOfficeReleasesAreaFilter;
};

export type TopGrossingReleasesNode = {
  __typename?: 'TopGrossingReleasesNode';
  /** Gross of the release according to the specified filter */
  gross: BoxOfficeGross;
  /** Top Grossing Release */
  release: BoxOfficeRelease;
};

export type TopGrossingReleasesTimeWindow = {
  timeWindowPeriod: TopGrossingReleasesTimeWindowPeriod;
};

/**
 * Grosses will be calculated over the specified time window period.
 * LATEST_ means that the period used will be the latest corresponding period for which data is available.
 */
export enum TopGrossingReleasesTimeWindowPeriod {
  LatestDay = 'LATEST_DAY',
  LatestWeekend = 'LATEST_WEEKEND'
}

export enum TopListType {
  All = 'ALL',
  Editorial = 'EDITORIAL'
}

export type TopMeterTitlesFilter = {
  /** Filter titles based on their genre */
  genreId?: InputMaybe<Scalars['String']['input']>;
  /** Movies, TV, or All */
  topMeterTitlesType?: InputMaybe<TopMeterTitlesType>;
};

export enum TopMeterTitlesType {
  /** Movies and TV Series */
  All = 'ALL',
  /** Only Movies */
  Movie = 'MOVIE',
  /** Only TV Series */
  Tv = 'TV'
}

export type TopPicksConnection = {
  __typename?: 'TopPicksConnection';
  edges: Array<Maybe<TopPicksEdge>>;
  pageInfo: PageInfo;
  refTag?: Maybe<RefTag>;
};

export type TopPicksEdge = {
  __typename?: 'TopPicksEdge';
  cursor: Scalars['ID']['output'];
  node: Title;
  position: Scalars['Int']['output'];
};

export type TopRanking = {
  __typename?: 'TopRanking';
  /** A combination of all dimensions of ranking is used to generate an unique id value for each title. */
  id: Scalars['ID']['output'];
  rank: Scalars['Int']['output'];
  /** TODO: There might be changes based on ongoing discussion pertaining to Naming and using DisplaybleConcept */
  text: LocalizedString;
};

export type TopTrendingInput = {
  dataWindow: TrendingDataWindow;
  trafficSource: TrendingTrafficSource;
};

/** Enum exposing all the supported Region Specific Title Trending Sets */
export enum TopTrendingPredefinedEnum {
  /** Trending Set for released Indian Titles based on Global Traffic */
  IndiaTitleTrendsReleased = 'INDIA_TITLE_TRENDS_RELEASED',
  /**
   * Trending Set for released Indian Titles with primary language Tamil
   * based on Global Traffic
   */
  IndiaTitleTrendsReleasedTamil = 'INDIA_TITLE_TRENDS_RELEASED_TAMIL',
  /**
   * Trending Set for released Indian Titles with primary language Telugu
   * based on Global Traffic
   */
  IndiaTitleTrendsReleasedTelugu = 'INDIA_TITLE_TRENDS_RELEASED_TELUGU',
  /** Trending Set for upcoming Indian Titles based on Global Traffic */
  IndiaTitleTrendsUpcoming = 'INDIA_TITLE_TRENDS_UPCOMING'
}

export type TopTrendingSetsPredefinedInput = {
  topTrendingSetPredefined: TopTrendingPredefinedEnum;
};

export type TotalCredits = {
  __typename?: 'TotalCredits';
  /** Restriction related information if exists for credits */
  restriction?: Maybe<CreditRestriction>;
  /** The total number of credits after the restriction is applied */
  total: Scalars['Int']['output'];
};

export type Track = {
  __typename?: 'Track';
  /** Products of Amazon Music for this soundtrack */
  amazonMusicProducts?: Maybe<Array<Maybe<AmazonMusicProduct>>>;
  /** Comments for this track */
  comments?: Maybe<Array<Maybe<Markdown>>>;
  /** The track as a displayable article */
  displayableArticle: DisplayableArticle;
  /** A token representing the track. */
  id: Scalars['ID']['output'];
  /** Optional display text for the track (e.g. 'Danger Zone'). */
  text?: Maybe<Scalars['String']['output']>;
};


export type TrackAmazonMusicProductsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type TrackCommentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type TrackNotificationPreference = {
  __typename?: 'TrackNotificationPreference';
  /** True if requesting customer receives notifications for this preference type */
  interested: Scalars['Boolean']['output'];
  /** Preference type */
  type: TrackNotificationPreferenceType;
};

/** Preference type for a tracked page */
export type TrackNotificationPreferenceType = {
  __typename?: 'TrackNotificationPreferenceType';
  /** Unique identifier for the notification preference type */
  id: Scalars['ID']['output'];
  /** Language of the text */
  language: DisplayableLanguage;
  /** Text describing the notification preference type */
  text: Scalars['String']['output'];
  /** The notification preference type identifier, this value should be used when submitting mutations to trackConst */
  typeId: Scalars['ID']['output'];
};

export type TrackNotificationPreferences = {
  __typename?: 'TrackNotificationPreferences';
  /** Indicates if current user is tracking given const */
  isTracking: Scalars['Boolean']['output'];
  /** The requesting user's notification preferences for this const. */
  notificationPreferences?: Maybe<Array<Maybe<TrackNotificationPreference>>>;
};

export type TrackRecommendationsInput = {
  /** Profession used in query for certain recommendation strategies */
  profession?: InputMaybe<Scalars['String']['input']>;
};

export type TrackedNameEdge = {
  __typename?: 'TrackedNameEdge';
  /** Cursor ID of the tracked name */
  cursor: Scalars['ID']['output'];
  /** A tracked name node */
  node: Name;
  /** Position of the node in this context, e.g. TrackedNameEdge 2 out of 10 */
  position: Scalars['Int']['output'];
};

export type TrackedNamesConnection = {
  __typename?: 'TrackedNamesConnection';
  /** Page of tracked names */
  edges: Array<Maybe<TrackedNameEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of tracked names */
  total: Scalars['Int']['output'];
};

export type TrackedTitleEdge = {
  __typename?: 'TrackedTitleEdge';
  /** Cursor ID of the tracked title */
  cursor: Scalars['ID']['output'];
  /** A tracked title node */
  node: Title;
  /** Position of the node in this context, e.g. TrackedTitleEdge 2 out of 10 */
  position: Scalars['Int']['output'];
};

export type TrackedTitlesConnection = {
  __typename?: 'TrackedTitlesConnection';
  /** Page of tracked titles */
  edges: Array<Maybe<TrackedTitleEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of tracked titles */
  total: Scalars['Int']['output'];
};

export type TrackerConsent = Consent & {
  __typename?: 'TrackerConsent';
  /** Encoded consent token using amazon vendor list. */
  avlTcfString: Scalars['String']['output'];
  /**
   * base64 encoded json representation of the consent information
   * e.g. eyJkZWNpc2lvbiI6ICJBQ0NFUFRfQUxMIiwicHVycG9zZXMiOiBbMSwgMiwgM10sInZlbmRvcnMiOiBbMywgNSwgN119
   *      Decoded: {"decision":"ACCEPT_ALL","is_required":true}
   */
  consentInfo?: Maybe<Scalars['String']['output']>;
  consentOperation: ConsentOperation;
  consentType: ConsentType;
  /** Encoded token for data sharing and cross-use. */
  crossUseString: Scalars['String']['output'];
  expirationDate: Scalars['DateTime']['output'];
  /** Encoded IAB TCFv2 (Transparency and Consent Framework) token. Uses IAB global vendor list. */
  gvlTcfString: Scalars['String']['output'];
  /** Granular purpose-level consent decisions for custom consent */
  purposes?: Maybe<Array<Maybe<GranularConsentRecord>>>;
  /** Granular vendor-level consent decisions for custom consent */
  vendors?: Maybe<Array<Maybe<GranularConsentRecord>>>;
};

export type Trademark = {
  __typename?: 'Trademark';
  /** The trademark as a displayable article */
  displayableArticle?: Maybe<DisplayableArticle>;
  /** Details of the person's trademarks */
  text: Markdown;
};

/** Pagination for Trademarks which always has a known total number of edges. */
export type TrademarkConnection = {
  __typename?: 'TrademarkConnection';
  /** Pages of Trademarks */
  edges: Array<Maybe<TrademarkEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Trademarks */
export type TrademarkEdge = {
  __typename?: 'TrademarkEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** Details of the person's trademark */
  node: Trademark;
  /** Position of the node in this context, eg: Trademark 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type TrendingCollectionOption = {
  __typename?: 'TrendingCollectionOption';
  country: DisplayableCountry;
  dataWindow: TrendingDataWindow;
  trafficSource: TrendingTrafficSource;
};

/**
 * We will throw exception if trending set does not exist, which means that
 * the response will contain an error field with the exception code and the
 * data field set to null
 * https://w.amazon.com/bin/view/IMDb/Trending/#Ranking_Sets
 */
export enum TrendingDataWindow {
  Hours = 'HOURS',
  Minutes = 'MINUTES'
}

export type TrendingNameCollection = {
  __typename?: 'TrendingNameCollection';
  items: TrendingNameConnection;
  option: TrendingCollectionOption;
};


export type TrendingNameCollectionItemsArgs = {
  first: Scalars['Int']['input'];
};

export type TrendingNameCollectionOptions = {
  __typename?: 'TrendingNameCollectionOptions';
  options: Array<Maybe<TrendingCollectionOption>>;
  selectedItem: TrendingNameCollection;
};

export type TrendingNameConnection = {
  __typename?: 'TrendingNameConnection';
  edges: Array<Maybe<TrendingNameEdge>>;
  pageInfo: PageInfo;
};

export type TrendingNameEdge = {
  __typename?: 'TrendingNameEdge';
  cursor: Scalars['ID']['output'];
  node: TrendingNameNode;
};

export type TrendingNameNode = {
  __typename?: 'TrendingNameNode';
  item: Name;
  rank: Scalars['Int']['output'];
  weightRank: Scalars['Int']['output'];
};

export type TrendingTitleCollection = {
  __typename?: 'TrendingTitleCollection';
  items: TrendingTitleConnection;
  option: TrendingCollectionOption;
};


export type TrendingTitleCollectionItemsArgs = {
  first: Scalars['Int']['input'];
};

export type TrendingTitleCollectionOptions = {
  __typename?: 'TrendingTitleCollectionOptions';
  options: Array<Maybe<TrendingCollectionOption>>;
  selectedItem: TrendingTitleCollection;
};

/** Trending schema */
export type TrendingTitleConnection = {
  __typename?: 'TrendingTitleConnection';
  edges: Array<Maybe<TrendingTitleEdge>>;
  pageInfo: PageInfo;
};

export type TrendingTitleEdge = {
  __typename?: 'TrendingTitleEdge';
  cursor: Scalars['ID']['output'];
  node: TrendingTitleNode;
};

export type TrendingTitleNode = {
  __typename?: 'TrendingTitleNode';
  item: Title;
  rank: Scalars['Int']['output'];
  weightRank: Scalars['Int']['output'];
};

/**
 * We will throw exception if trending set does not exist, which means that
 * the response will contain an error field with the exception code and the
 * data field set to null
 * https://w.amazon.com/bin/view/IMDb/Trending/#Ranking_Sets
 * All TrendingTrafficSource values except XWW are deprecated
 */
export enum TrendingTrafficSource {
  Xww = 'XWW'
}

export type TrendingVideoConnection = {
  __typename?: 'TrendingVideoConnection';
  edges: Array<Maybe<TrendingVideoEdge>>;
  pageInfo: PageInfo;
};

export type TrendingVideoEdge = {
  __typename?: 'TrendingVideoEdge';
  cursor: Scalars['ID']['output'];
  node: TrendingVideoNode;
};

export type TrendingVideoNode = {
  __typename?: 'TrendingVideoNode';
  item: Video;
  rank: Scalars['Int']['output'];
  weightRank: Scalars['Int']['output'];
};

/** A category of trivia describing the nature of a subset of trivia, e.g. 'Director Trademark'. Not all trivia has a category. */
export type TriviaCategory = {
  __typename?: 'TriviaCategory';
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

export type TriviaCategoryWithTrivia = {
  __typename?: 'TriviaCategoryWithTrivia';
  category?: Maybe<TriviaCategory>;
  restriction?: Maybe<TriviaRestriction>;
  trivia?: Maybe<TriviaConnection>;
};


export type TriviaCategoryWithTriviaTriviaArgs = {
  filter?: InputMaybe<TriviaCategoryWithTriviaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type TriviaCategoryWithTriviaFilter = {
  spoilers?: InputMaybe<FilterSpoilers>;
};

/** Pagination for Trivia types which always has a known total number of edges. */
export type TriviaConnection = {
  __typename?: 'TriviaConnection';
  /** Pages of Trivia */
  edges: Array<Maybe<TriviaEdge>>;
  /** Details of the page */
  pageInfo: PageInfo;
  /** Details of any applied restriction */
  restriction?: Maybe<TriviaRestriction>;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

/** Page of Trivia */
export type TriviaEdge = {
  __typename?: 'TriviaEdge';
  /** Cursor ID */
  cursor: Scalars['ID']['output'];
  /** A Trivia node */
  node: TitleTrivia;
  /** Position of the node in this context, eg: Trivia 4 out of 31 */
  position: Scalars['Int']['output'];
};

export type TriviaFilter = {
  categories?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  spoilers?: InputMaybe<FilterSpoilers>;
};

/** Information about restrictions applied to trivia */
export type TriviaRestriction = {
  __typename?: 'TriviaRestriction';
  /** Explanation(s) for the restriction */
  explanations: Array<Maybe<RestrictionExplanation>>;
  reasons: Array<Maybe<ContentRestrictionReason>>;
  /** DEPRECATED: Renamed, use `reasons` instead. */
  restrictionReason: Array<Maybe<ContentRestrictionReason>>;
  /** The total number of items if there was no restriction */
  unrestrictedTotal?: Maybe<Scalars['Int']['output']>;
};

export type TwitterLink = {
  __typename?: 'TwitterLink';
  label?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
  /** Twitter username */
  username: Scalars['String']['output'];
};

/** The top-level model for a server-driven UI-based workflow editing experience. */
export type UiWorkflow = {
  __typename?: 'UIWorkflow';
  /** Contains the actions available to display in the action tray */
  actionTray: UiWorkflowActionTray;
  /** Contains the main form elements or menu of options available within this workflow */
  body: UiWorkflowBody;
  /** Contains information about the specific content the customer is affecting in this specific workflow, e.g. 'Add an FAQ' */
  contentHeader: UiWorkflowContentHeader;
  /**
   * Contains information about the subject of the workflow, the context within
   * which the user is taking some action, e.g. a title being edited
   */
  contextHeader: UiWorkflowContextHeader;
  /** Contains any Global Menu controls, if required, such as links to alternative experiences */
  globalMenu?: Maybe<UiWorkflowGlobalMenu>;
  /** Contains information about the current workflow execution state */
  workflowState: UiWorkflowExecutionState;
  /** Indicates the type of operation this workflow is intended for, so that clients can choose appropriate icons etc */
  workflowType: UiWorkflowType;
};

/**
 * Represents an actionable button within a UI workflow.
 * Contains all the necessary information to render and handle a workflow action.
 */
export type UiWorkflowAction = {
  __typename?: 'UIWorkflowAction';
  /** Unique identifier for the action */
  id: Scalars['ID']['output'];
  /** Display text for the action */
  label: LocalizedString;
  /**
   * Specifies the direction of navigation through a workflow when a customer triggers this action. A client
   * can use this field to animate the transition with a horizontal/vertical slide in the direction suggestion,
   * if they wish.
   * If not provided, the action is assumed to have no inherent direction, ie the action leaves the workflow
   * in the same overall state, so clients should not animate the transition beyond showing a loading indicator.
   */
  navigationDirection?: Maybe<UiWorkflowActionNavigationDirection>;
  /** Indicates whether the action needs form data to be submitted in calls to updateUIWorkflow */
  requiresFormData: Scalars['Boolean']['output'];
  /** Visual style and importance level of the action */
  type: UiWorkflowActionType;
};

/**
 * Defines conceptual directions forward or backward through a workflow, to enable clients to
 * animate or provide customers navigational hints as they flow through a workflow by triggering actions.
 */
export enum UiWorkflowActionNavigationDirection {
  /** Moves the workflow backwards towards an earlier state */
  Backward = 'Backward',
  /** Moves the workflow forwards towards a completion state */
  Forward = 'Forward'
}

/**
 * Represents the action tray component of a UI workflow.
 * Contains the available actions that can be performed in the current workflow state.
 */
export type UiWorkflowActionTray = {
  __typename?: 'UIWorkflowActionTray';
  /**
   * The bounded and ordered list of available actions that can be performed in the current workflow state.
   * The number of actions available is not expected to be more than three.
   */
  actions: Array<Maybe<UiWorkflowAction>>;
};

/**
 * Defines the visual hierarchy and importance of workflow actions.
 * Used to determine how actions should be displayed in the UI.
 */
export enum UiWorkflowActionType {
  /** Action to exit or abandon the current workflow */
  Cancel = 'Cancel',
  /** Main action that represents the primary operation */
  Primary = 'Primary',
  /** Supporting actions that represent alternative operations */
  Secondary = 'Secondary'
}

/**
 * Represents the main body content of a UI workflow.
 * Contains an ordered collection of UI elements that form the workflow's content.
 */
export type UiWorkflowBody = {
  __typename?: 'UIWorkflowBody';
  /**
   * The bounded and ordered list of UI elements that make up the workflow's body content.
   * Clients should always show all workflow body elements, and in the order determined by the server, to ensure the
   * workflow is able to be completed correctly. The number of elements is usually less than 5, but a very complex
   * workflow may have more.
   */
  elements: Array<Maybe<UiWorkflowElementOrGroup>>;
};

/** Represents a checkbox form element in the UI workflow. */
export type UiWorkflowCheckboxFormElement = {
  __typename?: 'UIWorkflowCheckboxFormElement';
  /** Optional checkbox constraints */
  checkboxConstraints?: Maybe<CheckboxFieldConstraints>;
  /** The current checkbox 'checked' boolean value */
  checkboxValue: Scalars['Boolean']['output'];
  /**
   * Optional ordered and bound list of feedback messages associated with this form element (typically 0 or 1 entries).
   * Null or 0 entries means there is no feedback to display.
   * Clients must respect the order the feedback is returned in.
   */
  feedback?: Maybe<Array<Maybe<UiWorkflowFeedbackElement>>>;
  /** Optional help link providing additional guidance */
  helpLink?: Maybe<HelpLink>;
  /** Unique identifier for the checkbox */
  id: Scalars['ID']['output'];
  /** The label text to display next to the checkbox */
  label: LocalizedMarkdown;
};

/**
 * Represents the content header section of a UI workflow.
 * Contains the main heading and optional help resources for the workflow.
 */
export type UiWorkflowContentHeader = {
  __typename?: 'UIWorkflowContentHeader';
  /** The heading to display as part of the main content panel and its controls */
  heading: LocalizedMarkdown;
  /** An optional help link to display in the Content Header for the customer to get help */
  helpLink?: Maybe<HelpLink>;
};

/**
 * Represents the context header section of a UI workflow.
 * Provides contextual information about the current workflow being performed.
 */
export type UiWorkflowContextHeader = {
  __typename?: 'UIWorkflowContextHeader';
  /** The heading to display to the customer to contextualize the workflow, such as 'FAQs' or 'New Title'. */
  heading: LocalizedMarkdown;
  /**
   * The subject const of the workflow (optional).
   * In the future we will need to support workflows that create new primaries, so a subject entity will not yet exist.
   */
  subject?: Maybe<UiWorkflowSubject>;
};

/**
 * Union type for all possible UI workflow body elements excluding nested groups.
 * Combines all interactive and display elements that can appear in a workflow body or within a nested group.
 */
export type UiWorkflowElement = UiWorkflowCheckboxFormElement | UiWorkflowFeedbackCheckboxFormElement | UiWorkflowFeedbackDisplayElement | UiWorkflowMarkdownDisplayElement | UiWorkflowMarkdownTextAreaFormElement | UiWorkflowRadioGroupFormElement | UiWorkflowSelectFormElement | UiWorkflowTextAreaFormElement | UiWorkflowTextFormElement | UiWorkflowTitleRatingElement;

/**
 * Represents a group of related UI workflow elements.
 * Allows for logical grouping and organization of form elements.
 */
export type UiWorkflowElementGroup = {
  __typename?: 'UIWorkflowElementGroup';
  /** The ordered and bound list of UI elements contained in this group */
  elements: Array<Maybe<UiWorkflowElement>>;
  /** Optional heading for the group */
  heading?: Maybe<LocalizedMarkdown>;
  /** Optional help link providing additional guidance for this group */
  helpLink?: Maybe<HelpLink>;
  /** Unique identifier for the element group */
  id: Scalars['ID']['output'];
};

/** Union type for all possible UI workflow body elements including nested groups. */
export type UiWorkflowElementOrGroup = UiWorkflowCheckboxFormElement | UiWorkflowElementGroup | UiWorkflowFeedbackCheckboxFormElement | UiWorkflowFeedbackDisplayElement | UiWorkflowMarkdownDisplayElement | UiWorkflowMarkdownTextAreaFormElement | UiWorkflowRadioGroupFormElement | UiWorkflowSelectFormElement | UiWorkflowTextAreaFormElement | UiWorkflowTextFormElement | UiWorkflowTitleRatingElement;

export type UiWorkflowExecutionState = {
  __typename?: 'UIWorkflowExecutionState';
  /** A globally unique ID for a customer's specific run through the chosen server-driven workflow */
  executionId: Scalars['ID']['output'];
  /** A globally unique ID for the most recent interaction/request regarding this workflow execution */
  interactionId: Scalars['ID']['output'];
  /** A debug-friendly string describing the current status of the server-driven workflow being run */
  status: Scalars['String']['output'];
  /** A canonical ID assigned to the server-driven UI workflow the customer is interacting with */
  workflowId: Scalars['ID']['output'];
};

/**
 * Represents an element to display in the UI workflow body containing feedback that requires checking of a box by the
 * customer to acknowledge the feedback. The current checked or unchecked state is provided within the booleanValue field.
 */
export type UiWorkflowFeedbackCheckboxFormElement = {
  __typename?: 'UIWorkflowFeedbackCheckboxFormElement';
  /** Current checked or unchecked state of the acknowledgement checkbox */
  checkboxValue: Scalars['Boolean']['output'];
  /** Feedback to show the customer */
  feedback: ValidationFeedbackGroup;
  /** Optional help link providing additional guidance */
  helpLink?: Maybe<HelpLink>;
  /** Unique identifier for the feedback element */
  id: Scalars['ID']['output'];
  /** Label to show the customer alongside the acknowledgement checkbox */
  label: LocalizedMarkdown;
};

/** Represents an element to display in the UI workflow body containing feedback about the customer's workflow. */
export type UiWorkflowFeedbackDisplayElement = {
  __typename?: 'UIWorkflowFeedbackDisplayElement';
  /** Feedback about the customer's content */
  feedback: ValidationFeedbackGroup;
  /** Unique identifier for the feedback element */
  id: Scalars['ID']['output'];
};

/**
 * Union type for all possible feedback elements in the UI workflow.
 * Combines both interactive and display-only feedback elements.
 */
export type UiWorkflowFeedbackElement = UiWorkflowFeedbackCheckboxFormElement | UiWorkflowFeedbackDisplayElement;

/**
 * Represents the global menu structure for the UI workflow system.
 * Contains navigation items that appear in the global header.
 */
export type UiWorkflowGlobalMenu = {
  __typename?: 'UIWorkflowGlobalMenu';
  /**
   * Bounded list of menu items to show in the global header.
   * Number of items is not expected to grow beyond just a few entries.
   */
  menuItems: Array<Maybe<UiWorkflowGlobalMenuItem>>;
};

/** The set of possible menu item entry types */
export type UiWorkflowGlobalMenuItem = UiWorkflowGlobalMenuItemLink;

export type UiWorkflowGlobalMenuItemLink = {
  __typename?: 'UIWorkflowGlobalMenuItemLink';
  /** The localized label for the link */
  label: LocalizedString;
  /** The type of link, such as navigation */
  linkType: UiWorkflowGlobalMenuItemLinkType;
  /** The target URL for the link */
  url: Scalars['URL']['output'];
};

/**
 * The set of possible menu item link types, used to enable clients to show different icons or choose different targets.
 * We only need Navigation right now, but in the future we anticipate both external links and download link types.
 */
export enum UiWorkflowGlobalMenuItemLinkType {
  Navigation = 'Navigation'
}

/**
 * Represents a localized string for an input option in a multi-option form component such as a dropdown menu
 * or a radio button group.
 */
export type UiWorkflowLocalizedStringInputOption = {
  __typename?: 'UIWorkflowLocalizedStringInputOption';
  /** The text to display for this option in the form element */
  text: LocalizedString;
  /** The value to set for the form element if this option is chosen by the customer */
  value: Scalars['String']['output'];
};

/** Represents a block of markdown text to display within the body of UI workflow form. */
export type UiWorkflowMarkdownDisplayElement = {
  __typename?: 'UIWorkflowMarkdownDisplayElement';
  /** Unique identifier for the element */
  id: Scalars['ID']['output'];
  /** The markdown content to display */
  markdown: LocalizedMarkdown;
};

/** Represents a markdown-enabled text area input form element in the UI workflow. */
export type UiWorkflowMarkdownTextAreaFormElement = {
  __typename?: 'UIWorkflowMarkdownTextAreaFormElement';
  /**
   * Optional ordered and bound list of feedback messages associated with this form element (typically 0 or 1 entries).
   * Null or 0 entries means there is no feedback to display.
   * Clients must respect the order the feedback is returned in.
   */
  feedback?: Maybe<Array<Maybe<UiWorkflowFeedbackElement>>>;
  /** Optional help link providing additional guidance */
  helpLink?: Maybe<HelpLink>;
  /** Unique identifier for the text input */
  id: Scalars['ID']['output'];
  /** The label text to display above the text input */
  label: LocalizedMarkdown;
  /** Optional validation constraints for the markdown text area input */
  markdownTextAreaConstraints?: Maybe<MarkdownTextAreaFieldConstraints>;
  /** The current markdown text area value, if present */
  markdownTextAreaValue?: Maybe<Markdown>;
};

/** Represents a radio button group form element in a UI workflow. */
export type UiWorkflowRadioGroupFormElement = {
  __typename?: 'UIWorkflowRadioGroupFormElement';
  /**
   * Optional ordered and bound list of feedback messages associated with this form element (typically 0 or 1 entries).
   * Null or 0 entries means there is no feedback to display.
   * Clients must respect the order the feedback is returned in.
   */
  feedback?: Maybe<Array<Maybe<UiWorkflowFeedbackElement>>>;
  /** Optional help link providing additional guidance */
  helpLink?: Maybe<HelpLink>;
  /** Unique identifier for the form element */
  id: Scalars['ID']['output'];
  /** The label text to display for this radio group element */
  label: LocalizedMarkdown;
  /** Optional validation constraints for this radio group */
  radioGroupConstraints?: Maybe<RadioGroupFieldConstraints>;
  /** The available radio button options */
  radioGroupOptions: Array<Maybe<UiWorkflowRadioOption>>;
  /** The value of the currently selected radio button option, if present */
  radioGroupValue?: Maybe<Scalars['String']['output']>;
};

/**
 * The set of possible radio group option types. Currently just one is available, but in the future we anticipate
 * Title, Name and Company-entity option types, so using a Union for extensibility.
 */
export type UiWorkflowRadioOption = UiWorkflowLocalizedStringInputOption;

/** Represents a select dropdown form element in a UI workflow. */
export type UiWorkflowSelectFormElement = {
  __typename?: 'UIWorkflowSelectFormElement';
  /**
   * Optional ordered and bound list of feedback messages associated with this form element (typically 0 or 1 entries).
   * Null or 0 entries means there is no feedback to display.
   * Clients must respect the order the feedback is returned in.
   */
  feedback?: Maybe<Array<Maybe<UiWorkflowFeedbackElement>>>;
  /** Optional help link providing additional guidance */
  helpLink?: Maybe<HelpLink>;
  /** Unique identifier for the form element */
  id: Scalars['ID']['output'];
  /** The label text to display for this select dropdown element */
  label: LocalizedMarkdown;
  /** Optional validation constraints for this select dropdown */
  selectConstraints?: Maybe<SelectFieldConstraints>;
  /** The available options a customer can select from */
  selectOptions: Array<Maybe<UiWorkflowSelectOption>>;
  /** The value of the currently selected option, if present */
  selectValue?: Maybe<Scalars['String']['output']>;
};

/**
 * The set of possible select option types. Currently just one is available, but in the future we anticipate
 * Title, Name and Company-entity option types, so using a Union for extensibility.
 */
export type UiWorkflowSelectOption = UiWorkflowLocalizedStringInputOption;

/** The set of possible workflow subjects */
export type UiWorkflowSubject = Company | Name | Title;

/** Represents a text area input form element in the UI workflow. */
export type UiWorkflowTextAreaFormElement = {
  __typename?: 'UIWorkflowTextAreaFormElement';
  /**
   * Optional ordered and bound list of feedback messages associated with this form element (typically 0 or 1 entries).
   * Null or 0 entries means there is no feedback to display.
   * Clients must respect the order the feedback is returned in.
   */
  feedback?: Maybe<Array<Maybe<UiWorkflowFeedbackElement>>>;
  /** Optional help link providing additional guidance */
  helpLink?: Maybe<HelpLink>;
  /** Unique identifier for the text input */
  id: Scalars['ID']['output'];
  /** The label text to display above the text input */
  label: LocalizedMarkdown;
  /** Optional validation constraints for the text area input */
  textAreaConstraints?: Maybe<TextAreaFieldConstraints>;
  /** The current text area value, if present */
  textAreaValue?: Maybe<Scalars['String']['output']>;
};

/** Represents a text input form element in the UI workflow. */
export type UiWorkflowTextFormElement = {
  __typename?: 'UIWorkflowTextFormElement';
  /**
   * Optional ordered and bound list of feedback messages associated with this form element (typically 0 or 1 entries).
   * Null or 0 entries means there is no feedback to display.
   * Clients must respect the order the feedback is returned in.
   */
  feedback?: Maybe<Array<Maybe<UiWorkflowFeedbackElement>>>;
  /** Optional help link providing additional guidance */
  helpLink?: Maybe<HelpLink>;
  /** Unique identifier for the text input */
  id: Scalars['ID']['output'];
  /** The label text to display above the text input */
  label: LocalizedMarkdown;
  /** Optional validation constraints for the text input */
  textConstraints?: Maybe<TextFieldConstraints>;
  /** The current text value, if present */
  textValue?: Maybe<Scalars['String']['output']>;
};

/**
 * Represents an element in the form to let a customer rate the title specified.
 * Clients are expected to use their idiomatic title rating control and to make calls to update the customer's
 * rating on-demand rather than treat this as part of a larger workflow form submission.
 */
export type UiWorkflowTitleRatingElement = {
  __typename?: 'UIWorkflowTitleRatingElement';
  /** Unique identifier for the rating element */
  id: Scalars['ID']['output'];
  /** The title being rated */
  title: Title;
};

/**
 * The set of available workflow types.
 * TODO: Move to common types package after review for re-use in other graphlets for CTA vending
 */
export enum UiWorkflowType {
  Add = 'Add',
  Delete = 'Delete',
  Edit = 'Edit',
  Report = 'Report'
}

export enum UnknownReleaseDateFilter {
  ExcludeUnknown = 'EXCLUDE_UNKNOWN',
  /** If UNKNOWN_ONLY is used with releasedOnOrBefore or releasedOnOrAfter filters then an empty array will be returned. */
  UnknownOnly = 'UNKNOWN_ONLY'
}

export type UpdateUserProfileFeedback = {
  __typename?: 'UpdateUserProfileFeedback';
  /**
   * Validation feedback on a user's profile update.
   * Null is returned when there is no validationFeedback.
   */
  validationFeedback?: Maybe<ValidationFeedback>;
};

/**
 * User Type available only for authenticated users
 * Includes private info.
 * Also includes public info in profile field.
 * Includes optional ProStatus and StaffStatus fields.
 */
export type User = {
  __typename?: 'User';
  /** User's first name, or nickname if no first name was provided */
  displayName: Scalars['String']['output'];
  /** Returns whether the user has given feedback for that particular feature */
  feedbackGiven: FeedbackGiven;
  /** User's full name, or empty string if no name provided */
  fullName: Scalars['String']['output'];
  /** Returns the current user's list of interests. Currently only 50 interests can be stored. */
  interests: UserInterestsConnection;
  /** Returns if account is Amazon Account Pool (AAP) account or already converted to AAP account. */
  isAmazonAccount: Scalars['Boolean']['output'];
  /** Returns the linked providers available for the authenticated customer. */
  linkedAuthProviders: Array<Maybe<LinkedAuthProvider>>;
  /**
   * A setting of the users preferred language, composed of ISO 369-1 code dash ISO 3166-1/UN M.49 code
   * or null if no such preferred language is defined.
   */
  preferredLanguage?: Maybe<Scalars['String']['output']>;
  /** Returns the list of watch providers of user */
  preferredStreamingProviders: UserPreferredStreamingProvidersOutput;
  proStatus?: Maybe<ProStatus>;
  profile: UserProfile;
  /** Returns the current user's ratings privacy setting. */
  ratingsPrivacy?: Maybe<RatingsPrivacy>;
  /** If staffStatus is null, the user account is not marked as staff */
  staffStatus?: Maybe<StaffStatus>;
  /** Returns the current user's title display settings. */
  titleDisplay: TitleDisplayOutput;
};


/**
 * User Type available only for authenticated users
 * Includes private info.
 * Also includes public info in profile field.
 * Includes optional ProStatus and StaffStatus fields.
 */
export type UserFeedbackGivenArgs = {
  input: FeedbackGivenInput;
};


/**
 * User Type available only for authenticated users
 * Includes private info.
 * Also includes public info in profile field.
 * Includes optional ProStatus and StaffStatus fields.
 */
export type UserInterestsArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<UserInterestsFilter>;
  first: Scalars['Int']['input'];
};


/**
 * User Type available only for authenticated users
 * Includes private info.
 * Also includes public info in profile field.
 * Includes optional ProStatus and StaffStatus fields.
 */
export type UserPreferredStreamingProvidersArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<UserPreferredStreamingProvidersInput>;
  first: Scalars['Int']['input'];
};

export type UserBadgesInput = {
  /**
   * Returns badges for a specific user if included.
   * Defaults to the current authenticated user based on the x-imdb-customer-id header if omitted.
   * When userId is provided the data can be cached.
   * Throws UNAUTHENTICATED if neither is provided.
   */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum UserCategory {
  ImdbUsers = 'IMDB_USERS',
  Top_1000Voters = 'TOP_1000_VOTERS'
}

export type UserConsentInput = {
  /** The type of consent a user has opted in or out of. */
  consentType: ConsentType;
  /**
   * Mobile ID For Advertising, for requests coming from apps.
   * Used for the THIRD_PARTY_DATA_SHARING consent.
   */
  idfa?: InputMaybe<Scalars['String']['input']>;
};

export type UserConsentOutput = {
  __typename?: 'UserConsentOutput';
  /** Detailed consent information. */
  consent?: Maybe<Consent>;
  /**
   * Whether the user has opted in or out of the consent.
   * Is a required return field for all but TRACKING_COOKIE consent operations
   */
  consentOperation?: Maybe<ConsentOperation>;
  /** The type of consent a user has opted in or out of. */
  consentType: ConsentType;
};

export type UserInterestsConnection = {
  __typename?: 'UserInterestsConnection';
  edges: Array<Maybe<InterestEdge>>;
  pageInfo: PageInfo;
  /** The total number of objects in this set */
  total: Scalars['Int']['output'];
};

export type UserInterestsFilter = {
  includeInterestIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type UserLinkedAuthProviderStatusesInput = {
  /** URL customer will return to after linking/unlinking with a provider. Defaults to third party links page if omitted */
  returnURL?: InputMaybe<Scalars['URL']['input']>;
};

export type UserLinkedAuthProviderStatusesOutput = {
  __typename?: 'UserLinkedAuthProviderStatusesOutput';
  providers: Array<Maybe<AuthProviderStatus>>;
};

/** Entity type of a single notification in the Notification Center. */
export type UserNotification = {
  __typename?: 'UserNotification';
  /** Header text of the notification. Could be the notification type like Now Streaming, New Trailer. */
  header: LocalizedString;
  /** Unique id of the notification returned from Notification Service. */
  id: Scalars['ID']['output'];
  /** Attached image of the notification. Returns null if it does not have an image (e.g., system notification). */
  image?: Maybe<MediaServiceImage>;
  /** Last updated time of the notification. */
  lastUpdated: Scalars['DateTime']['output'];
  /** Main content of the notification. e.g., XXX from your watchlist is streaming on YYY. */
  primaryContent: LocalizedMarkdown;
  /** Secondary text of the notification, e.g., Because you followed XXX. Returns null if it has no value. */
  secondaryContent?: Maybe<LocalizedString>;
  /** URL deep link/navigate to when the notification is clicked. Returns null if it has no link. */
  url?: Maybe<Scalars['URL']['output']>;
};

/** Pagination for notifications, which always has a known total number of edges. */
export type UserNotificationConnection = {
  __typename?: 'UserNotificationConnection';
  /** A page of notifications. */
  edges: Array<Maybe<UserNotificationEdge>>;
  /** Details of the page. */
  pageInfo: PageInfo;
  /** Total number of notifications in the entire set. */
  total: Scalars['Int']['output'];
};

/** Item in a page of notifications. */
export type UserNotificationEdge = {
  __typename?: 'UserNotificationEdge';
  /** Cursor ID. */
  cursor: Scalars['ID']['output'];
  /** A notification node. */
  node: UserNotification;
  /** Position of this item in this context. */
  position: Scalars['Int']['output'];
};

export enum UserNotificationsSortBy {
  /**
   * Sort notifications based on their last updated time.
   * DESC: Latest dates to earliest dates.
   */
  LastUpdated = 'LAST_UPDATED'
}

export type UserNotificationsSortOrder = {
  by: UserNotificationsSortBy;
  order: SortOrder;
};

export type UserPreferredStreamingProvidersInput = {
  /** We can know whether particular streaming provider exists in the users list */
  includeFilter?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type UserPreferredStreamingProvidersOutput = {
  __typename?: 'UserPreferredStreamingProvidersOutput';
  streamingProviders: WatchProviderConnection;
  /** Returns the total number of streaming providers stored */
  total: Scalars['Int']['output'];
};

/**
 * User type
 * Extends external type.
 */
export type UserProfile = {
  __typename?: 'UserProfile';
  /**
   * The user's profile biography
   *
   * ---------------------
   * Graphlet Details:
   * - Name: userProfile
   * - CTI: IMDb/GraphQL/UserProfile
   * - Affected by headers: x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  bio?: Maybe<UserProfileBio>;
  /**
   * The date that this IMDb User Profile was created.
   * There are some active users whose accounts do not have a creation date. Field will return null response for those cases.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  creationDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The user's profile primary image
   *
   * ---------------------
   * Graphlet Details:
   * - Name: userProfile
   * - CTI: IMDb/GraphQL/UserProfile
   * - Affected by headers: x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  primaryImage?: Maybe<UserProfileImage>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: contributor
   * - CTI: IMDb/GraphQL/Contributor
   * - Affected by headers: x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-contributors-tech
   */
  userId: Scalars['ID']['output'];
  /**
   * The user's profile username aka nickname
   *
   * ---------------------
   * Graphlet Details:
   * - Name: userProfile
   * - CTI: IMDb/GraphQL/UserProfile
   * - Affected by headers: x-imdb-client-name, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  username?: Maybe<UserProfileUsername>;
};

export type UserProfileBio = {
  __typename?: 'UserProfileBio';
  /**
   * The status of any PENDING or REJECTED updates to a user's profile bio when a user is viewing their own profile.
   * This will return null if a user is not logged in OR if a logged in user is viewing someone else's profile.
   */
  status?: Maybe<UserProfileBioUpdateStatus>;
  /**
   * When a user is viewing someone else's profile this will return the live published profile bio aka the most recently
   * ACCEPTED update.
   *
   * When a user is logged in AND viewing their own profile AND they have a PENDING update this will return the pending
   * profile bio, otherwise this will return the live published profile bio.
   */
  text?: Maybe<Markdown>;
};

export type UserProfileBioUpdateStatus = {
  __typename?: 'UserProfileBioUpdateStatus';
  /** A UTC timestamp of when the user profile bio update status was most recently updated */
  lastUpdated?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The user profile bio submitted for update.
   *
   * This field will always be returned as part of the mutation response as well as when the updateStatus is PENDING.
   */
  modifiedItem?: Maybe<Markdown>;
  /** Feedback regarding the user profile bio update */
  updateFeedback?: Maybe<Array<Maybe<UpdateUserProfileFeedback>>>;
  /** The status of the user profile bio update. */
  updateStatus: UserProfileUpdateStatus;
};

export type UserProfileImage = {
  __typename?: 'UserProfileImage';
  /**
   * When a user is viewing someone else's profile this will return the live published profile image aka the most
   * recently ACCEPTED update.
   *
   * When a user is logged in AND viewing their own profile AND they have a PENDING update this will return the pending
   * profile image, otherwise this will return the live published profile image.
   */
  image?: Maybe<Image>;
  /**
   * The status of any PENDING or REJECTED updates to a user's profile image when a user is viewing their own profile.
   * This will return null if a user is not logged in OR if a logged in user is viewing someone else's profile.
   */
  status?: Maybe<UserProfileImageUpdateStatus>;
};

export type UserProfileImageUpdateStatus = {
  __typename?: 'UserProfileImageUpdateStatus';
  /** A UTC timestamp of when the user profile image update status was most recently updated */
  lastUpdated?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The user profile image submitted for update.
   *
   * This field will only be returned as part of the mutation response when the updateStatus is ACCEPTED or PENDING.
   * When the updateStatus is REJECTED, modifiedItem will be null
   */
  modifiedItem?: Maybe<Image>;
  /** Feedback regarding the user profile image update */
  updateFeedback?: Maybe<Array<Maybe<UpdateUserProfileFeedback>>>;
  /** The status of the user profile image update */
  updateStatus: UserProfileUpdateStatus;
};

export type UserProfileInput = {
  /** Optional userId input to fetch a user's profile. Defaults to the current authenticated user when no userId is provided. */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

/** Possible statuses for a UserProfile update */
export enum UserProfileUpdateStatus {
  Accepted = 'ACCEPTED',
  Pending = 'PENDING',
  Rejected = 'REJECTED'
}

export type UserProfileUsername = {
  __typename?: 'UserProfileUsername';
  /**
   * The status of any PENDING or REJECTED updates to a user's profile bio when a user is viewing their own profile.
   * This will return null if a user is not logged in OR if a logged in user is viewing someone else's profile.
   */
  status?: Maybe<UserProfileUsernameUpdateStatus>;
  /**
   * When a user is viewing someone else's profile this will return the live published username aka the most recently
   * ACCEPTED update.
   *
   * When a user is logged in AND viewing their own profile AND they have a PENDING update this will return the pending
   * username, otherwise this will return the live published username.
   *
   * Null is returned when a user has no username.
   */
  text?: Maybe<Scalars['String']['output']>;
};

export type UserProfileUsernameUpdateStatus = {
  __typename?: 'UserProfileUsernameUpdateStatus';
  /** A UTC timestamp of when the user profile username update status was most recently updated */
  lastUpdated?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The user profile username submitted for update.
   *
   * This field will always be returned as part of the mutation response as well as when the updateStatus is PENDING.
   */
  modifiedItem?: Maybe<Scalars['String']['output']>;
  /** Feedback regarding the user profile username update */
  updateFeedback?: Maybe<Array<Maybe<UpdateUserProfileFeedback>>>;
  /** The status of the user profile username update. */
  updateStatus: UserProfileUpdateStatus;
};

export type UserRatingsSearchConstraint = {
  /** Match titles based on their weighted IMDb star rating */
  aggregateRatingRange?: InputMaybe<FloatRangeInput>;
  /** Match titles based on the number of user ratings they have received */
  ratingsCountRange?: InputMaybe<IntRangeInput>;
};

/** Defines a reaction made by a user */
export type UserReaction = {
  __typename?: 'UserReaction';
  /** The entity id that the user reacted upon, e.g. a viconst */
  entityId: Scalars['ID']['output'];
  /** Timestamp of when the user last performed this reaction on an entity */
  lastUpdated: Scalars['DateTime']['output'];
  /** The user's reaction */
  reaction: Reaction;
};

export type UserReviewsInput = {
  /** Optional Reviews filter */
  filter?: InputMaybe<ReviewsFilter>;
  /** Defaults to most recent sort (sortBy: SUBMISSION_DATE sortOrder: DESC) */
  sort?: InputMaybe<UserReviewsSort>;
  /**
   * Optional userId input to fetch a user's reviews.
   * Fall back to the requesting customerId (x-imdb-customer-id header) if input is missing.
   * Throws BAD_USER_INPUT if userId is invalid.
   * Throws UNAUTHENTICATED if both requesting customerId header and userId input are missing.
   */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type UserReviewsSort = {
  by: UserReviewsSortBy;
  order: SortOrder;
};

export enum UserReviewsSortBy {
  /** Title text */
  AlphabeticalTitle = 'ALPHABETICAL_TITLE',
  /** Helpfulness score of review based on up/down votes */
  HelpfulnessScore = 'HELPFULNESS_SCORE',
  /** Date of review submission */
  SubmissionDate = 'SUBMISSION_DATE',
  /** Total vote count */
  TotalVotes = 'TOTAL_VOTES',
  /** Author's rating on review */
  UserRating = 'USER_RATING'
}

/** The role of of a user modifying the known for for consumption by IMDb admins */
export enum UserRole {
  /** A staff administrator role */
  Admin = 'ADMIN',
  /** A customer role */
  Customer = 'CUSTOMER'
}

export type UserWatchedTitlesInput = {
  /** Default to sort by first watched date in descending order. */
  sort?: InputMaybe<UserWatchedTitlesSort>;
};

export type UserWatchedTitlesSort = {
  by: WatchedTitlesSortBy;
  order: SortOrder;
};

export type ValidationFeedback = {
  __typename?: 'ValidationFeedback';
  /** Localized message of validation feedback, providing further detail for the user */
  message?: Maybe<LocalizedMarkdown>;
  /** Status of the validation feedback */
  status: ValidationFeedbackStatus;
  /**
   * Localized displayable title for validation feedback.
   * Null is returned when there is no detailed message.
   */
  title: LocalizedMarkdown;
};

/** Represents the localized feedback content to be displayed to the customer within a given feedback dialog/alert */
export type ValidationFeedbackContent = {
  __typename?: 'ValidationFeedbackContent';
  /**
   * An optional help link, to provide additional guidance to customers on how to deal with this specific feedback.
   * Not all validation messages will have a dedicated help link available.
   */
  helpLink?: Maybe<HelpLink>;
  /**
   * Localized message of validation feedback, providing further detail for the user.
   * Null is returned when there is no detailed message.
   */
  message?: Maybe<LocalizedMarkdown>;
  /** Localized displayable title for validation feedback. */
  title: LocalizedMarkdown;
};

/**
 * Represents multiple validation feedback messages of the same status/severity level.
 * Enables clients to more easily aggregate/group a list of related messages under the same message dialog/alert.
 */
export type ValidationFeedbackGroup = {
  __typename?: 'ValidationFeedbackGroup';
  /**
   * Bounded, ordered list of feedback messages sharing the same status, to show the customer.
   * Should never be more than a few feedback messages.
   */
  feedbackItems: Array<Maybe<ValidationFeedbackContent>>;
  /** The common status for all feedback messages in this group */
  status: ValidationFeedbackStatus;
};

/**
 * Possible statuses for returning validation feedback to a user. These may be mapped to visual icons displayed to a user
 * to help describe the feedback.
 */
export enum ValidationFeedbackStatus {
  Error = 'ERROR',
  Information = 'INFORMATION',
  Warning = 'WARNING'
}

export type VanityUrl = {
  __typename?: 'VanityUrl';
  label?: Maybe<Scalars['String']['output']>;
  /** The name page associated with this vanity URL */
  name: Name;
  /** The full vanity URL, e.g. https://imdb.me/abc */
  url: Scalars['String']['output'];
  /**
   * The path of the vanity URL excluding the leading slash.
   * For example, if full vanity URL is 'https://imdb.me/abc', then 'urlPath' will be 'abc'.
   */
  urlPath: Scalars['String']['output'];
};

/**
 * Video type
 * Extends external type.
 */
export type Video = {
  __typename?: 'Video';
  /**
   * Fetches the ad URL for a video ad on app clients
   *
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  appAdURL?: Maybe<Scalars['URL']['output']>;
  /**
   * Fetches the ad URL for a video ad on app clients
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  appAdURLV2?: Maybe<Scalars['URL']['output']>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  contentType?: Maybe<VideoContentType>;
  /**
   * The date the video was uploaded. Not all videos may have the createdDate datum.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  createdDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  description?: Maybe<LocalizedString>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  id: Scalars['ID']['output'];
  /**
   * Whether this video contains content inappropriate for more sensitive viewers
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  isMature: Scalars['Boolean']['output'];
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  name: LocalizedString;
  /**
   * Personalized suggested videos for a given videoId. Unique per user. Limit of 50.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: personalization
   * - CTI: IMDb/GraphQL/Personalized Picks
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: 0 seconds
   * - Slack Channel: #imdb-pwr-public
   */
  personalizedSuggestedVideos?: Maybe<PersonalizedSuggestedVideosConnection>;
  /**
   * The URLs that can be used by video players to playback the content of the video.
   * This is a very finite set of known encodings thus there is no pagination available
   * to the caller, but if the caller only supports a particular mime type(s) or
   * resolution(s) it can filter to those criteria.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: videoPlayback
   * - CTI: IMDb/GraphQL/Video Playback
   * - Affected by headers: x-imdb-detected-country
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-community-and-video
   */
  playbackURLs: Array<Maybe<PlaybackUrl>>;
  /**
   * The URLs containing the preview manifest of the video.
   * Currently the list will only have HLS preview manifest.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: videoPlayback
   * - CTI: IMDb/GraphQL/Video Playback
   * - Affected by headers: x-imdb-detected-country
   * - Cache TTL: 900 seconds
   * - Slack Channel: #imdb-community-and-video
   */
  previewURLs: Array<Maybe<PlaybackUrl>>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  primaryTitle?: Maybe<Title>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  providerType: VideoProviderType;
  /**
   * Cacheable
   * Sorted by aggregate count, descending
   * Vends the list of the current reactions, and their associated counts, for this entity
   *
   * ---------------------
   * Graphlet Details:
   * - Name: reactions
   * - CTI: IMDb/GraphQL/Reactions
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-video
   */
  reactionsSummary?: Maybe<ReactionsSummary>;
  /**
   * Returns a recommended VideoTimedTextTrack for a given videoId. To be used in situations clients want to display a
   * VideoTimedTextTrack but a user hasn't made an explicit language selection (ex. auto-play). The recommended
   * VideoTimedTextTrack is determined using the header x-imdb-user-language and criteria defined by business.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  recommendedTimedTextTrack?: Maybe<VideoTimedTextTrack>;
  /**
   * Names related to the given video. Results capped to first 100
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  relatedNames?: Maybe<VideoNameRelationConnection>;
  /**
   * Titles related to the given video. Results capped to first 100
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  relatedTitles?: Maybe<VideoTitleRelationConnection>;
  /**
   * Videos related to the current video. The results will be capped to 100.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  relatedVideos?: Maybe<VideoConnection>;
  /**
   * Runtime is required for vi consts but not for vc consts
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  runtime?: Maybe<VideoRuntime>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  thumbnail: Thumbnail;
  /**
   * Returns a list of available VideoTimedTextTracks for a given videoId, sorted alphabetically.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  timedTextTracks?: Maybe<Array<Maybe<VideoTimedTextTrack>>>;
  /**
   * Not cacheable
   * Sorted by most recently reacted
   * Vends the list of reactions the user has already provided
   * Requires the x-imdb-customer-id header from a logged-in user
   *
   * ---------------------
   * Graphlet Details:
   * - Name: reactions
   * - CTI: IMDb/GraphQL/Reactions
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-imdb-detected-country, x-imdb-user-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-video
   */
  userReactions?: Maybe<Array<Maybe<UserReaction>>>;
  /**
   * Dimension sizing information for this video
   *
   * ---------------------
   * Graphlet Details:
   * - Name: video
   * - CTI: IMDb/GraphQL/Video
   * - Affected by headers: x-imdb-detected-country, x-imdb-adsystem-overrides, x-imdb-user-language, x-imdb-client-name
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-community-and-video
   */
  videoDimensions?: Maybe<VideoDimensions>;
  /**
   * Fetches the ad URL for a video ad on web (desktop and mobile web) clients
   *
   * ---------------------
   * Graphlet Details:
   * - Name: adsProvider
   * - CTI: IMDb/GraphQL/Advertising Provider
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  webAdURL?: Maybe<Scalars['URL']['output']>;
  /**
   * Fetches the ad URL for a video ad on web (desktop and mobile web) clients
   *
   * ---------------------
   * Graphlet Details:
   * - Name: advertising
   * - CTI: IMDb/GraphQL/Advertising
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-adsystem-overrides, x-imdb-client-ip, x-imdb-client-name, x-imdb-client-version, x-imdb-consent-info, x-imdb-detected-country, x-imdb-user-language, user-agent
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-adtech-public
   */
  webAdURLV2?: Maybe<Scalars['URL']['output']>;
};


/**
 * Video type
 * Extends external type.
 */
export type VideoAppAdUrlArgs = {
  adParameters: AdParametersApp;
};


/**
 * Video type
 * Extends external type.
 */
export type VideoAppAdUrlv2Args = {
  adParameters: AdParametersApp;
};


/**
 * Video type
 * Extends external type.
 */
export type VideoPersonalizedSuggestedVideosArgs = {
  after?: InputMaybe<Scalars['ID']['input']>;
  first: Scalars['Int']['input'];
};


/**
 * Video type
 * Extends external type.
 */
export type VideoPlaybackUrLsArgs = {
  filter?: InputMaybe<VideoContentFilter>;
};


/**
 * Video type
 * Extends external type.
 */
export type VideoRecommendedTimedTextTrackArgs = {
  filter?: InputMaybe<RecommendedVideoTimedTextTrackFilter>;
};


/**
 * Video type
 * Extends external type.
 */
export type VideoRelatedNamesArgs = {
  first: Scalars['Int']['input'];
};


/**
 * Video type
 * Extends external type.
 */
export type VideoRelatedTitlesArgs = {
  first: Scalars['Int']['input'];
};


/**
 * Video type
 * Extends external type.
 */
export type VideoRelatedVideosArgs = {
  first: Scalars['Int']['input'];
};


/**
 * Video type
 * Extends external type.
 */
export type VideoTimedTextTracksArgs = {
  filter?: InputMaybe<VideoTimedTextTracksFilter>;
};


/**
 * Video type
 * Extends external type.
 */
export type VideoWebAdUrlArgs = {
  adParameters: AdParametersWeb;
};


/**
 * Video type
 * Extends external type.
 */
export type VideoWebAdUrlv2Args = {
  adParameters: AdParametersWeb;
};

/** Parameters used to construct an ad feedback URL for a video ad */
export type VideoAdFeedbackUrlInput = {
  /** The video ad in XML format for which an ad feedback URL is requested. */
  videoAdXml: Scalars['String']['input'];
};

export enum VideoAppearance {
  Horizontal = 'HORIZONTAL',
  Square = 'SQUARE',
  Vertical = 'VERTICAL'
}

export type VideoConnection = {
  __typename?: 'VideoConnection';
  /** List of videos */
  edges: Array<Maybe<VideoEdge>>;
  /** Indicates the possible video facets available for filtering on. */
  facets?: Maybe<VideoFacets>;
  /** Additional information useful for pagination */
  pageInfo: PageInfo;
  /** Total number of videos that fit the selection criteria. */
  total: Scalars['Int']['output'];
};

/** Allows for the caller to specify the mime types and/or definitions that should be included */
export type VideoContentFilter = {
  /** The list of definitions to include URLs for. Note that M3U8 does not support any definitions. */
  definitions?: InputMaybe<Array<InputMaybe<VideoDefinition>>>;
  /** The list of mime types to include URLs for. Note that M3U8 does not support any definitions. */
  mimeTypes?: InputMaybe<Array<InputMaybe<VideoMimeType>>>;
};

export type VideoContentType = {
  __typename?: 'VideoContentType';
  /** A localized version of the content type for display purposes */
  displayName: LocalizedString;
  /**
   * The ID of the content type. This should not be hard-coded, and should always be fetched at runtime.
   * These IDs may change over time
   */
  id: Scalars['ID']['output'];
};

export enum VideoContentTypeId {
  Clip = 'CLIP',
  DemoReel = 'DEMO_REEL',
  Featurette = 'FEATURETTE',
  FeatureFilm = 'FEATURE_FILM',
  FilmShort = 'FILM_SHORT',
  Interview = 'INTERVIEW',
  MusicVideo = 'MUSIC_VIDEO',
  News = 'NEWS',
  Other = 'OTHER',
  Promotional = 'PROMOTIONAL',
  Review = 'REVIEW',
  Trailer = 'TRAILER',
  TvMinisode = 'TV_MINISODE',
  TvProgram = 'TV_PROGRAM',
  WebClip = 'WEB_CLIP'
}

/** IMDb supports a number of resolutions for the video/mp4 and video/webm mime types. */
export enum VideoDefinition {
  Def_240p = 'DEF_240p',
  Def_360p = 'DEF_360p',
  Def_480p = 'DEF_480p',
  Def_720p = 'DEF_720p',
  Def_1080p = 'DEF_1080p',
  DefAuto = 'DEF_AUTO',
  DefSd = 'DEF_SD'
}

export type VideoDimensions = {
  __typename?: 'VideoDimensions';
  /**
   * The bucketed classification of the video's aspect ratio, either VERTICAL HORIZONTAL or SQUARE
   * This value is primarily meant for logging metadata, and as such these buckets are subject to change
   * and should not be assumed to apply to any particular aspect ratio
   */
  appearance: VideoAppearance;
  /** The aspect ratio of the video expressed as a value X where X:1 is the aspect ratio */
  aspectRatio: Scalars['Float']['output'];
  /** The height of the source uploaded video file in pixels. Note that individual encodings may have smaller values due to scaling */
  height: Scalars['Int']['output'];
  /** The width of the source uploaded video file in pixels. Note that individual encodings may have smaller values due to scaling */
  width: Scalars['Int']['output'];
};

export type VideoEdge = {
  __typename?: 'VideoEdge';
  cursor: Scalars['ID']['output'];
  node: Video;
  position: Scalars['Int']['output'];
};

/**
 * Response facets are impacted by the VideosQueryFilter. All types, nameConstraints, and titleConstraints filter options
 * will be included in the facet results, even if just set to a count of 0
 */
export type VideoFacets = {
  __typename?: 'VideoFacets';
  /** Video names with counts of how many videos are of that name, sorted by their counts in descending order */
  names?: Maybe<Array<Maybe<VideoNameFacet>>>;
  /** Video titles with counts of how many videos are of that title, sorted by their counts in descending order */
  titles?: Maybe<Array<Maybe<VideoTitleFacet>>>;
  /** Video types with counts of how many videos are of that type, sorted by their counts in descending order */
  types?: Maybe<Array<Maybe<VideoTypeFacet>>>;
};

export type VideoMedia = {
  __typename?: 'VideoMedia';
  /** IMDb viconst */
  id: Scalars['ID']['output'];
  name: LocalizedString;
  primaryImage?: Maybe<MediaServiceImage>;
  runtime?: Maybe<VideoRuntime>;
};

/**
 * MIME is an internet standard that explains the kind of file, in this case we support
 * the following video types.
 *
 * https://en.wikipedia.org/wiki/MIME
 */
export enum VideoMimeType {
  /**
   * A computer file format for a multimedia playlist. One common use of the M3U file format is
   * creating a single-entry playlist file pointing to a stream on the Internet - application/x-mpegurl
   * https://en.wikipedia.org/wiki/M3U
   */
  M3U8 = 'M3U8',
  /**
   * The ISO standard video file format based on Quicktime - video/mp4
   * https://www.iana.org/assignments/media-types/video/mp4
   */
  Mp4 = 'MP4',
  /**
   * A video file format designed as a royalty-free alternative to use in HTML5 video - video/webm
   * https://en.wikipedia.org/wiki/WebM
   */
  Webm = 'WEBM'
}

/** Provides information on how many videos in a gallery match the specified video name */
export type VideoNameFacet = {
  __typename?: 'VideoNameFacet';
  name: Name;
  total: Scalars['Int']['output'];
};

export type VideoNameFilterConstraints = {
  /** Match videos related to all of the requested names */
  allNameIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type VideoNameRelationConnection = {
  __typename?: 'VideoNameRelationConnection';
  /** List of name relations */
  edges: Array<Maybe<VideoNameRelationEdge>>;
  /** Additional information useful for pagination */
  pageInfo: PageInfo;
  /** Total number of names related to this video */
  total: Scalars['Int']['output'];
};

export type VideoNameRelationEdge = {
  __typename?: 'VideoNameRelationEdge';
  cursor: Scalars['ID']['output'];
  node: Name;
  position: Scalars['Int']['output'];
};

/** Enum representing how a video ad is played in the context of the content on a page. */
export enum VideoPlacementType {
  /** Video ad that plays after the video content on the page. */
  Postroll = 'POSTROLL',
  /** Video ad that plays prior to video content on the page. */
  Preroll = 'PREROLL'
}

export type VideoProviderType = {
  __typename?: 'VideoProviderType';
  /** The ID representing the Video source provider type. eg: 'amzn1.imdb.video.providertype.staff' */
  id: Scalars['ID']['output'];
};

/**
 * Clients are to request the corresponding ad data. See VideoRecommendationsAdType documentation for corresponding queries.
 * Any other metadata for ads in this context goes here
 */
export type VideoRecommendationsAdItem = {
  __typename?: 'VideoRecommendationsAdItem';
  adType: VideoRecommendationsAdType;
  transitionDelay?: Maybe<Scalars['Float']['output']>;
};

/**
 * An enum representing which ad types are supported in Query.videoRecommendations
 *
 * DISPLAY_AD indicates a call to
 *  - Query.displayAdForApp, for apps
 */
export enum VideoRecommendationsAdType {
  DisplayAd = 'DISPLAY_AD'
}

export type VideoRecommendationsConnection = {
  __typename?: 'VideoRecommendationsConnection';
  edges: Array<Maybe<VideoRecommendationsItemsEdge>>;
  pageInfo: PageInfo;
};

export type VideoRecommendationsContext = {
  /** Specifies how the videos will be displayed to customers */
  displayType: VideoRecommendationsDisplayType;
  /**
   * A list of the different VideoRecommendationsAdType(s) which are supported by clients
   * Only VideoRecommendationsAdType(s) specified in supportedAdTypes will be returned
   * If supportedAdTypes is empty, there will be no ads returned
   */
  supportedAdTypes: Array<InputMaybe<VideoRecommendationsAdType>>;
};

/** Different options for how the videos will be displayed to customers */
export enum VideoRecommendationsDisplayType {
  /** PORTRAIT_ORIENTATION indicates the videos will all be shown in a portrait video player */
  PortraitOrientation = 'PORTRAIT_ORIENTATION'
}

export type VideoRecommendationsItem = VideoRecommendationsAdItem | VideoRecommendationsVideoItem;

export type VideoRecommendationsItemsEdge = {
  __typename?: 'VideoRecommendationsItemsEdge';
  cursor: Scalars['ID']['output'];
  node: VideoRecommendationsItem;
};

/**
 * The video to be displayed to customers
 * Any other metadata for the video in this context goes here
 *
 * 'video' will be null when we try to return a video that is unavailable (e.g. availability block, geo-block)
 */
export type VideoRecommendationsVideoItem = {
  __typename?: 'VideoRecommendationsVideoItem';
  video?: Maybe<Video>;
};

/** Types */
export type VideoRuntime = {
  __typename?: 'VideoRuntime';
  unit: TimeUnit;
  value: Scalars['Int']['output'];
};

export type VideoSort = {
  by: VideoSortBy;
  order: SortOrder;
};

export enum VideoSortBy {
  Date = 'DATE',
  Duration = 'DURATION'
}

/**
 * Represents a single VideoTimedTextTrack that can be used to display text that is synced with a video's audio during
 * video playback. Contains a URL, language, and a descriptive displayName. For a given video language (ex. en-US) pairing
 * only a single VideoTimedTextTrack will be returned, based on accessibility criteria defined by business.
 */
export type VideoTimedTextTrack = {
  __typename?: 'VideoTimedTextTrack';
  /**
   * A short description of the VideoTimedTextTrack experience suitable for displaying to the customer to set
   * expectations. This may be used in the video player menu. The displayName language is the language of the
   * VideoTimedTextTrack. (Ex. `English` for `en-US`, `Franaise` for`fr-FR`)
   */
  displayName: LocalizedString;
  /** The language for a VideoTimedTextTrack */
  language: Scalars['Language']['output'];
  /**
   * A fragment to include in ref markers that references this VideoTimedTextTrack, for example 'cc-es-SP'.
   * The length of this string will not exceed 11 characters.
   */
  refTagFragment: Scalars['String']['output'];
  /** The type for a VideoTimedTextTrack */
  type: VideoTimedTextTrackType;
  /**
   * A URL that can be used in a video player to display the contents of the VideoTimedTextTrack.
   * It may or may not be valid for a limited time and thus is intended for immediate use by the caller.
   */
  url: Scalars['URL']['output'];
};

/** The VideoTimedTextTrackFormat format(s) supported by IMDb */
export enum VideoTimedTextTrackFormat {
  /** SubRip Subtitle */
  Srt = 'SRT'
}

/** The VideoTimedTextTrackType types supported by IMDb */
export enum VideoTimedTextTrackType {
  ClosedCaption = 'CLOSED_CAPTION',
  Subtitle = 'SUBTITLE'
}

export type VideoTimedTextTracksFilter = {
  /** If no VideoTimedTextTrackFormat is provided it will default to SRT. */
  format?: InputMaybe<VideoTimedTextTrackFormat>;
};

/** Provides information on how many videos in a gallery match the specified video title */
export type VideoTitleFacet = {
  __typename?: 'VideoTitleFacet';
  title: Title;
  total: Scalars['Int']['output'];
};

export type VideoTitleFilterConstraints = {
  /** Match videos related to any of the requested titles */
  anyTitleIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type VideoTitleRelationConnection = {
  __typename?: 'VideoTitleRelationConnection';
  /** List of title relations */
  edges: Array<Maybe<VideoTitleRelationEdge>>;
  /** Additional information useful for pagination */
  pageInfo: PageInfo;
  /** Total number of names related to this video */
  total: Scalars['Int']['output'];
};

export type VideoTitleRelationEdge = {
  __typename?: 'VideoTitleRelationEdge';
  cursor: Scalars['ID']['output'];
  node: Title;
  position: Scalars['Int']['output'];
};

/** Provides information on how many videos in a gallery match the specified video type */
export type VideoTypeFacet = {
  __typename?: 'VideoTypeFacet';
  total: Scalars['Int']['output'];
  /** Video Type information including display label */
  type: VideoContentType;
};

export type VideoTypeWithVideos = {
  __typename?: 'VideoTypeWithVideos';
  /** The video type common for all of the associated videos */
  videoType: VideoContentType;
  /** The first page of videos in each category */
  videos?: Maybe<VideoTypesConnection>;
};


export type VideoTypeWithVideosVideosArgs = {
  first: Scalars['Int']['input'];
};

/** Pagination for videos by type, page info is intended for use with the related videos field */
export type VideoTypesConnection = {
  __typename?: 'VideoTypesConnection';
  edges: Array<Maybe<VideoEdge>>;
  pageInfo: PageInfo;
  /** Total number of objects in the entire set */
  total: Scalars['Int']['output'];
};

export type VideosQueryFilter = {
  /**
   * Match videos based on their maturity classification.
   * Affects all values, including actual videos returned and total videos count.
   */
  maturityLevel?: InputMaybe<MaturityLevel>;
  /** Return videos meeting the specified names */
  nameConstraints?: InputMaybe<VideoNameFilterConstraints>;
  /** Return videos meeting the specified titles */
  titleConstraints?: InputMaybe<VideoTitleFilterConstraints>;
  /** Return only videos which are one of these types */
  types?: InputMaybe<Array<InputMaybe<VideoContentTypeId>>>;
};

export type ViewPortSize = {
  height: Scalars['Int']['input'];
  width: Scalars['Int']['input'];
};

/** Enum values for the valid visibility levels for data items */
export enum VisibilityLevel {
  Hidden = 'HIDDEN',
  ProSiteOnly = 'PRO_SITE_ONLY',
  Public = 'PUBLIC'
}

export type WatchOption = {
  __typename?: 'WatchOption';
  /** Description of the watch option with more details. */
  description?: Maybe<LocalizedString>;
  /** Returns a link that navigates either to the content or a landing page for the content. */
  link: Scalars['URL']['output'];
  /**
   * Returns true if the watch option's provider is promoted. False or null means that it is not promoted
   * Promoted provider feature is no longer supported by the Ads team - https://sim.amazon.com/issues/W2W-170. The field will always return false.
   */
  promoted?: Maybe<Scalars['Boolean']['output']>;
  /** Provider of the watch option */
  provider: WatchProvider;
  /** The name of the provider for the watch option. */
  providerName: LocalizedString;
  /** The provider suffix that can be added to the refTag attached to the link */
  providerRefTagFragment: Scalars['String']['output'];
  /** Description of the watch option with shortened details. */
  shortDescription?: Maybe<LocalizedString>;
  /**
   * The short display text for the watch option. (call to action for the button)
   * This can be used for buttons where concise naming is required.
   */
  shortTitle: LocalizedString;
  /**
   * The display text for the watch option. (call to action for the button)
   * This can be used for a descriptive call to action.
   */
  title: LocalizedString;
};


export type WatchOptionLinkArgs = {
  platform: PlatformLinkFormatId;
};

/**
 * Watch option category types.
 *
 * There is no filtering support for below category types; graphlet will throw an exception.
 * These are present in the enum due to them being valid response watch option category types for other APIs.
 * Not all APIs support filtering:
 *     - PHYSICAL
 *
 * IMDbTV is no longer a supported watch option category type. Using the enum will not have any effect.
 */
export enum WatchOptionCategoryType {
  ImdbTv = 'IMDB_TV',
  Physical = 'PHYSICAL',
  Podcast = 'PODCAST',
  RentOrBuy = 'RENT_OR_BUY',
  Subscription = 'SUBSCRIPTION',
  Theatrical = 'THEATRICAL'
}

/** The filters to be used in the query. */
export type WatchOptionQueryFilter = {
  /** Include watch options for provided watch option categories only. */
  includeWatchOptionCategories?: InputMaybe<Array<InputMaybe<WatchOptionCategoryType>>>;
};

/**
 * The location of the client. A lat/long or postal code location must be given for the client input to be valid. If both
 * lat/long and postal code are provided we default to using lat/long.
 */
export type WatchOptionsLocation = {
  latLong?: InputMaybe<LatLong>;
  postalCodeLocation?: InputMaybe<PostalCodeLocation>;
};

/**
 * Watch option constraints are limited to region of the request.
 * Region is determined by the x-imdb-detected-country header (gateway determines from request).
 *
 * WatchOptionsSearchConstraint currently supports a limited set of providers:
 * * 'amzn1.imdb.w2w.provider.amazon' (Amazon physical purchase)
 * * 'amzn1.imdb.w2w.provider.prime_video': (Prime Video purchase/rental)
 * * 'amzn1.imdb.w2w.provider.prime_video.PRIME' (Prime Video subscription)
 *
 * Example: if you want to match titles that are available for purchase/rent on Prime Video in the US,
 * specify anyWatchProviderIds: ['amzn1.imdb.w2w.provider.prime_video'] AND anyWatchRegions: ['US']
 *
 * Example: if you want to exclude titles that are available for physical purchase on Amazon in the UK,
 * specify excludeAnyWatchProviderIds: ['amzn1.imdb.w2w.provider.amazon'] AND anyWatchRegions: ['GB']
 */
export type WatchOptionsSearchConstraint = {
  /**
   * Match titles WITH watch options by the specified providers.
   * * Use query `watchProviders` to fetch a curated list of options to use for this constraint.
   */
  anyWatchProviderIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Match titles that are available to watch in any of the specified regions. Regions supplied
   * in this field will override values from the x-imdb-detected-country header for all
   * watch option constraints.
   *
   * Country code in ISO 3166 (IMDbLocaleConfig:region_codes.json)
   * Example: To limit to Watch Provider availability in United States or Great Britain: ['US', 'GB']
   */
  anyWatchRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Match titles WITHOUT watch options by the specified providers.
   * * Use query `watchProviders` to fetch a curated list of options to use for this constraint.
   *
   * If the same input is specified in the any and exclude constraints,
   * then the results should be empty.
   */
  excludeWatchProviderIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Override the regions to exclude for the given request.
   * Country code in ISO 3166 (IMDbLocaleConfig:region_codes.json)
   * Example: To exclude Watch Provider availability from United States or Great Britain: ['US', 'GB']
   */
  excludeWatchRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Match titles that have the specified type of watch options. */
  hasWatchOptionTypes?: InputMaybe<Array<InputMaybe<SearchWatchOptionType>>>;
};

export type WatchProvider = {
  __typename?: 'WatchProvider';
  /**
   * Description of the watch option with more details.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  description?: Maybe<LocalizedString>;
  /**
   * ---------------------
   * Graphlet Details:
   * - Name: identity
   * - CTI: IMDb/GraphQL/Identity
   * - Affected by headers: x-amzn-transitive-authentication-token, x-imdb-customer-id, x-amzn-customer-id, x-auth-session-customer-id, x-amzn-sessionid, x-imdb-client-ip, x-imdb-client-name, x-imdb-detected-country, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-trust
   */
  id: Scalars['ID']['output'];
  /**
   * Indicates whether the provider is a popular one in the client's region
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  isPopular: Scalars['Boolean']['output'];
  /**
   * Indicates whether the watch provider is supported for the client's location and platform
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  isSupported: Scalars['Boolean']['output'];
  /**
   * Watch provider logos.
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  logos?: Maybe<WatchProviderLogos>;
  /**
   * The name of this watch option provider, for example 'Prime Video'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  name: LocalizedString;
  /**
   * Fragment to include in ref markers that reference this WatchProvider, for example 'netflix'
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  refTagFragment: Scalars['String']['output'];
  /**
   * Category type which describes the watch provider so client can categorize
   *
   * ---------------------
   * Graphlet Details:
   * - Name: watch
   * - CTI: IMDb/GraphQL/Watch
   * - Affected by headers: x-imdb-client-name, x-imdb-client-version, x-imdb-detected-country, x-imdb-detected-time-zone, x-imdb-user-language
   * - Cache TTL: Varies. Reach out to graphlet owner
   * - Slack Channel: #imdb-coverage-tech
   */
  watchOptionCategoryType?: Maybe<WatchOptionCategoryType>;
};


export type WatchProviderIsSupportedArgs = {
  platform: PlatformId;
};

export type WatchProviderConnection = {
  __typename?: 'WatchProviderConnection';
  edges: Array<Maybe<WatchProviderEdge>>;
  pageInfo: PageInfo;
};

export type WatchProviderEdge = {
  __typename?: 'WatchProviderEdge';
  cursor: Scalars['ID']['output'];
  node: WatchProvider;
};

/** Types */
export type WatchProviderLogos = {
  __typename?: 'WatchProviderLogos';
  /** Square image. Ex. It may be used in front of providers in the WatchOptions dialog */
  icon?: Maybe<MediaServiceImage>;
  /** Rectangular image. Ex. It may be used as a slate in the WatchOptions carousel */
  slate?: Maybe<MediaServiceImage>;
};

/** The filters to be used in the watch providers query. */
export type WatchProvidersQueryFilter = {
  /** Include watch options for provided watch option categories only. */
  includeWatchOptionCategories?: InputMaybe<Array<InputMaybe<WatchOptionCategoryType>>>;
};

export type WatchedStatus = {
  __typename?: 'WatchedStatus';
  /** The time the first watch signal was received. */
  firstWatched?: Maybe<Scalars['DateTime']['output']>;
  /** Whether this title has been watched before. */
  isWatched: Scalars['Boolean']['output'];
  /** Lists all the sources of the remaining watch signals. */
  remainingWatchedSourceTypes?: Maybe<Array<Maybe<TitleWatchedSourceType>>>;
};

export type WatchedTitleEdge = {
  __typename?: 'WatchedTitleEdge';
  cursor: Scalars['ID']['output'];
  node: TitleWatchedStatus;
};

export type WatchedTitlesConnection = {
  __typename?: 'WatchedTitlesConnection';
  edges: Array<Maybe<WatchedTitleEdge>>;
  pageInfo: PageInfo;
  /** Total number of the titles this customer has watched. */
  total: Scalars['Int']['output'];
};

export enum WatchedTitlesSortBy {
  /** Sort by first watched date. */
  FirstWatchedDate = 'FIRST_WATCHED_DATE'
}

export type WatchlistStatistics = {
  __typename?: 'WatchlistStatistics';
  /** Displayable Count of total number of users who have added the title to their watchlist */
  displayableCount?: Maybe<LocalizedDisplayableCount>;
  /** The total number of users who have added the title to their watchlist */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/**
 * AdCreativeInfo with additional web-specific fields.
 * This should be merged with the AdSlot type used for apps in future schema consolidation.
 */
export type WebAdCreativeInfo = {
  __typename?: 'WebAdCreativeInfo';
  /** Type of ad product, provided if ad contains creative from Amazon Ad Exchange */
  aaxAdType?: Maybe<Scalars['String']['output']>;
  /** Ad product type information, provided if ad contains creative */
  adProductType?: Maybe<AdProductType>;
  /** ID of the creative, provided if ad contains creative */
  creativeId?: Maybe<Scalars['String']['output']>;
  /** Flag that determines if the ad slot is eligible to run 3p auction */
  isEligibleFor3pAd: Scalars['Boolean']['output'];
  /** Flag that determines if the slot is eligible for automatic ad refresh */
  isEligibleForRefresh: Scalars['Boolean']['output'];
  /** Flag used to communicate if the ad returned is premium */
  isPremium: Scalars['Boolean']['output'];
  /** Height and width of the returned creative */
  size: CreativeSize;
  /** HTML markup for the slot containing the ad creative */
  slotMarkup: Scalars['String']['output'];
};

/**
 * AdSlot with additional web-specific fields.
 * This should be merged with the AdSlot type used for apps in future schema consolidation.
 */
export type WebAdSlot = {
  __typename?: 'WebAdSlot';
  /**
   * Ad feedback URL to be linked in the sponsored label of the ad.
   * This will be null for ad slots not containing a creative, such as the SIS pixel or placeholders.
   */
  adFeedbackUrl?: Maybe<Scalars['URL']['output']>;
  /** The creative metadata and slotsMarkup returned for the given ad slot */
  creativeInfo: WebAdCreativeInfo;
  /** The name of the ad slot */
  name: Scalars['String']['output'];
};

/** Parameters specific to web ad targeting */
export type WebAdTargetingParameters = {
  /**
   * True if the client is requesting content that meets the AdBlockPlus Acceptable Ads program,
   * false if the request is for standard ad content.
   */
  isAbpAcceptable: Scalars['Boolean']['input'];
  /** The IMDb site variant on which the ads are intended to be shown */
  site: AdSite;
  /**
   * Mappings of requested ad slot names to requested ad slot sizes.
   * Required for non-mobile sites, but is optional in the schema.
   * The resolver is responsible for safely handling empty input.
   */
  slotSizeMap?: InputMaybe<Array<InputMaybe<SlotSize>>>;
  /**
   * URL of the page being targeted.
   * If not provided, defaults to homepage URL corresponding to site field.
   */
  url?: InputMaybe<Scalars['URL']['input']>;
};

/** Output from the webAdsConfig operation containing all information needed to request ads */
export type WebAdsConfigOutput = {
  __typename?: 'WebAdsConfigOutput';
  /** APS slot information for Amazon Publisher Services integration */
  apsSlotInfoMap: Array<Maybe<WebApsSlotInfo>>;
  /**
   * Flag indicating if ads slots are enabled on the page.
   * This can be false if ads are blocked by targeting, not allowed on a specific page,
   * or if the BigRedButton is used to disable display ads.
   */
  areSlotsEnabled: Scalars['Boolean']['output'];
  /** Flag indicating if the page has premium ads */
  hasPremiumAd: Scalars['Boolean']['output'];
  /** HTML markup to be included in the head of the document */
  headerMarkup: Scalars['String']['output'];
  /** Flag indicating if ad refresh is enabled */
  isAdRefreshEnabled: Scalars['Boolean']['output'];
  /** PLAID overrides for the page */
  plaidOverrides: Array<Maybe<PlaidOverride>>;
  /** Breakpoint to ad size mappings for responsive AdSlot */
  responsiveSlotSizes: Array<Maybe<WebResponsiveSlotSize>>;
  /** List of ad slots available on the page */
  slots: Array<Maybe<WebAdSlot>>;
};

/**
 * Parameters used to make a display ad request for web pages.
 * Note: There is some ambiguity between AdParametersWeb and WebAdTargetingParameters, each of which predate
 * the web ads schemas, and must be extended to capture all parameters for web display ads.
 * In the future, inputs for ad request resolvers should be consolidated to contain one platform-specific parameters
 * object (e.g. app vs. web), and one that is format specific (e.g. display vs. video).
 * SIM for schema consolidation: https://sim.amazon.com/issues/IMDBADTECH-5463
 */
export type WebAdsInput = {
  /**
   * A set of parameters needed from web clients to target ads.
   * These parameters include page type, subpage type, and other targeting information.
   * This input type is shared with the video ad for web resolver schema.
   */
  adParameters: AdParametersWeb;
  /** A set of parameters used to target display ads, across all site variants */
  displayAdTargetingParameters: DisplayAdTargetingParameters;
  /**
   * A set of parameters specific to web ad targeting, across ad formats.
   * This input type is shared with the display ad for app resolver schema.
   */
  webAdTargetingParameters: WebAdTargetingParameters;
};

/** Output for the webAds query */
export type WebAdsOutput = {
  __typename?: 'WebAdsOutput';
  /** Flag indicating if any premium ads are present */
  hasPremiumAd: Scalars['Boolean']['output'];
  /**
   * Flag indicating if request was for automatic ad refresh.
   * The resolver will set this as true if refreshableSlots input was populated.
   */
  isRefreshRequest: Scalars['Boolean']['output'];
  /** Mapping of slots with resizing re-fetch disabled to their blocked breakpoints */
  responsiveResizingDisabledSlots: Array<Maybe<WebResponsiveResizingDisabledSlot>>;
  /** A list of ad slots and their creative info */
  slots: Array<Maybe<WebAdSlot>>;
};

/** Information about an APS slot for Amazon Publisher Services integration */
export type WebApsSlotInfo = {
  __typename?: 'WebApsSlotInfo';
  /** Identifiers for the ad slot */
  apsSlot: ApsSlot;
  /** Parameters for the ad slot */
  apsSlotParams: Array<Maybe<ApsSlotParam>>;
  /** The name of the ad slot */
  slotName: Scalars['String']['output'];
};

/** Viewport breakpoint with disabled flag */
export type WebResponsiveResizingDisabledBreakpoint = {
  __typename?: 'WebResponsiveResizingDisabledBreakpoint';
  /** The width in pixels of the breakpoint */
  breakpoint: Scalars['Int']['output'];
  /** Whether responsive resizing is disabled for this breakpoint */
  isDisabled: Scalars['Boolean']['output'];
};

/** Slot with responsive resizing disabled */
export type WebResponsiveResizingDisabledSlot = {
  __typename?: 'WebResponsiveResizingDisabledSlot';
  /** The breakpoints for which responsive resizing is disabled */
  breakpoints: Array<Maybe<WebResponsiveResizingDisabledBreakpoint>>;
  /** The name of the slot */
  name: Scalars['String']['output'];
};

/** Mapping between slot names and their size configurations for different viewport breakpoints */
export type WebResponsiveSlotSize = {
  __typename?: 'WebResponsiveSlotSize';
  /** List of viewport breakpoints and corresponding ad sizes */
  breakpoints: Array<Maybe<WebViewportBreakpointSlotSize>>;
  /** The name of the ad slot */
  slotName: Scalars['String']['output'];
};

/** Viewport breakpoint configuration for responsive ad sizing */
export type WebViewportBreakpointSlotSize = {
  __typename?: 'WebViewportBreakpointSlotSize';
  /** The maximum window width to serve this ad size */
  breakpoint: Scalars['Int']['output'];
  /** The ad size for this breakpoint (e.g. 728x90) */
  slotSize: CreativeSize;
};

export type WebsiteLink = {
  __typename?: 'WebsiteLink';
  label?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

export type WebviewVideoPlayer = {
  __typename?: 'WebviewVideoPlayer';
  /** Audio language of the video. */
  audioLanguage: Scalars['Language']['output'];
  /** Language of the burned-in captions. Returns null if there is no burned-in captions. */
  burnedInCaptionsLanguage?: Maybe<Scalars['Language']['output']>;
  /** Description of the video. */
  description?: Maybe<LocalizedString>;
  /**
   * The customized webview Url.
   * Client's info, which is got from the header, will be used to customize this Url
   * to contain client-related params.
   */
  webviewUrl: Scalars['String']['output'];
};

export enum WeightUnit {
  Kilogram = 'KILOGRAM',
  Pound = 'POUND'
}

/** Filter of wide-released or non-wide-released release dates */
export enum WideReleaseFilter {
  ExcludeWideRelease = 'EXCLUDE_WIDE_RELEASE',
  WideReleaseOnly = 'WIDE_RELEASE_ONLY'
}

export enum WinsFilter {
  ExcludeWins = 'EXCLUDE_WINS',
  WinsOnly = 'WINS_ONLY'
}

/**
 * The constraints here are combined (AND).
 *
 * examples:
 *
 * withNameDataConstraint: {
 *     allDataAvailable: [TRIVIA],
 *     noDataAvailable: [TRIVIA]
 * }
 *
 * will not match any names.
 *
 * withNameDataConstraint: {
 *     allDataAvailable: [TRIVIA, BIRTH_PLACE],
 *     anyDataAvailable: [BIRTH_DATE, QUOTES]
 *     noDataAvailable: [DEATH_PLACE]
 * }
 *
 * will match names that have (trivia data AND a birth place) AND no death place AND (either a birth date OR quotes).
 */
export type WithNameDataSearchConstraint = {
  /** Match names that have ALL of the selected data available */
  allDataAvailable?: InputMaybe<Array<InputMaybe<NameDataType>>>;
  /** Match names that have AT LEAST ONE of the selected data available */
  anyDataAvailable?: InputMaybe<Array<InputMaybe<NameDataType>>>;
  /** Match names that have NONE of the selected data available */
  noDataAvailable?: InputMaybe<Array<InputMaybe<NameDataType>>>;
};

export type WithTitleDataSearchConstraint = {
  /** Match titles that have ALL of these data available */
  allDataAvailable?: InputMaybe<Array<InputMaybe<TitleDataType>>>;
  /** Match titles that have AT LEAST ONE of these data available */
  anyDataAvailable?: InputMaybe<Array<InputMaybe<TitleDataType>>>;
  /** Match titles that do NOT have ALL of these data */
  noDataAvailable?: InputMaybe<Array<InputMaybe<TitleDataType>>>;
};

export type WorkAuthorizationCountries = {
  __typename?: 'WorkAuthorizationCountries';
  /** Total number of work authorization items for the person */
  total: Scalars['Int']['output'];
  /** The work authorization items matching input arguments (e.g. 'limit') */
  workAuthorizations: Array<Maybe<WorkAuthorizationInCountry>>;
};

export type WorkAuthorizationInCountry = {
  __typename?: 'WorkAuthorizationInCountry';
  /** A country */
  country: LocalizedDisplayableCountry;
  /** Whether authorized to work in this country */
  isAuthorized: Scalars['Boolean']['output'];
};

export type YearDisplayableProperty = {
  __typename?: 'YearDisplayableProperty';
  value: Markdown;
};

/** A range of years */
export type YearRange = {
  __typename?: 'YearRange';
  /** The end year */
  endYear?: Maybe<Scalars['Int']['output']>;
  /** The start year */
  year?: Maybe<Scalars['Int']['output']>;
};

export type GetMoreEpisodesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  episodeFilter?: InputMaybe<EpisodesFilter>;
  after: Scalars['ID']['input'];
}>;


export type GetMoreEpisodesQuery = { __typename?: 'Query', title?: { __typename?: 'Title', episodes?: { __typename?: 'Episodes', episodes?: { __typename?: 'EpisodeConnection', edges: Array<{ __typename?: 'EpisodeEdge', node: { __typename?: 'Title', id: string, series?: { __typename?: 'Series', displayableEpisodeNumber: { __typename?: 'DisplayableEpisodeNumber', displayableSeason: { __typename?: 'LocalizedDisplayableSeason', text: string }, episodeNumber: { __typename?: 'LocalizedDisplayableEpisodeNumber', text: string } } } | null } } | null>, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean } } | null } | null, series?: { __typename?: 'Series', series: { __typename?: 'Title', episodes?: { __typename?: 'Episodes', episodes?: { __typename?: 'EpisodeConnection', edges: Array<{ __typename?: 'EpisodeEdge', node: { __typename?: 'Title', id: string, series?: { __typename?: 'Series', displayableEpisodeNumber: { __typename?: 'DisplayableEpisodeNumber', displayableSeason: { __typename?: 'LocalizedDisplayableSeason', text: string }, episodeNumber: { __typename?: 'LocalizedDisplayableEpisodeNumber', text: string } } } | null } } | null>, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean } } | null } | null } } | null } | null };

export type TitleQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  episodeFilter?: InputMaybe<EpisodesFilter>;
}>;


export type TitleQuery = { __typename?: 'Query', title?: { __typename?: 'Title', id: string, episodes?: { __typename?: 'Episodes', episodes?: { __typename?: 'EpisodeConnection', edges: Array<{ __typename?: 'EpisodeEdge', node: { __typename?: 'Title', id: string, titleText?: { __typename?: 'TitleText', text: string } | null, series?: { __typename?: 'Series', displayableEpisodeNumber: { __typename?: 'DisplayableEpisodeNumber', displayableSeason: { __typename?: 'LocalizedDisplayableSeason', text: string }, episodeNumber: { __typename?: 'LocalizedDisplayableEpisodeNumber', text: string } } } | null, releaseDate?: { __typename?: 'ReleaseDate', day?: number | null, month?: number | null, year?: number | null } | null, runtime?: { __typename?: 'Runtime', seconds: number } | null } } | null>, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean } } | null } | null, series?: { __typename?: 'Series', series: { __typename?: 'Title', id: string, episodes?: { __typename?: 'Episodes', episodes?: { __typename?: 'EpisodeConnection', edges: Array<{ __typename?: 'EpisodeEdge', node: { __typename?: 'Title', id: string, titleText?: { __typename?: 'TitleText', text: string } | null, series?: { __typename?: 'Series', displayableEpisodeNumber: { __typename?: 'DisplayableEpisodeNumber', displayableSeason: { __typename?: 'LocalizedDisplayableSeason', text: string }, episodeNumber: { __typename?: 'LocalizedDisplayableEpisodeNumber', text: string } } } | null, releaseDate?: { __typename?: 'ReleaseDate', day?: number | null, month?: number | null, year?: number | null } | null, runtime?: { __typename?: 'Runtime', seconds: number } | null } } | null>, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean } } | null } | null }, displayableEpisodeNumber: { __typename?: 'DisplayableEpisodeNumber', displayableSeason: { __typename?: 'LocalizedDisplayableSeason', text: string }, episodeNumber: { __typename?: 'LocalizedDisplayableEpisodeNumber', text: string } } } | null } | null };

export type TitleSearchQueryVariables = Exact<{
  search: MainSearchOptions;
  episodeFilter?: InputMaybe<EpisodesFilter>;
}>;


export type TitleSearchQuery = { __typename?: 'Query', mainSearch?: { __typename?: 'MainSearchConnection', edges: Array<{ __typename?: 'MainSearchEdge', node: { __typename?: 'MainSearchNode', entity:
          | { __typename?: 'Company' }
          | { __typename?: 'Interest' }
          | { __typename?: 'Keyword' }
          | { __typename?: 'Name' }
          | { __typename?: 'NameProfession' }
          | { __typename?: 'ProfessionCategory' }
          | { __typename?: 'Title', id: string, runtime?: { __typename?: 'Runtime', seconds: number } | null, titleText?: { __typename?: 'TitleText', text: string } | null, originalTitleText?: { __typename?: 'TitleText', text: string } | null, akas?: { __typename?: 'AkaConnection', edges: Array<{ __typename?: 'AkaEdge', node: { __typename?: 'Aka', text: string } } | null> } | null, ratingsSummary?: { __typename?: 'RatingsSummary', voteCount: number } | null, series?: { __typename?: 'Series', series: { __typename?: 'Title', id: string, episodes?: { __typename?: 'Episodes', episodes?: { __typename?: 'EpisodeConnection', edges: Array<{ __typename?: 'EpisodeEdge', node: { __typename?: 'Title', id: string } } | null>, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean } } | null } | null }, displayableEpisodeNumber: { __typename?: 'DisplayableEpisodeNumber', displayableSeason: { __typename?: 'LocalizedDisplayableSeason', text: string }, episodeNumber: { __typename?: 'LocalizedDisplayableEpisodeNumber', text: string } } } | null }
         } } | null> } | null };


export const GetMoreEpisodesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetMoreEpisodes"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"episodeFilter"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"EpisodesFilter"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"after"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"title"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"episodes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"episodes"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"filter"},"value":{"kind":"Variable","name":{"kind":"Name","value":"episodeFilter"}}},{"kind":"Argument","name":{"kind":"Name","value":"sort"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"by"},"value":{"kind":"EnumValue","value":"EPISODE_THEN_RELEASE"}},{"kind":"ObjectField","name":{"kind":"Name","value":"order"},"value":{"kind":"EnumValue","value":"ASC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"IntValue","value":"500"}},{"kind":"Argument","name":{"kind":"Name","value":"after"},"value":{"kind":"Variable","name":{"kind":"Name","value":"after"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableEpisodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableSeason"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"episodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}}]}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"endCursor"}},{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"episodes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"episodes"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"filter"},"value":{"kind":"Variable","name":{"kind":"Name","value":"episodeFilter"}}},{"kind":"Argument","name":{"kind":"Name","value":"sort"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"by"},"value":{"kind":"EnumValue","value":"EPISODE_THEN_RELEASE"}},{"kind":"ObjectField","name":{"kind":"Name","value":"order"},"value":{"kind":"EnumValue","value":"ASC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"IntValue","value":"500"}},{"kind":"Argument","name":{"kind":"Name","value":"after"},"value":{"kind":"Variable","name":{"kind":"Name","value":"after"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableEpisodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableSeason"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"episodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}}]}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"endCursor"}},{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}}]}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetMoreEpisodesQuery, GetMoreEpisodesQueryVariables>;
export const TitleDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Title"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"episodeFilter"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"EpisodesFilter"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"title"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"episodes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"episodes"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"filter"},"value":{"kind":"Variable","name":{"kind":"Name","value":"episodeFilter"}}},{"kind":"Argument","name":{"kind":"Name","value":"sort"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"by"},"value":{"kind":"EnumValue","value":"EPISODE_THEN_RELEASE"}},{"kind":"ObjectField","name":{"kind":"Name","value":"order"},"value":{"kind":"EnumValue","value":"ASC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"IntValue","value":"500"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"titleText"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableEpisodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableSeason"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"episodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"releaseDate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"day"}},{"kind":"Field","name":{"kind":"Name","value":"month"}},{"kind":"Field","name":{"kind":"Name","value":"year"}}]}},{"kind":"Field","name":{"kind":"Name","value":"runtime"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"seconds"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"endCursor"}},{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"episodes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"episodes"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"filter"},"value":{"kind":"Variable","name":{"kind":"Name","value":"episodeFilter"}}},{"kind":"Argument","name":{"kind":"Name","value":"sort"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"by"},"value":{"kind":"EnumValue","value":"EPISODE_THEN_RELEASE"}},{"kind":"ObjectField","name":{"kind":"Name","value":"order"},"value":{"kind":"EnumValue","value":"ASC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"IntValue","value":"500"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"titleText"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableEpisodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableSeason"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"episodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"releaseDate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"day"}},{"kind":"Field","name":{"kind":"Name","value":"month"}},{"kind":"Field","name":{"kind":"Name","value":"year"}}]}},{"kind":"Field","name":{"kind":"Name","value":"runtime"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"seconds"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"endCursor"}},{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}}]}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"displayableEpisodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableSeason"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"episodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<TitleQuery, TitleQueryVariables>;
export const TitleSearchDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"TitleSearch"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"search"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"MainSearchOptions"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"episodeFilter"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"EpisodesFilter"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"mainSearch"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"IntValue","value":"20"}},{"kind":"Argument","name":{"kind":"Name","value":"options"},"value":{"kind":"Variable","name":{"kind":"Name","value":"search"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"entity"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Title"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"runtime"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"seconds"}}]}},{"kind":"Field","name":{"kind":"Name","value":"titleText"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"originalTitleText"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"akas"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"IntValue","value":"100"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"ratingsSummary"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"voteCount"}}]}},{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"series"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"episodes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"episodes"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"filter"},"value":{"kind":"Variable","name":{"kind":"Name","value":"episodeFilter"}}},{"kind":"Argument","name":{"kind":"Name","value":"sort"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"by"},"value":{"kind":"EnumValue","value":"EPISODE_THEN_RELEASE"}},{"kind":"ObjectField","name":{"kind":"Name","value":"order"},"value":{"kind":"EnumValue","value":"ASC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"IntValue","value":"500"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"endCursor"}},{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}}]}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"displayableEpisodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"displayableSeason"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}},{"kind":"Field","name":{"kind":"Name","value":"episodeNumber"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"text"}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<TitleSearchQuery, TitleSearchQueryVariables>;